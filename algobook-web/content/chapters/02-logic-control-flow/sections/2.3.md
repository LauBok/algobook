# Multi-Option Decision Structures with Elif

In Section 2.2, you discovered that nested if-else statements become difficult to read and maintain when dealing with multiple choices. The age category classifier exercise demonstrated this problem clearly - each additional condition required deeper indentation, creating a "staircase" effect that makes code hard to follow.

This section introduces `elif` statements that provide an elegant solution to multi-option decision problems. Elif statements enable clear, readable decision logic that would otherwise require complex nested structures.

## The Problem with Nested If Statements

Recall the age category classifier from section 2.2. Using nested if-else statements created increasingly deep indentation that was difficult to read:

```python-execute
# Nested if-else approach from section 2.2
age = 25

if age <= 12:
    print("Child")
else:
    if age <= 17:
        print("Teen")
    else:
        print("Adult")
```

This approach becomes even more problematic with additional categories. Consider a grade classification system:

```python-execute
# Deeply nested if-else for grade classification
score = 85

if score >= 90:
    print("Grade: A")
else:
    if score >= 80:
        print("Grade: B")
    else:
        if score >= 70:
            print("Grade: C")
        else:
            if score >= 60:
                print("Grade: D")
            else:
                print("Grade: F")
```

```warning title="Nested If-Else Problems"
The indentation grows with each condition, making the code difficult to read, modify, and debug. Adding new conditions requires restructuring existing logic.
```

## Elif Statements: The Solution

The `elif` (short for "else if") statement provides an alternative condition when the first condition fails. It creates a readable list of options that Python checks sequentially until it finds a match, eliminating the need for deep nesting.

The same grade logic becomes significantly cleaner:

```python-execute
# Much cleaner with elif!
score = 85

if score >= 90:
    print("Grade: A")
elif score >= 80:
    print("Grade: B")
elif score >= 70:
    print("Grade: C")
elif score >= 60:
    print("Grade: D")
else:
    print("Grade: F")

print("Grade assigned successfully.")
```

The age category classifier also becomes much more readable:

```python-execute
# Age classifier with elif - much cleaner!
age = 25

if age <= 12:
    print("Child")
elif age <= 17:
    print("Teen")
else:
    print("Adult")

print("Category assigned.")
```

Elif chains function like multiple-choice tests where only one answer can be selected:

- Python evaluates conditions from top to bottom
- Execution stops at the first True condition
- All remaining elif and else blocks are skipped
- Only one block executes per elif chain

### Elif Chain Structure

Every elif chain follows this logical pattern:

```python
if condition1:
    # First choice
elif condition2:
    # Second choice  
elif condition3:
    # Third choice
else:
    # Default choice (optional)
```

You can have as many `elif` statements as you need. The `else` at the end is optional, but it's a good safety net to catch any cases you might have missed.

## Practical Applications

### Contact Search Enhancement

Building on our contact search theme from previous sections, elif statements enable sophisticated contact classification and search options:

```python-execute
# Contact search with multiple search types
print("=== Contact Search System ===")
search_option = input("Search by (name/phone/email): ").lower()

if search_option == "name":
    target = input("Enter name to search: ")
    print(f"Searching contacts by name: {target}")
    print("Name search activated.")
elif search_option == "phone":
    target = input("Enter phone number: ")
    print(f"Searching contacts by phone: {target}")
    print("Phone search activated.")
elif search_option == "email":
    target = input("Enter email address: ")
    print(f"Searching contacts by email: {target}")
    print("Email search activated.")
else:
    print("Invalid search option!")
    print("Please choose name, phone, or email.")

print("Search system ready.")
```

### Contact Priority Classification

Different contacts may have different priority levels based on their relationship or importance:

```python-execute
# Contact priority system
print("=== Contact Priority System ===")
relationship = input("Contact relationship (family/work/friend/other): ").lower()

if relationship == "family":
    priority = "High"
    notification = "Immediate alerts enabled"
elif relationship == "work":
    priority = "High"
    notification = "Business hours alerts"
elif relationship == "friend":
    priority = "Medium"
    notification = "Standard notifications"
elif relationship == "other":
    priority = "Low"
    notification = "Minimal notifications"
else:
    priority = "Unknown"
    notification = "Default settings applied"

print(f"Priority level: {priority}")
print(f"Notification setting: {notification}")
```

### User Access Level System

Contact management systems often require different access levels for different types of users:

```python-execute
# User access level system
print("=== Contact System Access Control ===")
user_type = input("Enter user type (admin/manager/user/guest): ").lower()

if user_type == "admin":
    print("Full system access granted")
    print("Can add, edit, delete all contacts")
elif user_type == "manager":
    print("Manager access granted")
    print("Can view and edit contacts in your department")
elif user_type == "user":
    print("Standard user access granted")
    print("Can view and edit your own contacts")
elif user_type == "guest":
    print("Guest access granted")
    print("Can view public contact directory only")
else:
    print("Unknown user type - access denied")
    print("Please contact system administrator")

print("Access control check complete.")
```

### Combining Conditions with Logical Operators

Remember the logical operators (`and`, `or`, `not`) from section 2.1? They become even more powerful when combined with elif statements. You can create sophisticated decision criteria that consider multiple factors at once.

For contact systems, you might need to check multiple criteria to determine access permissions:

```python-execute
# Contact access with multiple criteria
print("=== Advanced Contact Access Control ===")
user_level = input("Enter user level (1-5): ")
department = input("Enter department (sales/hr/it/admin): ").lower()
is_manager_input = input("Are you a manager? (yes/no): ")
is_manager = is_manager_input.lower() == "yes"

user_level = int(user_level)

if user_level >= 5 and department == "admin":
    print("FULL ACCESS: All contacts and system settings")
elif user_level >= 4 and (department == "admin" or is_manager):
    print("MANAGER ACCESS: All contacts in your area")
elif user_level >= 3 and department in ["sales", "hr", "it"]:
    print("DEPARTMENT ACCESS: Contacts in your department")
elif user_level >= 2:
    print("STANDARD ACCESS: Your contacts and public directory")
else:
    print("LIMITED ACCESS: Public directory only")

print("Access level determined.")
```

### Simple Algorithmic Applications

Elif statements provide elegant solutions to common programming problems. Here are simplified examples that demonstrate the power of elif chains:

#### Number Classification

```python-execute
# Classify a number as positive, negative, or zero
print("=== Number Classifier ===")
number = float(input("Enter a number: "))

if number > 0:
    print(f"{number} is positive")
elif number < 0:
    print(f"{number} is negative")
else:
    print(f"{number} is zero")

print("Classification complete.")
```

#### Grade Point Average Calculator

```python-execute
# Convert letter grade to GPA points
print("=== GPA Calculator ===")
letter_grade = input("Enter letter grade (A/B/C/D/F): ").upper()

if letter_grade == "A":
    gpa_points = 4.0
    print(f"Grade {letter_grade} = {gpa_points} GPA points")
elif letter_grade == "B":
    gpa_points = 3.0
    print(f"Grade {letter_grade} = {gpa_points} GPA points")
elif letter_grade == "C":
    gpa_points = 2.0
    print(f"Grade {letter_grade} = {gpa_points} GPA points")
elif letter_grade == "D":
    gpa_points = 1.0
    print(f"Grade {letter_grade} = {gpa_points} GPA points")
elif letter_grade == "F":
    gpa_points = 0.0
    print(f"Grade {letter_grade} = {gpa_points} GPA points")
else:
    print("Invalid grade! Please enter A, B, C, D, or F.")

print("GPA calculation complete.")
```

## Assessment and Practice

### Grade Classification Exercise

```exercise
id: grade-classifier
title: Grade Classifier
description: Create a program that converts numerical scores to letter grades using elif statements.
difficulty: easy
echoInput: true
starterCode: |
  # Grade Classifier
  # Use elif statements to convert numerical scores to letter grades

  print("=== Grade Classifier ===")
  score = float(input("Enter numerical score (0-100): "))

  # Your task: Use elif statements to assign letter grades:
  # 90-100: "A"
  # 80-89: "B"
  # 70-79: "C"
  # 60-69: "D"
  # Below 60: "F"

  # Write your elif chain here:
testCases:
  - input: "95\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 95
      A
    hidden: false
  - input: "85\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 85
      B
    hidden: true
  - input: "75\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 75
      C
    hidden: true
  - input: "65\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 65
      D
    hidden: true
  - input: "55\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 55
      F
    hidden: true
  - input: "90\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 90
      A
    hidden: true
  - input: "80\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 80
      B
    hidden: true
  - input: "70\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 70
      C
    hidden: true
  - input: "60\n"
    expectedOutput: |
      === Grade Classifier ===
      Enter numerical score (0-100): 60
      D
    hidden: true
hints:
  - "Start with the highest score range first (90-100)"
  - "Use elif for each grade range"
  - "Don't forget the final else for failing grades"
  - "Each condition should check >= the minimum score for that grade"
solution: |
  print("=== Grade Classifier ===")
  score = float(input("Enter numerical score (0-100): "))

  if score >= 90:
      print("A")
  elif score >= 80:
      print("B")
  elif score >= 70:
      print("C")
  elif score >= 60:
      print("D")
  else:
      print("F")
```


### Check Your Understanding

```quiz
id: elif-basics
question: In an if-elif-else chain, how many blocks of code will execute?
options:
  - id: a
    text: "All blocks that have True conditions"
    correct: false
    explanation: Only the FIRST True condition executes, then Python skips the rest.
  - id: b
    text: "Exactly one block"
    correct: true
    explanation: Correct! Python executes the first True condition it finds, then skips all remaining elif and else blocks.
  - id: c
    text: "Only the if block"
    correct: false
    explanation: Any block can execute - if, elif, or else - depending on which condition is True first.
  - id: d
    text: "The if block and all elif blocks"
    correct: false
    explanation: Only one block executes total, not multiple blocks.
```

```quiz
id: elif-order
question: Why does order matter in elif chains?
options:
  - id: a
    text: "Python requires alphabetical order"
    correct: false
    explanation: Order has nothing to do with alphabetical sorting.
  - id: b
    text: "Python checks conditions from top to bottom and stops at the first True"
    correct: true
    explanation: Exactly! Python evaluates conditions in order and stops at the first True, so order affects which condition "wins".
  - id: c
    text: "Order doesn't matter at all"
    correct: false
    explanation: Order is very important! Different orders can produce different results.
  - id: d
    text: "The else block must come first"
    correct: false
    explanation: The else block always comes last, after all if and elif blocks.
```

```quiz
id: complex-conditions
question: What does `gpa >= 3.0 and sat_score >= 1200` evaluate to if gpa is 3.5 and sat_score is 1100?
options:
  - id: a
    text: "True"
    correct: false
    explanation: For 'and' to be True, BOTH conditions must be True. The SAT score condition (1100 >= 1200) is False.
  - id: b
    text: "False"
    correct: true
    explanation: Correct! While gpa >= 3.0 is True (3.5 >= 3.0), sat_score >= 1200 is False (1100 >= 1200), so True and False = False.
  - id: c
    text: "3.5"
    correct: false
    explanation: This logical expression evaluates to a boolean (True/False), not a number.
  - id: d
    text: "Error"
    correct: false
    explanation: This is valid syntax that evaluates to False.
```

## Summary

This section introduced elif statements as the solution to nested if-else complexity:

**Key Concepts:**
- **Elif statements:** Provide clean alternatives to deeply nested if-else structures
- **Sequential evaluation:** Python checks conditions from top to bottom, executing only the first True condition
- **Multiple choice logic:** Handle complex decision scenarios with multiple possible outcomes
- **Combining conditions:** Use logical operators with elif for sophisticated decision criteria
- **Practical applications:** Contact systems, access control, and classification problems

**Benefits of Elif:**
- **Improved readability:** Flat structure instead of nested indentation
- **Easier maintenance:** Adding new conditions doesn't require restructuring existing code
- **Clear logic flow:** Sequential evaluation makes the decision process obvious

**Connection to Contact Search:**
You can now handle multiple search options, user access levels, and contact classifications - all essential features for implementing the complete contact search system from section 1.1.

**What's Next:** The next section provides comprehensive practice that combines all the concepts from Chapter 2, preparing you to implement complete algorithmic solutions with sophisticated decision-making capabilities.
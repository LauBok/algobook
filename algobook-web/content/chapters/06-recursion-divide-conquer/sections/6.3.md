# Mathematical Recursion: Numbers and Sequences

Mathematics is full of recursive patterns. Many mathematical definitions are naturally recursive - they define something in terms of smaller versions of itself. Now that you understand how to implement recursive functions, let's explore some beautiful mathematical problems that showcase the power of recursive thinking.

## Learning Objectives

By the end of this section, you will be able to:
- Recognize recursive patterns in mathematical definitions
- Implement classic recursive mathematical functions (Fibonacci, GCD, power)
- Design recursive solutions for mathematical problems systematically
- Understand how recursive mathematical definitions translate to code
- Optimize basic recursive functions using mathematical insights

## Why Mathematics and Recursion Go Together

Many mathematical concepts are defined recursively:

- **Factorials**: $n! = n \times (n-1)!$ with $1! = 1$
- **Fibonacci sequence**: $F(n) = F(n-1) + F(n-2)$ with $F(1) = 1, F(2) = 1$  
- **Exponentiation**: $a^n = a \times a^{n-1}$ with $a^0 = 1$
- **Greatest Common Divisor**: $\gcd(a,b) = \gcd(b, a \bmod b)$ with $\gcd(a,0) = a$

The recursive definition often **is** the most natural way to think about these problems!

```note title="Mathematical Recursion vs. Programming Recursion"
In mathematics, recursive definitions are common because they're often the most elegant way to define sequences and operations. In programming, we translate these mathematical definitions almost directly into code.
```

## The Fibonacci Sequence: A Classic Example

The **Fibonacci sequence** is one of the most famous recursive mathematical patterns:
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...

**Pattern**: Each number is the sum of the two preceding numbers.

**Mathematical definition**:
- $F(1) = 1$
- $F(2) = 1$  
- $F(n) = F(n-1) + F(n-2)$ for $n > 2$

This definition is **inherently recursive** - it's hard to think about it any other way!

### Implementing Fibonacci Recursively

```python-execute
def fibonacci(n):
    # Base cases: the first two Fibonacci numbers
    if n == 1 or n == 2:
        return 1
    
    # Recursive case: F(n) = F(n-1) + F(n-2)
    return fibonacci(n - 1) + fibonacci(n - 2)

# Test it out
print("First 8 Fibonacci numbers:")
for i in range(1, 9):
    print(f"F({i}) = {fibonacci(i)}")
```

### Tracing Fibonacci: Why Two Recursive Calls?

Unlike our previous examples, `fibonacci()` makes **two recursive calls**. Let's trace `fibonacci(5)`:

```
fibonacci(5)
├── fibonacci(4)
│   ├── fibonacci(3)
│   │   ├── fibonacci(2) → 1
│   │   └── fibonacci(1) → 1
│   └── fibonacci(2) → 1
└── fibonacci(3)
    ├── fibonacci(2) → 1
    └── fibonacci(1) → 1
```

Notice that `fibonacci(3)` is calculated **twice**! This is inefficient but shows the pure recursive approach.

```callstack-visualizer
id: fibonacci-stack-demo
title: Fibonacci Call Stack Visualization
description: Watch how Fibonacci creates a branching call tree! Notice how functions stack up deeply before returning, and see the same calculations repeated multiple times. This shows why recursive Fibonacci is inefficient for large numbers.
functionName: fibonacci
showCountdown: false
showFactorial: false
showFibonacci: true
```

The widget above shows the **branching nature** of Fibonacci recursion:

- **Deep stacking**: Watch how the stack grows very deep before any functions return
- **Two calls per function**: Each fibonacci(n) makes two recursive calls  
- **Repeated calculations**: You'll see the same fibonacci numbers calculated multiple times
- **Complex execution order**: Functions return in a specific order determined by the call tree

This visualization makes it clear why recursive Fibonacci becomes slow for larger numbers - the same work gets repeated many times!

```warning title="Fibonacci Inefficiency"
The recursive Fibonacci function recalculates the same values many times. For large n, this becomes very slow! Later in your studies, you'll learn optimization techniques like memoization to fix this.
```

Let's see this inefficiency in action with a timing demonstration:

```python-execute
import time

def fibonacci_with_count(n, call_count=[0]):
    call_count[0] += 1
    if n == 1 or n == 2:
        return 1
    return fibonacci_with_count(n - 1, call_count) + fibonacci_with_count(n - 2, call_count)

# Test different values and see how the number of calls explodes
for test_n in [10, 15, 20]:
    call_count = [0]
    start_time = time.time()
    result = fibonacci_with_count(test_n, call_count)
    end_time = time.time()
    
    print(f"fibonacci({test_n}) = {result}")
    print(f"Function calls made: {call_count[0]}")
    print(f"Time taken: {end_time - start_time:.4f} seconds")
    print()

print("Notice how the number of calls grows exponentially!")
print("fibonacci(10) needs dozens of calls, fibonacci(20) needs thousands!")
```

## Greatest Common Divisor: Ancient Algorithm, Modern Recursion

The **Greatest Common Divisor (GCD)** of two numbers is the largest number that divides both evenly.

**Examples**:
- $\gcd(12, 8) = 4$ (since 4 divides both 12 and 8, and no larger number does)
- $\gcd(17, 13) = 1$ (17 and 13 are coprime)

**Euclid's Algorithm** (over 2000 years old!) is naturally recursive:
- $\gcd(a, 0) = a$ (base case)
- $\gcd(a, b) = \gcd(b, a \bmod b)$ (recursive case)

But wait - what does $a \bmod b$ mean? The **mod operator** (`%` in Python) gives you the **remainder** when you divide $a$ by $b$. For example:
- $17 \bmod 5 = 2$ (because $17 \div 5 = 3$ remainder $2$)
- $48 \bmod 18 = 12$ (because $48 \div 18 = 2$ remainder $12$)
- $15 \bmod 3 = 0$ (because $15 \div 3 = 5$ remainder $0$)

This remainder operation is the key to why Euclid's algorithm works!

```python-execute
def gcd(a, b):
    # Base case: when b is 0, the GCD is a
    if b == 0:
        return a
    
    # Recursive case: gcd(a,b) = gcd(b, a mod b)
    return gcd(b, a % b)

# Test it
print(f"gcd(12, 8) = {gcd(12, 8)}")
print(f"gcd(17, 13) = {gcd(17, 13)}")
print(f"gcd(48, 18) = {gcd(48, 18)}")

# Let's trace gcd(48, 18) step by step
print("\nTracing gcd(48, 18):")
print("gcd(48, 18) → gcd(18, 48%18) → gcd(18, 12)")
print("gcd(18, 12) → gcd(12, 18%12) → gcd(12, 6)")  
print("gcd(12, 6) → gcd(6, 12%6) → gcd(6, 0)")
print("gcd(6, 0) → 6 (base case)")
```

```hint title="Why Euclid's Algorithm Works"
The key insight: $\gcd(a,b) = \gcd(b, a \bmod b)$ because any number that divides both $a$ and $b$ must also divide their remainder. This reduces the problem size very quickly!
```

## Exponentiation: Multiply Your Way Up

Computing $a^n$ seems like it requires $n$ multiplications, but recursion gives us insight into the problem structure.

**Basic recursive definition**:
- $a^0 = 1$ (base case)
- $a^n = a \times a^{n-1}$ (recursive case)

```python-execute
def power(base, exponent):
    # Base case: anything to the power of 0 is 1
    if exponent == 0:
        return 1
    
    # Recursive case: a^n = a * a^(n-1)
    return base * power(base, exponent - 1)

# Test it
print(f"2^5 = {power(2, 5)}")
print(f"3^4 = {power(3, 4)}")  
print(f"5^0 = {power(5, 0)}")
```

### Fast Exponentiation: A Clever Optimization

But wait! We can be much smarter about this. Notice that:
- $a^8 = (a^4)^2 = ((a^2)^2)^2$

We can cut the problem in half each time:

```python-execute
# First define the regular power function
def power(base, exponent):
    if exponent == 0:
        return 1
    return base * power(base, exponent - 1)

# Now the fast power function
def fast_power(base, exponent):
    # Base case
    if exponent == 0:
        return 1
    
    # If exponent is even: a^n = (a^(n/2))^2
    if exponent % 2 == 0:
        half_power = fast_power(base, exponent // 2)
        return half_power * half_power
    
    # If exponent is odd: a^n = a * a^(n-1)
    else:
        return base * fast_power(base, exponent - 1)

# Test both versions
print("Comparing regular vs fast exponentiation:")
print(f"Regular 2^10 = {power(2, 10)}")
print(f"Fast 2^10 = {fast_power(2, 10)}")

# The fast version is much more efficient for large exponents!
print(f"Fast 2^20 = {fast_power(2, 20)}")
```

```note title="Divide and Conquer Preview"
Fast exponentiation uses a **divide-and-conquer** approach - we divide the problem in half at each step. This reduces the number of operations from $n$ to $\log(n)$. We'll explore this pattern more in the next section!
```

## Mathematical Recursion Design Process

When you encounter a mathematical problem, ask:

1. **Is there a recursive definition?** Look for:
   - Sequences where each term depends on previous terms
   - Operations that can be broken down into smaller versions
   - Mathematical induction-style proofs

2. **What are the base cases?** Usually:
   - The first few terms of a sequence
   - The simplest version of the operation (like $a^0 = 1$)

3. **How does the recursive case work?**
   - How do you combine the current element with the result of the smaller problem?
   - Is it addition? Multiplication? Something else?

## More Mathematical Recursion Examples

Let's explore several more mathematical functions that benefit from recursive thinking. Each example demonstrates a different aspect of how recursion naturally emerges from mathematical definitions.

```python-execute
# Sum of digits (mathematical breakdown)
def sum_digits(n):
    """Add up all digits in a number: sum_digits(1234) = 1+2+3+4 = 10"""
    if n < 10:  # Single digit
        return n
    # Take last digit (n % 10) plus sum of remaining digits (n // 10)
    return (n % 10) + sum_digits(n // 10)

# Count digits (mathematical structure)  
def count_digits(n):
    """Count how many digits are in a number"""
    if n < 10:  # Single digit
        return 1
    # Remove one digit (n // 10) and count the rest, then add 1 for the digit we removed
    return 1 + count_digits(n // 10)

# Integer palindrome check (mathematical symmetry)
def is_palindrome_number(n):
    """Check if a number reads the same forwards and backwards"""
    # Convert to string to check symmetry easily
    s = str(n)
    return is_palindrome_string(s)

def is_palindrome_string(s):
    """Helper function for palindrome checking"""
    if len(s) <= 1:  # Empty or single character
        return True
    if s[0] != s[-1]:  # First and last don't match
        return False
    return is_palindrome_string(s[1:-1])  # Check middle part

# Test them all and see the mathematical structure
print("Mathematical recursion examples:")
print(f"Sum of digits in 1234: {sum_digits(1234)}")
print(f"Number of digits in 1234: {count_digits(1234)}")
print(f"Is 12321 a palindrome? {is_palindrome_number(12321)}")
print(f"Is 12345 a palindrome? {is_palindrome_number(12345)}")
```

Notice how each function breaks the problem down mathematically:
- **sum_digits**: "Sum of all digits = last digit + sum of remaining digits"
- **count_digits**: "Number of digits = 1 + number of digits after removing one"
- **is_palindrome**: "Palindrome check = first and last match AND middle is palindrome"

## Check Your Understanding

```quiz
id: mathematical-recursion-patterns
question: "Looking at the recursive definition $F(n) = 2 \\times F(n-1) + 1$ with $F(1) = 1$, what is $F(4)$?"
options:
  - id: a
    text: "7"
    correct: false
    explanation: "Let's trace it. $F(2) = 2 \\times 1 + 1 = 3$, $F(3) = 2 \\times 3 + 1 = 7$, $F(4) = 2 \\times 7 + 1 = 15$."
  - id: b
    text: "15"
    correct: true
    explanation: "Correct! $F(1)=1$, $F(2)=2 \\times 1+1=3$, $F(3)=2 \\times 3+1=7$, $F(4)=2 \\times 7+1=15$."
  - id: c
    text: "8"
    correct: false
    explanation: "This would be $2^3$. Remember the formula is $F(n) = 2 \\times F(n-1) + 1$, not just $2 \\times F(n-1)$."
  - id: d
    text: "4"
    correct: false
    explanation: "This doesn't follow the recursive pattern. Try tracing through $F(2)$, $F(3)$, then $F(4)$."
```

```quiz
id: fibonacci-base-cases
question: "Why does the Fibonacci function need TWO base cases ($n=1$ and $n=2$)?"
options:
  - id: a
    text: "Because $F(n)$ needs the previous two values, so we need to define both starting points"
    correct: true
    explanation: "Correct! Since $F(n) = F(n-1) + F(n-2)$, we need both $F(1)$ and $F(2)$ defined to calculate $F(3)$."
  - id: b
    text: "Because one base case would make it too slow"
    correct: false
    explanation: "Base cases don't affect speed - they prevent infinite recursion. We need two because of the recurrence relation."
  - id: c
    text: "Because we want to make sure it always stops"
    correct: false
    explanation: "One base case can stop recursion. We need two because the recursive formula depends on two previous values."
  - id: d
    text: "Because Fibonacci numbers always come in pairs"
    correct: false
    explanation: "This isn't about pairs - it's because $F(n)$ depends on both $F(n-1)$ and $F(n-2)$."
```

```quiz
id: gcd-base-case
question: "In the GCD algorithm, why is `gcd(a, 0) = a` a good base case?"
options:
  - id: a
    text: "Because 0 divides every number"
    correct: false
    explanation: "Actually, every number divides 0, not the other way around. 0 divided by any number is 0."
  - id: b
    text: "Because the largest number that divides both $a$ and 0 is $a$ itself"
    correct: true
    explanation: "Correct! Any number divides 0 (since $a \\times 0 = 0$), so the GCD of $a$ and 0 is the largest divisor of $a$, which is $a$ itself."
  - id: c
    text: "Because it makes the math easier"
    correct: false
    explanation: "While it does simplify things, the real reason is mathematical - $a$ is truly the GCD of $a$ and 0."
  - id: d
    text: "Because 0 is the smallest possible remainder"
    correct: false
    explanation: "While 0 is indeed the smallest remainder, that's not why `gcd(a, 0) = a`. It's because $a$ divides both $a$ and 0."
```

## Practice Exercises

```exercise
id: collatz-steps
title: Collatz Conjecture Steps
description: The Collatz conjecture states that starting with any positive integer n, if n is even divide it by 2, if n is odd multiply by 3 and add 1. Repeat until you reach 1. Write a recursive function that counts how many steps this takes.
difficulty: medium
starterCode: |
  def collatz_steps(n):
      # Your code here
      pass
prepend: |
  # Test harness - students don't see this
postpend: |
  # Testing code - students don't see this
  n = int(input().strip())
  result = collatz_steps(n)
  print(result)
testCases:
  - input: "1"
    expectedOutput: "0"
  - input: "4"
    expectedOutput: "2"
  - input: "2"
    expectedOutput: "1"
    hidden: true
  - input: "3"
    expectedOutput: "7"
    hidden: true
  - input: "5"
    expectedOutput: "5"
    hidden: true
  - input: "6"
    expectedOutput: "8"
    hidden: true
  - input: "7"
    expectedOutput: "16"
    hidden: true
  - input: "8"
    expectedOutput: "3"
    hidden: true
  - input: "10"
    expectedOutput: "6"
    hidden: true
  - input: "16"
    expectedOutput: "4"
    hidden: true
  - input: "27"
    expectedOutput: "111"
    hidden: true
  - input: "15"
    expectedOutput: "17"
    hidden: true
hints:
  - "Base case: if n equals 1, return 0 (no more steps needed)"
  - "If n is even: return 1 + collatz_steps(n // 2)"
  - "If n is odd: return 1 + collatz_steps(3 * n + 1)"
  - "Use the % operator to check if n is even: n % 2 == 0"
solution: |
  def collatz_steps(n):
      if n == 1:
          return 0
      if n % 2 == 0:
          return 1 + collatz_steps(n // 2)
      else:
          return 1 + collatz_steps(3 * n + 1)
```

```exercise
id: sum-of-squares
title: Sum of Squares
description: Write a recursive function that calculates the sum of squares from 1 to n. For example, sum_of_squares(3) = $1^2 + 2^2 + 3^2 = 14$.
difficulty: medium  
starterCode: |
  def sum_of_squares(n):
      # Your code here
      pass
prepend: |
  # Test harness - students don't see this
postpend: |
  # Testing code - students don't see this
  n = int(input().strip())
  result = sum_of_squares(n)
  print(result)
testCases:
  - input: "4"
    expectedOutput: "30"
  - input: "1"
    expectedOutput: "1"
    hidden: true
  - input: "2"
    expectedOutput: "5"
    hidden: true
  - input: "3"
    expectedOutput: "14"
    hidden: true
  - input: "5"
    expectedOutput: "55"
    hidden: true
  - input: "6"
    expectedOutput: "91"
    hidden: true
  - input: "7"
    expectedOutput: "140"
    hidden: true
  - input: "8"
    expectedOutput: "204"
    hidden: true
  - input: "9"
    expectedOutput: "285"
    hidden: true
  - input: "10"
    expectedOutput: "385"
    hidden: true
  - input: "12"
    expectedOutput: "650"
    hidden: true
  - input: "15"
    expectedOutput: "1240"
    hidden: true
hints:
  - "Base case: sum_of_squares(1) = $1^2 = 1$"
  - "Recursive case: sum_of_squares(n) = $n^2$ + sum_of_squares(n-1)"
  - "Think about how to build up from smaller cases"
  - "Remember that $n^2$ means n * n"
solution: |
  def sum_of_squares(n):
      if n == 1:
          return 1
      return n * n + sum_of_squares(n - 1)
```


## Key Takeaways

- **Mathematical problems** often have natural recursive definitions
- **Classic examples** include Fibonacci, GCD, and exponentiation  
- **Multiple base cases** may be needed (like Fibonacci needing $F(1)$ and $F(2)$)
- **Multiple recursive calls** in one function are possible (like Fibonacci calling both $F(n-1)$ and $F(n-2)$)
- **Optimization opportunities** exist (like fast exponentiation using divide-and-conquer)
- **Design process**: Look for recursive mathematical definitions, identify base cases, implement recursive case
- **Efficiency matters**: Some recursive solutions can be very inefficient without optimization

Next, we'll explore divide-and-conquer algorithms - a powerful recursive pattern that efficiently solves large problems by cutting them in half!
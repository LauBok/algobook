# Your First Recursive Functions

You understand the recursive mindset from the previous section. Now it's time to implement recursive solutions in Python! You'll discover that recursive functions follow a surprisingly simple pattern, once you see it.

## Learning Objectives

By the end of this section, you will be able to:
- Write basic recursive functions in Python
- Identify and implement base cases to prevent infinite recursion
- Trace through recursive function calls step by step
- Understand how Python handles recursive function calls
- Convert simple iterative problems to recursive solutions

## The Anatomy of a Recursive Function

Every recursive function in Python has the same basic structure. Let's start with the countdown example from the previous section.

### Recursive Countdown: From Concept to Code

**The Problem**: Count down from any number N to 1.

**Recursive thinking** (from the previous section):
- To count down from N: print N, then count down from N-1
- Base case: When N is 1, just print it and stop

**Python implementation**:

```python-execute
def countdown(n):
    # Base case: when to stop recursing
    if n == 1:
        print(1)
        return
    
    # Recursive case: do the current step, then solve smaller problem
    print(n)
    countdown(n - 1)  # This is the recursive call!

# Test it out
countdown(5)
```

```note title="The Recursive Function Pattern"
Every recursive function follows this template:
```python
def recursive_function(parameters):
    # BASE CASE: When to stop
    if (simple condition):
        return (direct answer)
    
    # RECURSIVE CASE: Break down the problem
    # Do some work for the current problem
    # Then call the function on a smaller version
    return recursive_function(smaller_parameters)
```
```

### Tracing Through a Recursive Call

Understanding how recursive calls actually execute is crucial for building your mental model. Let's trace through `countdown(3)` step by step to see what actually happens inside your computer's memory:

**Step-by-step execution:**

1. **Call `countdown(3)`**:
   - Python creates a new "space" in memory for this function call
   - Is `3 == 1`? No, so we don't return yet
   - Print 3 (this happens immediately)
   - Call `countdown(2)` (this creates another "space" on top of the first)

2. **Inside `countdown(2)`**:
   - Python creates another new space for this call
   - Is `2 == 1`? No, so we continue
   - Print 2 (this happens immediately)  
   - Call `countdown(1)` (yet another space created)

3. **Inside `countdown(1)`**:
   - Python creates the final space for this call
   - Is `1 == 1`? Yes! (Base case reached - this is our stopping point)
   - Print 1
   - Return (stop recursing, clean up this space)

4. **Back in `countdown(2)`**: 
   - The call to `countdown(1)` finished, so we continue from where we left off
   - Nothing more to do after the recursive call, so return (clean up this space)
   
5. **Back in `countdown(3)`**: 
   - The call to `countdown(2)` finished, so we continue 
   - Nothing more to do, so return (clean up the original space)
   
6. **Done!** All function spaces cleaned up, program continues

This is exactly like having a stack of plates - you can only add to the top and remove from the top.

## A More Useful Example: Factorial

Let's implement the factorial example from the previous section. Remember: 5! = 5 × 4 × 3 × 2 × 1.

**Recursive thinking**:
- N! = N × (N-1)!
- Base case: 1! = 1

```python-execute
def factorial(n):
    # Base case
    if n == 1:
        return 1
    
    # Recursive case: n! = n × (n-1)!
    return n * factorial(n - 1)

# Test it
print(f"5! = {factorial(5)}")
print(f"3! = {factorial(3)}")
print(f"1! = {factorial(1)}")
```

### Tracing Factorial Step by Step

Factorial demonstrates a crucial difference from countdown: instead of just doing work and moving on, factorial must **wait for and use** the result from its recursive call. This creates a different execution pattern.

Let's trace through `factorial(4)` and pay careful attention to when calculations actually happen:

**The "Going Down" Phase (Building the Stack):**

1. **Call `factorial(4)`**:
   - Is `4 == 1`? No.
   - Need to return 4 × `factorial(3)`, but first we must compute `factorial(3)`
   - **Calculation paused** - waiting for `factorial(3)` to complete

2. **Call `factorial(3)`**:
   - Is `3 == 1`? No.
   - Need to return 3 × `factorial(2)`, but first we must compute `factorial(2)`
   - **Calculation paused** - waiting for `factorial(2)` to complete

3. **Call `factorial(2)`**:
   - Is `2 == 1`? No.
   - Need to return 2 × `factorial(1)`, but first we must compute `factorial(1)`
   - **Calculation paused** - waiting for `factorial(1)` to complete

4. **Call `factorial(1)`**:
   - Is `1 == 1`? Yes! Base case reached.
   - Return 1 immediately (no more waiting!)

**The "Coming Back Up" Phase (Doing the Math):**

5. **Now the actual calculations happen** as each function gets the answer it was waiting for:
   - `factorial(1)` returns 1
   - `factorial(2)` now has its answer: 2 × 1 = 2, returns 2
   - `factorial(3)` now has its answer: 3 × 2 = 6, returns 6
   - `factorial(4)` now has its answer: 4 × 6 = 24, returns 24

**Final answer**: 24

Notice how different this is from countdown! In countdown, all the printing happened on the way down. In factorial, all the math happens on the way back up.

```callstack-visualizer
id: countdown-factorial-stack-demo
title: Interactive Call Stack Visualization
description: Compare countdown vs factorial! Watch how countdown prints going down the stack, while factorial calculates coming back up. Try both functions to see the two different recursive patterns.
showCountdown: true
showFactorial: true
showFibonacci: false
```

The widget above shows exactly how the call stack works! Here's what you're seeing:

- **Stack grows upward** as each function calls the next one
- **Blue frame** shows the currently executing function  
- **Gray frames** are waiting for inner calls to complete
- **Red frames** show functions that are returning
- **Compare the patterns**: Countdown prints while going down, factorial calculates while coming back up

```note title="Why Base Cases Matter"
Without the base case `if n == 1: return 1`, factorial would keep calling itself with 0, -1, -2, etc., forever! The base case is what provides the actual answer that allows all the recursive calls to complete.
```

## Common Recursive Function Patterns

### Pattern 1: Process and Recurse
Like `countdown()` - do something with the current value, then recurse on a smaller problem.

```python-execute
def print_backwards(text, index):
    # Base case: we've reached the beginning
    if index < 0:
        return
    
    # Process: print current character
    print(text[index])
    
    # Recurse: move to previous character
    print_backwards(text, index - 1)

# Try it out
print_backwards("hello", 4)  # Prints: o, l, l, e, h
```

### Pattern 2: Recurse and Process  
Like `factorial()` - recurse first to get the smaller result, then process it.

```python-execute
def sum_digits(n):
    # Base case: single digit
    if n < 10:
        return n
    
    # Recursive case: last digit + sum of remaining digits
    last_digit = n % 10
    remaining_digits = n // 10
    return last_digit + sum_digits(remaining_digits)

# Test it
print(f"Sum of digits in 1234: {sum_digits(1234)}")  # 1 + 2 + 3 + 4 = 10
```

## What Can Go Wrong?

Understanding common recursive mistakes is just as important as learning the correct patterns. Let's examine the typical problems you'll encounter and how to avoid them.

### Missing Base Case
```python-execute
# This function has no base case - it will crash!
def broken_countdown(n):
    print(n)
    broken_countdown(n - 1)  # Never stops!

# Don't run this - it will cause an error after ~1000 calls
# broken_countdown(5)
print("We skipped the broken function to avoid crashing!")
```

**What happens**: Without a base case, the function calls itself indefinitely. Python will eventually run out of memory for storing function calls (called "stack overflow") and crash with a `RecursionError`.

**The error message**: `RecursionError: maximum recursion depth exceeded`

### Wrong Base Case
```python-execute
def almost_broken_factorial(n):
    # Wrong base case - what about factorial(0)?
    if n == 1:
        return 1
    return n * almost_broken_factorial(n - 1)

# This works for positive numbers...
print(f"5! = {almost_broken_factorial(5)}")

# But what happens with 0? Let's trace it:
# factorial(0): 0 == 1? No. Return 0 * factorial(-1)
# factorial(-1): -1 == 1? No. Return -1 * factorial(-2)
# This will continue forever!

print("We need to handle edge cases like 0!")
```

```warning title="Always Check Your Base Cases"
Make sure your base case will actually be reached! Common mistakes:
- Forgetting edge cases like 0 or negative numbers
- Base case that never triggers (like `if n == 0` when n starts at 5 and decreases by 2)
- Multiple base cases needed but only implementing one
```

## Recursive vs. Iterative Comparison

Let's compare the same problem solved both ways:

```python-execute
# Recursive version
def power_recursive(base, exponent):
    if exponent == 0:
        return 1
    return base * power_recursive(base, exponent - 1)

# Iterative version  
def power_iterative(base, exponent):
    result = 1
    for i in range(exponent):
        result *= base
    return result

# Both give the same answer
print(f"Recursive 2^3 = {power_recursive(2, 3)}")
print(f"Iterative 2^3 = {power_iterative(2, 3)}")
```

**When to choose each approach:**
- **Recursive**: Often clearer for problems that naturally break down into smaller versions
- **Iterative**: Usually more memory-efficient, sometimes faster

## Check Your Understanding

```quiz
id: base-cases-quiz
question: "Which of these is the correct base case for a function that counts how many digits are in a positive integer?"
options:
  - id: a
    text: "`if n == 0`"
    correct: false
    explanation: "A positive integer will never reach 0 during our recursive breakdown."
  - id: b
    text: "`if n < 10`"
    correct: true
    explanation: "Correct! Single digits (1-9) have exactly 1 digit, so this is where we stop recursing."
  - id: c
    text: "`if n == 1`"
    correct: false
    explanation: "What about other single digits like 7 or 9? They also have only 1 digit."
  - id: d
    text: "`if n > 0`"
    correct: false
    explanation: "This would always be true for positive integers - we'd never recurse at all!"
```

```quiz
id: recursive-tracing
question: "If we call `mystery_function(3)` where `mystery_function(n)` returns 1 if `n <= 1`, otherwise returns `n + mystery_function(n-1)`, what does it return?"
options:
  - id: a
    text: "3"
    correct: false
    explanation: "Tracing: `mystery_function(3) = 3 + mystery_function(2) = 3 + (2 + mystery_function(1)) = 3 + (2 + 1) = 6`."
  - id: b
    text: "6"
    correct: true
    explanation: "Correct! Tracing: `mystery_function(3) = 3 + mystery_function(2) = 3 + (2 + mystery_function(1)) = 3 + (2 + 1) = 6`."
  - id: c
    text: "1"
    correct: false
    explanation: "This would only be true if we called `mystery_function(1)` directly. Remember to trace through the recursive calls."
  - id: d
    text: "9"
    correct: false
    explanation: "This would be `3 × 3`. Remember we're adding, not multiplying: `n + mystery_function(n-1)`."
```

```quiz
id: factorial-edge-case
question: "What happens if you call `factorial(0)` with the factorial function we wrote above?"
options:
  - id: a
    text: "Returns 0"
    correct: false
    explanation: "The function doesn't have a base case for 0, so it won't return 0."
  - id: b
    text: "Returns 1"
    correct: false
    explanation: "While mathematically 0! = 1, our function doesn't handle this case correctly."
  - id: c
    text: "Causes infinite recursion"
    correct: true
    explanation: "Correct! Our base case is `if n == 1`, but `factorial(0)` calls `factorial(-1)`, `factorial(-2)`, etc., forever since -1 ≠ 1."
  - id: d
    text: "Gives a syntax error"
    correct: false
    explanation: "The syntax is valid Python. The problem is logical - missing base case for n = 0."
```

```quiz
id: execution-phases
question: "In the factorial function, when does the actual multiplication happen?"
options:
  - id: a
    text: "As soon as each function is called (going down the recursion)"
    correct: false
    explanation: "The multiplication is `n * factorial(n-1)`, but we can't multiply until `factorial(n-1)` returns a value."
  - id: b
    text: "After the base case is reached, as each function returns (coming back up)"
    correct: true
    explanation: "Correct! Each function waits for its recursive call to return before it can do its multiplication and return."
  - id: c
    text: "Only in the base case"
    correct: false
    explanation: "The base case returns 1, but the multiplication happens in every other call as they return."
  - id: d
    text: "At random times during execution"
    correct: false
    explanation: "The execution order is very predictable - it follows the call stack pattern."
```

## Practice Exercises

```exercise
id: recursive-fractal-pattern
title: Build Fractal Pattern with Recursion  
description: Write a recursive function that builds a fractal-like number pattern. For n=1 return [1], for n=2 return [1, 2, 1], for n=3 return [1, 2, 1, 3, 1, 2, 1]. Each level sandwiches the current number between two copies of the previous pattern.
difficulty: medium
starterCode: |
  def build_pattern(n):
      # Your code here
      pass
prepend: |
  # Test harness - students don't see this
postpend: |
  # Testing code - students don't see this
  test_input = int(input().strip())
  result = build_pattern(test_input)
  print(' '.join(map(str, result)))
testCases:
  - input: "3"
    expectedOutput: "1 2 1 3 1 2 1"
  - input: "1"
    expectedOutput: "1"
    hidden: true
  - input: "2"
    expectedOutput: "1 2 1"
    hidden: true
  - input: "4"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
  - input: "5"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
  - input: "6"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
  - input: "7"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
  - input: "8"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
  - input: "10"
    expectedOutput: "1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 9 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 10 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 9 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1"
    hidden: true
hints:
  - "Base case: when n equals 1, return [1]"
  - "Recursive case: get the pattern for n-1, then sandwich n between two copies of it"  
  - "Pattern for n = smaller_pattern + [n] + smaller_pattern"
  - "This creates a fractal-like structure where each level contains two copies of the previous level"
solution: |
  def build_pattern(n):
      if n == 1:
          return [1]
      
      # Get the pattern for n-1
      smaller_pattern = build_pattern(n - 1)
      
      # Build current pattern: smaller_pattern + [n] + smaller_pattern
      return smaller_pattern + [n] + smaller_pattern
```

```exercise
id: simple-sum
title: Sum Numbers Recursively
description: Write a recursive function that calculates the sum of all integers from 1 to n.
difficulty: easy
starterCode: |
  def sum_to_n(n):
      # Your code here
      pass
prepend: |
  # Test harness - students don't see this
postpend: |
  # Testing code - students don't see this
  n = int(input().strip())
  result = sum_to_n(n)
  print(result)
testCases:
  - input: "7"
    expectedOutput: "28"
  - input: "1"
    expectedOutput: "1"
    hidden: true
  - input: "2"
    expectedOutput: "3"
    hidden: true
  - input: "3"
    expectedOutput: "6"
    hidden: true
  - input: "4"
    expectedOutput: "10"
    hidden: true
  - input: "5"
    expectedOutput: "15"
    hidden: true
  - input: "6"
    expectedOutput: "21"
    hidden: true
  - input: "8"
    expectedOutput: "36"
    hidden: true
  - input: "10"
    expectedOutput: "55"
    hidden: true
  - input: "12"
    expectedOutput: "78"
    hidden: true
  - input: "15"
    expectedOutput: "120"
    hidden: true
  - input: "20"
    expectedOutput: "210"
    hidden: true
hints:
  - "Think: sum_to_n(5) = 5 + sum_to_n(4)"
  - "Base case: sum_to_n(1) = 1"
  - "Use return to give back the calculated sum"
  - "Each recursive call should get you closer to the base case"
solution: |
  def sum_to_n(n):
      if n == 1:
          return 1
      return n + sum_to_n(n - 1)
```

## Key Takeaways

- **Recursive functions** call themselves to solve smaller versions of the same problem
- **Every recursive function needs**:
  - **Base case**: When to stop recursing and return a direct answer
  - **Recursive case**: How to break the problem down and call itself
- **Function call stack**: Python keeps track of recursive calls in a stack-like structure
- **Tracing recursive calls**: Work through examples step by step to understand the flow
- **Common pitfalls**: Missing base cases or base cases that never trigger
- Recursive solutions are often **clearer** but may use **more memory** than iterative ones

Next, we'll explore more sophisticated recursive problems involving mathematical sequences and calculations!
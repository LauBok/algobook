# Python Sorting in Practice

After understanding sorting algorithms, we can explore Python's built-in sorting capabilities. Python uses TimSort, an efficient hybrid algorithm, allowing focus on practical sorting applications rather than implementation details.

## Learning Objectives

By the end of this section, you will:
- Master Python's built-in sorting functions
- Use custom sorting criteria with key functions
- Apply sorting to solve real programming problems
- Know when to use `sorted()` vs `.sort()`

## Python Sorting Fundamentals

### Basic Sorting Functions

Python's `sorted()` function works on any sequence:

```python-execute
# Start with basic sorting
numbers = [64, 34, 25, 12, 90]
words = ["banana", "apple", "cherry"]

print("Numbers:", sorted(numbers))
print("Words:", sorted(words))
```

### `sorted()` vs `.sort()`

Python provides two sorting approaches:

```python-execute
# sorted() creates a NEW list (original unchanged)
original = [3, 1, 4, 1, 5]
new_sorted = sorted(original)
print(f"Original: {original}")
print(f"New list: {new_sorted}")

# .sort() modifies the SAME list
my_list = [3, 1, 4, 1, 5]
my_list.sort()  # Changes my_list directly
print(f"After .sort(): {my_list}")
```

**When to use each:**
- Use `sorted()` when you want to keep the original list
- Use `.sort()` when you want to save memory by modifying the existing list

### Reverse Sorting

Add `reverse=True` to sort from largest to smallest:

```python-execute
scores = [85, 92, 78, 96, 88]
print("Low to high:", sorted(scores))
print("High to low:", sorted(scores, reverse=True))
```

## Advanced Sorting Techniques

The `key` parameter enables sorting by custom criteria:

**Sort by String Length**
```python-execute
languages = ["Python", "Go", "JavaScript", "C"]
print("Alphabetical:", sorted(languages))
print("By length:", sorted(languages, key=len))
```

**Sort Complex Data Structures**
```python-execute
students = [
    ("Alice", 85),
    ("Bob", 92),
    ("Carol", 78)
]

# Sort by grade (second element)
by_grade = sorted(students, key=lambda student: student[1])
for name, grade in by_grade:
    print(f"{name}: {grade}")
```

**Sort by Multiple Criteria**
```python-execute
students = [
    ("Alice", 85, "A"),
    ("Bob", 85, "B"),     # Same grade as Alice
    ("Carol", 92, "A")
]

# Sort by grade (high to low), then by name (A to Z)
result = sorted(students, key=lambda x: (-x[1], x[0]))
for name, grade, section in result:
    print(f"{name}: {grade}")
```

The tuple `(-x[1], x[0])` creates a sorting key with two parts:
- `-x[1]` (negative grade for descending order)
- `x[0]` (name for ascending order)

Python sorts tuples element by element, so it sorts by grade first, then breaks ties using name.

## Practical Applications

**Finding Top Performers**
```python-execute
employees = [
    {"name": "Alice", "sales": 15000},
    {"name": "Bob", "sales": 12000},
    {"name": "Carol", "sales": 18000},
    {"name": "Dave", "sales": 9000}
]

# Get top 3 by sales
top_3 = sorted(employees, key=lambda x: x["sales"], reverse=True)[:3]
for emp in top_3:
    print(f"{emp['name']}: ${emp['sales']}")
```

**Time-Based Organization**
```python-execute
schedule = [("Meeting", "14:30"), ("Lunch", "12:00"), ("Standup", "09:00")]
sorted_schedule = sorted(schedule, key=lambda event: event[1])
for event, time in sorted_schedule:
    print(f"{time}: {event}")
```

**File Management**
```python-execute
files = [
    ("document.pdf", 2500),
    ("image.jpg", 800),
    ("video.mp4", 15000)
]

by_size = sorted(files, key=lambda f: f[1], reverse=True)
for filename, size in by_size:
    print(f"{filename}: {size} KB")
```

## Python Sorting Advantages

Python uses TimSort, an optimized hybrid algorithm with guaranteed $O(n \log n)$ performance:

- **Stable**: Equal elements maintain their original order
- **Adaptive**: Faster on partially sorted data
- **Reliable**: Handles edge cases automatically

```note title="When to Use Built-in Sorting"
Use `sorted()` or `.sort()` unless:
- Implementing algorithms for educational purposes
- Requiring highly specialized custom behavior
- Working in a different programming language
```

## Reference Summary

Here's everything you need to know about Python sorting:

```python-execute
# Basic sorting
numbers = [3, 1, 4, 2]
print("sorted():", sorted(numbers))     # New list: [1, 2, 3, 4]

# In-place sorting  
numbers.sort()                          # Changes original list
print("after .sort():", numbers)

# Reverse order
print("reverse:", sorted([3, 1, 4], reverse=True))

# Custom criteria
words = ["apple", "cat", "elephant"]
print("by length:", sorted(words, key=len))

# Multiple criteria (grade desc, name asc)
students = [("Alice", 85), ("Bob", 92), ("Charlie", 85)]
result = sorted(students, key=lambda x: (-x[1], x[0]))
print("sorted:", result)
```

```note title="Sorting Cheat Sheet"
- `sorted(list)` → returns new sorted list
- `list.sort()` → modifies list in place  
- `reverse=True` → largest to smallest
- `key=len` → sort by length
- `key=lambda x: x[1]` → sort by second element
- `key=lambda x: (-x[1], x[0])` → sort by second (desc), then first (asc)
```

## Key Takeaways

- **Use Python's built-in sorting**: It's fast, reliable, and handles all edge cases
- **Choose `sorted()` vs `.sort()`**: New list vs modify existing
- **Master the `key` parameter**: Sort by any criteria you want
- **Combine techniques**: Use `key` + `reverse` for complex sorting

You now know everything you need to sort data effectively in Python. The algorithms you learned (merge sort, quicksort) are the foundation, but Python's TimSort implementation handles all the complexity for you.

## Chapter 9 Summary

In this chapter, you've mastered the fundamentals of sorting algorithms:

**Theory and Algorithms:**
- **Why sorting matters**: Enables fast search, data analysis, and powers real-world applications
- **Merge sort**: Divide-and-conquer approach with guaranteed $O(n \log n)$ performance and stability
- **Quick sort**: Efficient average-case $O(n \log n)$ with in-place partitioning
- **Theoretical limits**: Proved why comparison-based sorting cannot be faster than $O(n \log n)$

**Practical Skills:**
- **Python sorting mastery**: `sorted()` vs `.sort()`, `reverse=True`, and custom `key` functions
- **Real-world applications**: Finding top performers, organizing data, and solving practical problems

**Key Insights:**
- Efficient algorithms make impossible problems solvable at scale
- Theory provides fundamental limits, but practical implementations optimize for real data patterns
- Python's TimSort combines the best of multiple approaches for both theoretical guarantees and practical speed

You're now equipped with both the theoretical understanding and practical skills to handle any sorting challenge. In the next chapter, we'll explore dictionaries and hash-based data structures for lightning-fast lookups!
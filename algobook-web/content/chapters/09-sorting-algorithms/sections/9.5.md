# Python's Built-in Sorting: Fast and Practical

Now that you understand sorting algorithms, let's learn how to actually sort data in Python. Python uses an advanced algorithm called **TimSort** (don't worry about the details—it's fast and reliable), so you can focus on using Python's sorting features effectively.

## Learning Objectives

By the end of this section, you will:
- Master Python's built-in sorting functions
- Use custom sorting criteria with key functions
- Apply sorting to solve real programming problems
- Know when to use `sorted()` vs `.sort()`

## Basic Sorting

Python's `sorted()` function is the easiest way to sort data:

```python-execute
# Start with basic sorting
numbers = [64, 34, 25, 12, 90]
words = ["banana", "apple", "cherry"]

print("Numbers:", sorted(numbers))
print("Words:", sorted(words))
```

`sorted()` works on any list and returns a new sorted list.

## `sorted()` vs `.sort()` - When to Use Which

Python gives you two ways to sort. Here's the key difference:

```python-execute
# sorted() creates a NEW list (original unchanged)
original = [3, 1, 4, 1, 5]
new_sorted = sorted(original)
print(f"Original: {original}")
print(f"New list: {new_sorted}")

# .sort() modifies the SAME list
my_list = [3, 1, 4, 1, 5]
my_list.sort()  # Changes my_list directly
print(f"After .sort(): {my_list}")
```

**When to use each:**
- Use `sorted()` when you want to keep the original list
- Use `.sort()` when you want to save memory by modifying the existing list

## Reverse Sorting

Add `reverse=True` to sort from largest to smallest:

```python-execute
scores = [85, 92, 78, 96, 88]
print("Low to high:", sorted(scores))
print("High to low:", sorted(scores, reverse=True))
```

This works with both numbers and strings. For strings, reverse means reverse alphabetical order.

## Sorting by Custom Criteria with `key`

The real power comes from the `key` parameter. It lets you sort by any criteria you want.

### Sort by String Length
```python-execute
languages = ["Python", "Go", "JavaScript", "C"]
print("Alphabetical:", sorted(languages))
print("By length:", sorted(languages, key=len))
```

`key=len` means "sort by the length of each string."

### Sort Tuples by Different Elements
```python-execute
students = [
    ("Alice", 85),
    ("Bob", 92), 
    ("Carol", 78)
]

# Sort by grade (second element)
by_grade = sorted(students, key=lambda student: student[1])
for name, grade in by_grade:
    print(f"{name}: {grade}")
```

`lambda student: student[1]` means "sort by the second element of each tuple."

### Sort by Multiple Criteria
```python-execute
students = [
    ("Alice", 85, "A"),
    ("Bob", 85, "B"),     # Same grade as Alice
    ("Carol", 92, "A")
]

# Sort by grade (high to low), then by name (A to Z)
result = sorted(students, key=lambda x: (-x[1], x[0]))
for name, grade, section in result:
    print(f"{name}: {grade}")
```

The tuple `(-x[1], x[0])` creates a sorting key with two parts:
- First: `-x[1]` (negative grade for descending order)
- Second: `x[0]` (name for ascending order)

Python sorts tuples element by element, so it sorts by grade first, then breaks ties using name.

## Common Use Cases

Here are practical problems you can solve with sorting:

### Finding Top 3 Performers
```python-execute
employees = [
    {"name": "Alice", "sales": 15000},
    {"name": "Bob", "sales": 12000}, 
    {"name": "Carol", "sales": 18000},
    {"name": "Dave", "sales": 9000}
]

# Get top 3 by sales
top_3 = sorted(employees, key=lambda x: x["sales"], reverse=True)[:3]
for emp in top_3:
    print(f"{emp['name']}: ${emp['sales']}")
```

### Organizing Events by Time
```python-execute
schedule = [("Meeting", "14:30"), ("Lunch", "12:00"), ("Standup", "09:00")]
sorted_schedule = sorted(schedule, key=lambda event: event[1])
for event, time in sorted_schedule:
    print(f"{time}: {event}")
```

### Sorting Files by Size
```python-execute
files = [
    ("document.pdf", 2500),
    ("image.jpg", 800), 
    ("video.mp4", 15000)
]

by_size = sorted(files, key=lambda f: f[1], reverse=True)
for filename, size in by_size:
    print(f"{filename}: {size} KB")
```

## Why Python's Sorting is Great

Python uses TimSort, which is incredibly fast and handles all edge cases. You don't need to worry about the algorithm details—just know that:

- It's always fast (guaranteed $O(n \log n)$ worst case)
- It's "stable" (equal elements stay in their original order)
- It's adaptive (even faster on partially sorted data)

```note title="When to Use Python's Built-in Sort"
**Always use `sorted()` or `.sort()` unless:**
- You're implementing sorting algorithms for learning
- You need a very specific custom behavior
- You're in a different programming language

Python's sorting is professionally optimized and handles edge cases you might miss.
```

## Quick Reference

Here's everything you need to know about Python sorting:

```python-execute
# Basic sorting
numbers = [3, 1, 4, 2]
print("sorted():", sorted(numbers))     # New list: [1, 2, 3, 4]

# In-place sorting  
numbers.sort()                          # Changes original list
print("after .sort():", numbers)

# Reverse order
print("reverse:", sorted([3, 1, 4], reverse=True))

# Custom criteria
words = ["apple", "cat", "elephant"]
print("by length:", sorted(words, key=len))

# Multiple criteria (grade desc, name asc)
students = [("Alice", 85), ("Bob", 92), ("Charlie", 85)]
result = sorted(students, key=lambda x: (-x[1], x[0]))
print("sorted:", result)
```

```note title="Sorting Cheat Sheet"
- `sorted(list)` → returns new sorted list
- `list.sort()` → modifies list in place  
- `reverse=True` → largest to smallest
- `key=len` → sort by length
- `key=lambda x: x[1]` → sort by second element
- `key=lambda x: (-x[1], x[0])` → sort by second (desc), then first (asc)
```

## Key Takeaways

- **Use Python's built-in sorting**: It's fast, reliable, and handles all edge cases
- **Choose `sorted()` vs `.sort()`**: New list vs modify existing
- **Master the `key` parameter**: Sort by any criteria you want
- **Combine techniques**: Use `key` + `reverse` for complex sorting

You now know everything you need to sort data effectively in Python. The algorithms you learned (merge sort, quicksort) are the foundation, but Python's TimSort implementation handles all the complexity for you.

## Chapter 9 Summary

In this chapter, you've mastered the fundamentals of sorting algorithms:

**Theory and Algorithms:**
- **Why sorting matters**: Enables fast search, data analysis, and powers real-world applications
- **Merge sort**: Divide-and-conquer approach with guaranteed $O(n \log n)$ performance and stability
- **Quick sort**: Efficient average-case $O(n \log n)$ with in-place partitioning
- **Theoretical limits**: Proved why comparison-based sorting cannot be faster than $O(n \log n)$

**Practical Skills:**
- **Python sorting mastery**: `sorted()` vs `.sort()`, `reverse=True`, and custom `key` functions
- **Real-world applications**: Finding top performers, organizing data, and solving practical problems

**Key Insights:**
- Efficient algorithms make impossible problems solvable at scale
- Theory provides fundamental limits, but practical implementations optimize for real data patterns
- Python's TimSort combines the best of multiple approaches for both theoretical guarantees and practical speed

You're now equipped with both the theoretical understanding and practical skills to handle any sorting challenge. In the next chapter, we'll explore dictionaries and hash-based data structures for lightning-fast lookups!
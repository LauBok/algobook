# Creating Your First Functions

## Learning Objectives
- Write and call simple functions using Python syntax
- Understand the basic structure of function definitions
- Follow the execution flow when functions are called
- Practice creating functions that perform specific tasks
- Transform repetitive code from Section 5.1 into reusable functions

## From Problem to Solution

In the previous section, we identified a frustrating problem: writing the same code over and over again. You saw examples where we calculated grades and rectangle areas by copying and pasting nearly identical logic.

Now we'll learn how to solve this problem using Python's function syntax. By the end of this section, you'll be able to take those repetitive code blocks and transform them into clean, reusable functions.

## Function Definition: The `def` Keyword

Python provides the `def` keyword specifically for creating functions. Think of `def` as telling Python: "I'm about to define a reusable block of code." Here's the basic structure:

```python
def function_name():
    # Code that the function executes
    print("This code runs when the function is called")
```

Let's break down each part of this syntax:

- **`def`**: This keyword tells Python "I'm defining a function." Every function definition starts with `def`.
- **`function_name`**: This is the name you choose for your function, similar to naming a variable. Choose descriptive names that explain what the function does.
- **`()`**: These parentheses will eventually hold parameters (inputs to your function), but for now they're empty. We'll learn about parameters in the next section.
- **`:`**: The colon marks the end of the function definition line and tells Python "the function body starts on the next line."
- **Indented code**: Everything indented under the function definition becomes part of the function. Python uses indentation to know which lines belong inside the function, just like with if statements and loops.

```note title="Lexical Scoping Through Indentation"
Python uses syntactic indentation to define lexical scope. All statements within a function body must be indented consistently relative to the function definition. This indentation determines which statements belong to the function's local scope.
```

## Your First Function

Let's start with the simplest possible example: a function that displays a greeting message. This will help you understand the basic mechanics before we tackle more complex examples.

```python-execute
def say_hello():
    print("Hello there!")
    print("Welcome to our program!")
    print("Hope you're having a great day!")

# To use the function, we "call" it by writing its name with parentheses
say_hello()
```

Let's analyze what happens when you run this code:

1. **Function Definition**: The `def say_hello():` line creates a function named `say_hello`. The three print statements become part of this function.

2. **Function Call**: The line `say_hello()` actually **uses** the function. This is called "calling" or "invoking" the function.

3. **Execution**: When Python sees `say_hello()`, it jumps to the function definition and executes all the indented code under it.

Notice something important: just defining a function doesn't make its code run. The code inside the function only executes when you **call** the function by writing its name followed by parentheses.

## The Power of Reuse

Now let's see the real magic of functions: you can call the same function as many times as you need! This immediately solves the repetition problem from Section 5.1.

```python-execute
# You can call the same function multiple times
def print_separator():
    print("=" * 30)

print_separator()
print("Section 1: Important Information")
print_separator() 
print("Section 2: More Details")
print_separator()
```

Look at what we accomplished! Instead of typing `print("=" * 30)` three times, we:
1. **Defined it once** in a function named `print_separator`
2. **Called it three times** by writing `print_separator()`

This is exactly the solution to the repetitive code problem we identified in Section 5.1. We've eliminated duplication while making our code more readable.

## Understanding Function Execution Flow

It's important to understand exactly what happens when Python encounters a function call. This knowledge will help you debug your programs and understand more complex examples later.

When Python encounters a function call, here's the step-by-step process:

1. **Pause current execution**: Python temporarily stops running the current line of code
2. **Jump to function definition**: Python finds the function definition and moves to the first line inside the function
3. **Execute function body**: Python runs all the indented code inside the function from top to bottom
4. **Return to caller**: After the function finishes, Python continues with the line that came after the function call

Let's see this execution flow in action with a detailed example:

```python-execute
print("Before calling the function")

def my_function():
    print("Inside the function!")
    print("Still inside the function!")

print("About to call the function")
my_function()
print("After calling the function")
```

When you run this code, observe the order of the output:

1. "Before calling the function" - Python executes normally
2. "About to call the function" - Python continues to the next line  
3. "Inside the function!" - Python jumps to `my_function()` and starts executing inside it
4. "Still inside the function!" - Python continues executing inside the function
5. "After calling the function" - Python returns to where it left off and continues

This "jump and return" behavior is fundamental to how functions work. Understanding this flow will help you debug problems and predict how your programs will behave.

## Practical Example: Transforming Repetitive Code

Now let's apply what we've learned to solve a real problem. Remember the repetitive grade calculation code from Section 5.1? We can use functions to eliminate that duplication.

Here's how we can improve on the repetitive code using a simple function:

```python-execute
def print_grade_header():
    print("\n" + "=" * 25)
    print("  GRADE CALCULATOR")
    print("=" * 25)

# Now we can use this header wherever we need it
print_grade_header()
print("Calculate your quiz grades below:")

print_grade_header() 
print("Calculate your exam grades below:")

print_grade_header()
print("Calculate your final grades below:")
```

This is much cleaner than writing the same header code three times! We've eliminated repetition and made our code more maintainable.

## Functions for Code Organization

Beyond eliminating repetition, functions also help **organize** your code into logical chunks. Instead of one long script that does everything, you can break your program into clearly named pieces that each handle a specific task.

Here's an example that shows how functions make your main program much easier to read and understand:

```python-execute
def print_welcome_message():
    print("Welcome to the Semester Progress Calculator!")
    print("Let's see how you're doing in your classes.")

def print_instructions():
    print("\nInstructions:")
    print("- Enter your current points earned")
    print("- Enter total points possible")
    print("- We'll calculate your percentage")

def print_goodbye_message():
    print("\nThanks for using the progress calculator!")
    print("Keep up the great work!")

# Main program using our functions
print_welcome_message()
print_instructions()

# Here we would add the actual calculation code
current_points = int(input("\nCurrent points earned: "))
total_points = int(input("Total points possible: "))
percentage = (current_points / total_points) * 100
print(f"Your current grade: {percentage:.1f}%")

print_goodbye_message()
```

Look at the difference! The main program (the bottom section) reads like a clear outline:
1. Print welcome message
2. Print instructions  
3. Do the actual calculation
4. Print goodbye message

Each function has a clear, descriptive name that explains exactly what it does. When someone reads your code, they can understand the overall flow without getting lost in implementation details.

## Function Naming Best Practices

Just like with variables, function names should be descriptive:

```python-execute
# Good function names - clear and descriptive
def calculate_rectangle_area():
    print("Calculating area...")

def display_menu_options():
    print("1. Add numbers")
    print("2. Multiply numbers")
    print("3. Exit")

def validate_user_input():
    print("Checking if input is valid...")

# Call each function to see what they do
calculate_rectangle_area()
display_menu_options()
validate_user_input()
```

```warning title="Avoid Vague Names"
Functions named `do_stuff()`, `function1()`, or `temp()` don't tell you what they actually do. Future you (and your teammates) will be confused!
```

## Documenting Your Functions

As you write more functions, it becomes important to document what they do. Python provides a special way to add documentation called **docstrings** (documentation strings). 

A docstring is a string that comes immediately after the function definition line:

```python-execute
def calculate_grade_percentage():
    """Calculate the percentage grade for a student."""
    print("This function calculates grades")
    print("More functionality will be added later")

def display_welcome_screen():
    """Display a welcome message and program instructions."""
    print("Welcome to the Grade Calculator!")
    print("This program helps you track your academic progress")

# Call the functions to see them work
calculate_grade_percentage()
print()
display_welcome_screen()
```

The triple quotes (`"""`) create docstrings that explain what each function does. This documentation helps other programmers (and future you) understand your code quickly.

```note title="Documentation Standards"
Docstrings provide inline documentation following Python Enhancement Proposal (PEP) 257. They enable automated documentation generation and improve code maintainability. Professional codebases require comprehensive function documentation.
```

## Example Function Usages

Here are some common ways you'll use functions:

### 1. Display Functions (Output Information)

```python-execute
def show_program_title():
    print("*" * 40)
    print("*        MATH HELPER PROGRAM         *") 
    print("*" * 40)

def show_loading_message():
    print("Loading... please wait...")
    print("." * 20)

show_program_title()
show_loading_message()
```

### 2. Calculation Setup Functions

```python-execute
def prepare_calculation():
    print("Setting up calculation...")
    print("Initializing variables...")
    print("Ready to compute!")

def cleanup_after_calculation():
    print("Calculation complete!")
    print("Cleaning up temporary data...")
    print("All done!")

prepare_calculation()
# Imagine calculation code here
cleanup_after_calculation()
```

## Practice: Function Creation

```quiz
id: function-syntax-basics
question: Which of these correctly defines a function named `print_message`?
options:
  - id: a
    text: |
      ```python
      function print_message():
          print("Hello")
      ```
    correct: false
    explanation: Python uses `def`, not `function`, to define functions.
  - id: b
    text: |
      ```python
      def print_message():
          print("Hello")
      ```
    correct: true
    explanation: Correct! This uses the proper `def` keyword, function name, parentheses, colon, and indented body.
  - id: c
    text: |
      ```python
      def print_message()
          print("Hello")
      ```
    correct: false
    explanation: Missing the colon (:) after the parentheses. Python requires a colon to start the function body.
  - id: d
    text: |
      ```python
      def print_message():
      print("Hello")
      ```
    correct: false
    explanation: The function body must be indented. Without indentation, Python doesn't know what code belongs in the function.
```

```exercise
id: first-function-creation
title: Create a Message Function
description: Write a function called `display_welcome` that prints a welcome message to new users.
difficulty: easy
starterCode: |
  # Write your function here
  def display_welcome():
      # Add your code below this line
      pass
  
  # Test your function
  display_welcome()
testCases:
  - input: ""
    expectedOutput: "Welcome to our amazing program!\nWe're glad you're here!"
  - input: ""
    expectedOutput: "Welcome to our amazing program!\nWe're glad you're here!"
    hidden: true
hints:
  - "Use print() statements inside your function"
  - "Remember to indent the code inside the function"
  - "Replace 'pass' with your print statements"
solution: |
  def display_welcome():
      print("Welcome to our amazing program!")
      print("We're glad you're here!")
  
  display_welcome()
```

## Multiple Function Calls

You can call the same function as many times as needed:

```python-execute
def draw_line():
    print("-" * 20)

def print_section_title(title):
    draw_line() 
    print(title)
    draw_line()

# Note: This example uses a parameter (title) which we'll learn about properly in the next section
# For now, just see how functions can be called multiple times

draw_line()
print("Starting program...")
draw_line()
print("Processing data...")
draw_line()
print("Program complete!")
draw_line()
```

## Functions That Call Other Functions

Functions can call other functions, which helps build complex programs from simple pieces:

```python-execute
def print_stars():
    print("*" * 15)

def print_title():
    print("  WELCOME USER  ")

def show_fancy_header():
    print_stars()
    print_title()
    print_stars()

# Calling one function that uses two other functions
show_fancy_header()
```

This demonstrates how functions can work together to accomplish bigger tasks.

## Execution Flow with Multiple Functions

```python-execute
def first_function():
    print("Executing first function")
    second_function()  # This calls another function
    print("Back in first function")

def second_function():
    print("Now in second function")
    print("Second function is finishing")

print("Starting main program")
first_function()
print("Main program ending")
```

Run this and carefully observe the order of the output. This shows how Python jumps between functions.

## Key Takeaways

- **Functions are defined with `def`**: Always use `def function_name():` format
- **Indentation matters**: All function code must be properly indented
- **Functions must be called**: Defining a function doesn't run it - you must call it
- **Execution flow**: Python jumps to the function, runs it, then returns to where it was called
- **Reusability**: Once defined, functions can be called as many times as needed
- **Organization**: Functions help break complex programs into manageable pieces

```quiz
id: function-execution-flow
question: What happens when you define a function but never call it?
options:
  - id: a
    text: Python runs the function automatically
    correct: false
    explanation: Functions only run when explicitly called. Defining them just makes them available for use.
  - id: b
    text: Python gives an error message
    correct: false
    explanation: It's perfectly fine to define functions and not call them. No error occurs.
  - id: c
    text: The function code never executes
    correct: true
    explanation: Correct! Functions only execute their code when called. Just defining them doesn't run them.
  - id: d
    text: The function runs once when defined
    correct: false
    explanation: Functions don't automatically run when defined. They wait to be called.
```

## The Next Level: Making Functions Flexible

You now understand the basics of creating and calling functions. You can eliminate code repetition and organize your programs better. But there's still a limitation with what we've learned so far.

Notice that all our functions do exactly the same thing every time they're called. The `print_separator()` function always prints the same separator. The `say_hello()` function always prints the same greeting.

But what if we want functions that can adapt to different situations? What if we want:
- A greeting function that can greet different people by name?
- A calculation function that can work with different numbers?
- A display function that can show different messages?

This is where **parameters** come in. In the next section, we'll learn how to make functions flexible by giving them input data (parameters) and how to get results back from them (return values). This will transform functions from simple code organizers into powerful, reusable tools that can solve a wide variety of problems.
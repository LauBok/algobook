# Creating Your First Functions

## Learning Objectives
- Write and call simple functions using Python syntax
- Understand the basic structure of function definitions
- Follow the execution flow when functions are called
- Practice creating functions that perform specific tasks
- Transform repetitive code from Section 5.1 into reusable functions

## Function Definition Syntax

### Basic Structure

Python implements functions through the `def` keyword, which creates named procedures that can be executed repeatedly. The fundamental syntax follows this structure:

```python
def function_name():
    # Code that executes when function is called
    print("This code runs when the function is called")
```

The essential components are:

- **`def`**: Keyword that begins function definition
- **`function_name`**: Identifier following Python naming conventions
- **`()`**: Parameter list (empty for functions without parameters)
- **`:`**: Colon marking the start of the function body
- **Indented block**: All statements belonging to the function, consistently indented

```note title="Indentation Requirements"
Python uses indentation to define which statements belong to a function. All code inside a function must be indented consistently (typically 4 spaces). This indentation creates the function's scope.
```

### Function Definition and Execution

Consider this example demonstrating function creation and use:

```python-execute
def say_hello():
    print("Hello there!")
    print("Welcome to our program!")
    print("Hope you're having a great day!")

# Call the function by using its name followed by parentheses
say_hello()
```

The execution process follows these steps:

1. **Definition**: The `def` statement creates the function and stores it in memory
2. **Invocation**: Calling `say_hello()` executes the function's code
3. **Return**: Control returns to the main program after execution completes

Importantly, defining a function does not execute its code—the code only runs when the function is called.

### Function Reusability

Once defined, functions can be called multiple times, eliminating code duplication:

```python-execute
def print_separator():
    print("=" * 30)

print_separator()
print("Section 1: Important Information")
print_separator()
print("Section 2: More Details")
print_separator()
```

This demonstrates the core advantage of functions:
1. **Write once**: Define the logic in one place
2. **Use many times**: Call the function whenever needed


## Practical Applications

### Code Transformation and Organization

Functions serve dual purposes: eliminating code redundancy and organizing program logic into manageable components. The following examples demonstrate both applications:

```python-execute
def print_grade_header():
    print("\n" + "=" * 25)
    print("  GRADE CALCULATOR")
    print("=" * 25)

# Function can be reused in multiple locations
print_grade_header()
print("Calculate your quiz grades below:")

print_grade_header() 
print("Calculate your exam grades below:")

print_grade_header()
print("Calculate your final grades below:")
```

### Structured Program Design

Beyond eliminating redundancy, functions enable hierarchical program organization. By decomposing complex programs into smaller, focused functions, we create modular designs that enhance readability and maintainability:

```python-execute
def print_welcome_message():
    print("Welcome to the Semester Progress Calculator!")
    print("This system evaluates academic performance metrics.")

def print_instructions():
    print("\nInstructions:")
    print("- Enter your current points earned")
    print("- Enter total points possible")
    print("- The system will calculate your percentage")

def print_goodbye_message():
    print("\nThanks for using the progress calculator!")
    print("Keep up the great work!")

# Main program using our functions
print_welcome_message()
print_instructions()

# Academic performance calculation implementation
current_points = int(input("\nCurrent points earned: "))
total_points = int(input("Total points possible: "))
percentage = (current_points / total_points) * 100
print(f"Current performance metric: {percentage:.1f}%")

print_goodbye_message()
```

This program structure demonstrates **functional decomposition**: each function handles a specific responsibility with clear boundaries. The main program becomes a high-level orchestration of these focused components, improving both comprehension and maintainability.

## Best Practices

### Naming Conventions

Function names should clearly convey their purpose and follow established Python conventions:

```python-execute
# Good function names - clear and descriptive
def display_rectangle_info():
    print("Rectangle area calculation will be implemented")
    print("Width × Height = Area")

def display_menu_options():
    print("1. Add numbers")
    print("2. Multiply numbers")
    print("3. Exit")

def display_input_requirements():
    print("Input requirements:")
    print("- Must be a positive number")
    print("- No special characters allowed")

# Demonstration of function invocation
display_rectangle_info()
print()
display_menu_options()
print()
display_input_requirements()
```

```warning title="Avoid Vague Names"
Functions named `do_stuff()`, `function1()`, or `temp()` fail to convey semantic meaning and impede code comprehension.
```

### Documentation Standards

Python supports structured function documentation through docstrings, enabling automated documentation generation and improved code maintainability:

```python-execute
def display_grade_process():
    """Show the steps for grade calculation."""
    print("Grade calculation process:")
    print("1. Collect points earned")
    print("2. Collect total points possible")
    print("3. Calculate percentage: (earned/total) × 100")

def display_welcome_screen():
    """Display welcome message and program overview."""
    print("Welcome to the Grade Calculator!")
    print("This program helps you track your academic progress")
    print("Follow the prompts to calculate your current grade")

# Invocation of documented functions
display_grade_process()
print()
display_welcome_screen()
```

Docstrings utilize triple-quote delimiters and follow PEP 257 conventions for consistent documentation standards.

```note title="Documentation Standards"
Docstrings provide inline documentation following Python Enhancement Proposal (PEP) 257. They enable automated documentation generation and improve code maintainability. Professional codebases require comprehensive function documentation.
```

## Assessment and Practice

```quiz
id: function-syntax-basics
question: Which of these correctly defines a function named `print_message`?
options:
  - id: a
    text: |
      ```python
      function print_message():
          print("Hello")
      ```
    correct: false
    explanation: Python uses `def`, not `function`, to define functions.
  - id: b
    text: |
      ```python
      def print_message():
          print("Hello")
      ```
    correct: true
    explanation: Correct! This uses the proper `def` keyword, function name, parentheses, colon, and indented body.
  - id: c
    text: |
      ```python
      def print_message()
          print("Hello")
      ```
    correct: false
    explanation: Missing the colon (:) after the parentheses. Python requires a colon to start the function body.
  - id: d
    text: |
      ```python
      def print_message():
      print("Hello")
      ```
    correct: false
    explanation: The function body must be indented. Without indentation, Python doesn't know what code belongs in the function.
```

```exercise
id: first-function-creation
title: Create a Message Function
description: Write a function called `display_welcome` that prints two lines welcoming new users to a program.
difficulty: easy
starterCode: |
  # Write your function here
  def display_welcome():
      # Add your code below this line
      pass

  # Test your function
  display_welcome()
testCases:
  - input: ""
    expectedOutput: "Welcome to our amazing program!\nWe're glad you're here!"
  - input: ""
    expectedOutput: "Welcome to our amazing program!\nWe're glad you're here!"
    hidden: true
hints:
  - "Use print() statements inside your function"
  - "Your function should print exactly two lines"
  - "Replace 'pass' with your print statements"
  - "Look at the expected output to see exactly what to print"
```

## Key Concepts

- **Syntax**: Function definitions utilize `def` keyword with proper indentation for lexical scoping
- **Execution Model**: Function invocation transfers control to function body, then returns to caller
- **Reusability**: Functions enable multiple invocations of identical computational logic
- **Abstraction**: Functions encapsulate implementation details behind descriptive interfaces
- **Modularity**: Hierarchical program organization through functional decomposition

```quiz
id: function-execution-flow
question: What happens when you define a function but never call it?
options:
  - id: a
    text: Python runs the function automatically
    correct: false
    explanation: Functions only run when explicitly called. Defining them just makes them available for use.
  - id: b
    text: Python gives an error message
    correct: false
    explanation: It's perfectly fine to define functions and not call them. No error occurs.
  - id: c
    text: The function code never executes
    correct: true
    explanation: Correct! Functions only execute their code when called. Just defining them doesn't run them.
  - id: d
    text: The function runs once when defined
    correct: false
    explanation: Functions don't automatically run when defined. They wait to be called.
```

## Advanced Function Concepts

The functions demonstrated thus far exhibit static behavior—identical output for each invocation. This constraint limits functional utility in diverse computational contexts.

**Parametric functions** extend functional capability through:
- Input parameterization enabling dynamic behavior
- Return value mechanisms for computational results
- Enhanced abstraction supporting algorithmic generalization

Section 5.3 introduces these advanced concepts, transforming functions from static code organizers into dynamic computational abstractions capable of addressing variable problem domains.
# Practice and Review: Building with Functions

## Learning Objectives
- Apply all function concepts to solve substantial problems
- Refactor repetitive code from previous chapters into clean functions
- Experience the benefits of modular, function-based programming
- Build confidence with function composition and design
- Practice translating problems into function-based solutions

## The Transformation: From Messy to Elegant

You've come a long way in this chapter! You started by recognizing the problems with repetitive code, learned to create basic functions, discovered parameters and return values, and explored advanced concepts like lambda expressions.

Now it's time for the payoff: taking the messy, repetitive code from earlier chapters and transforming it into clean, elegant, function-based solutions. You'll see firsthand how functions don't just eliminate repetition - they completely change how you think about solving problems.

## Refactoring Previous Work: Before and After

Let's revisit some problems from earlier chapters and see the dramatic transformation that functions provide. Remember the repetitive temperature conversion code you might have written in Chapter 1?

### Before Functions (Chapter 1 Style)

```python-execute
# Converting multiple temperatures - the repetitive way
temp1_f = 98.6
temp1_c = (temp1_f - 32) * 5/9
print(f"{temp1_f}°F is {temp1_c:.1f}°C")

temp2_f = 212
temp2_c = (temp2_f - 32) * 5/9  
print(f"{temp2_f}°F is {temp2_c:.1f}°C")

temp3_f = 32
temp3_c = (temp3_f - 32) * 5/9
print(f"{temp3_f}°F is {temp3_c:.1f}°C")
```

### After Functions (Clean and Reusable)

```python-execute
def fahrenheit_to_celsius(fahrenheit):
    """Convert Fahrenheit to Celsius"""
    celsius = (fahrenheit - 32) * 5/9
    return celsius

def celsius_to_fahrenheit(celsius):
    """Convert Celsius to Fahrenheit"""
    fahrenheit = celsius * 9/5 + 32
    return fahrenheit

def display_temperature_conversion(temp, from_unit, to_unit, conversion_func):
    """Display a temperature conversion clearly"""
    converted = conversion_func(temp)
    print(f"{temp}°{from_unit} is {converted:.1f}°{to_unit}")

# Now converting temperatures is clean and flexible
temps_f = [98.6, 212, 32, 0, 100]
for temp in temps_f:
    display_temperature_conversion(temp, "F", "C", fahrenheit_to_celsius)

print()  # Blank line

# Easy to convert the other direction too
temps_c = [37, 100, 0, -10, 25]
for temp in temps_c:
    display_temperature_conversion(temp, "C", "F", celsius_to_fahrenheit)
```

Look at this transformation! The function-based version:

**1. Eliminates repetition**: No more copying the same formula multiple times  
**2. Makes intent clear**: Function names explain exactly what's happening  
**3. Enables flexibility**: Easy to convert in either direction with different data  
**4. Simplifies maintenance**: If the conversion formula changes, update it in one place  
**5. Improves readability**: The main program reads like a clear outline

This is the power of functions - they don't just save typing, they transform how you think about and organize code.

```quiz
id: refactoring-benefits
question: What is the main advantage of refactoring repetitive code into functions?
options:
  - id: faster
    text: The code runs faster
    correct: false
    explanation: While functions might have slight performance overhead, the main benefit is not speed.
  - id: reusability
    text: The code becomes reusable and easier to maintain
    correct: true
    explanation: Correct! Functions eliminate repetition and make code easier to modify, test, and reuse.
  - id: shorter
    text: The code file becomes shorter
    correct: false
    explanation: While function-based code might be shorter, the main benefit is organization and reusability.
  - id: automatic
    text: Python automatically optimizes function calls
    correct: false
    explanation: The benefits come from better code organization, not automatic optimization.
```

## Building a Grade Calculator System

Let's create a comprehensive grade calculator using everything we've learned:

```python-execute
def calculate_percentage(points_earned, points_possible):
    """Calculate percentage score"""
    if points_possible == 0:
        return 0
    return (points_earned / points_possible) * 100

def get_letter_grade(percentage):
    """Convert percentage to letter grade"""
    if percentage >= 97:
        return "A+"
    elif percentage >= 93:
        return "A"
    elif percentage >= 90:
        return "A-"
    elif percentage >= 87:
        return "B+"
    elif percentage >= 83:
        return "B"
    elif percentage >= 80:
        return "B-"
    elif percentage >= 77:
        return "C+"
    elif percentage >= 73:
        return "C"
    elif percentage >= 70:
        return "C-"
    elif percentage >= 67:
        return "D+"
    elif percentage >= 63:
        return "D"
    elif percentage >= 60:
        return "D-"
    else:
        return "F"

def calculate_weighted_average(scores, weights):
    """Calculate weighted average of multiple scores"""
    if len(scores) != len(weights):
        return 0
    
    total_weighted_score = 0
    total_weight = 0
    
    for score, weight in zip(scores, weights):
        total_weighted_score += score * weight
        total_weight += weight
    
    if total_weight == 0:
        return 0
    return total_weighted_score / total_weight

def display_grade_report(student_name, categories, scores, weights):
    """Display a complete grade report for a student"""
    print(f"\n{'='*40}")
    print(f"GRADE REPORT FOR {student_name.upper()}")
    print(f"{'='*40}")
    
    # Show individual categories
    for i, category in enumerate(categories):
        percentage = scores[i]
        letter = get_letter_grade(percentage)
        print(f"{category:<15}: {percentage:>6.1f}% ({letter})")
    
    # Calculate and show overall grade
    overall = calculate_weighted_average(scores, weights)
    overall_letter = get_letter_grade(overall)
    
    print(f"{'-'*40}")
    print(f"{'OVERALL':<15}: {overall:>6.1f}% ({overall_letter})")
    print(f"{'='*40}")

# Use the grade calculator system
categories = ["Homework", "Quizzes", "Midterm", "Final"]
alice_scores = [88.5, 92.0, 85.0, 90.0]
weights = [0.25, 0.25, 0.25, 0.25]  # Equal weighting

display_grade_report("Alice Johnson", categories, alice_scores, weights)

# Different student with different scores
bob_scores = [95.0, 78.0, 88.0, 92.0]
display_grade_report("Bob Smith", categories, bob_scores, weights)
```

This system is modular, reusable, and easy to modify. Each function has a single, clear purpose.

```quiz
id: function-design-principle
question: In the grade calculator system, why is it better to have separate functions like `calculate_percentage()` and `get_letter_grade()` instead of one big function?
options:
  - id: memory
    text: Separate functions use less memory
    correct: false
    explanation: Memory usage is not the primary concern in function design.
  - id: single-purpose
    text: Each function has a single, clear responsibility that's easy to test and reuse
    correct: true
    explanation: Exactly! This follows the "single responsibility principle" - each function does one thing well.
  - id: faster
    text: Multiple small functions run faster than one large function
    correct: false
    explanation: Performance is usually similar, but maintainability is much better with focused functions.
  - id: required
    text: Python requires functions to be small
    correct: false
    explanation: Python doesn't enforce function size limits - this is a design best practice.
```

## Mathematical Function Library

Let's build a collection of useful math functions:

```python-execute
def calculate_compound_interest(principal, annual_rate, years, compounds_per_year=1):
    """Calculate compound interest: A = P(1 + r/n)^(nt)"""
    rate = annual_rate / 100  # Convert percentage to decimal
    amount = principal * (1 + rate/compounds_per_year) ** (compounds_per_year * years)
    return amount

def calculate_loan_payment(principal, annual_rate, years):
    """Calculate monthly loan payment"""
    monthly_rate = annual_rate / 100 / 12
    months = years * 12
    
    if monthly_rate == 0:  # No interest case
        return principal / months
    
    payment = principal * (monthly_rate * (1 + monthly_rate)**months) / ((1 + monthly_rate)**months - 1)
    return payment

def calculate_distance_2d(x1, y1, x2, y2):
    """Calculate distance between two 2D points"""
    return ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5

def calculate_quadratic_roots(a, b, c):
    """Calculate roots of quadratic equation ax² + bx + c = 0"""
    discriminant = b**2 - 4*a*c
    
    if discriminant < 0:
        return None  # No real roots
    elif discriminant == 0:
        root = -b / (2*a)
        return (root, root)  # One repeated root
    else:
        sqrt_discriminant = discriminant ** 0.5
        root1 = (-b + sqrt_discriminant) / (2*a)
        root2 = (-b - sqrt_discriminant) / (2*a)
        return (root1, root2)

# Test our math library
print("Investment Calculator:")
investment = calculate_compound_interest(1000, 5, 10, 4)
print(f"$1,000 at 5% for 10 years (quarterly): ${investment:.2f}")

print("\nLoan Calculator:")
monthly_payment = calculate_loan_payment(25000, 4.5, 5)
print(f"$25,000 loan at 4.5% for 5 years: ${monthly_payment:.2f}/month")

print("\nDistance Calculator:")
distance = calculate_distance_2d(0, 0, 3, 4)
print(f"Distance from (0,0) to (3,4): {distance:.2f}")

print("\nQuadratic Equation Solver:")
roots = calculate_quadratic_roots(1, -5, 6)  # x² - 5x + 6 = 0
if roots:
    print(f"Roots of x² - 5x + 6 = 0: {roots[0]:.2f} and {roots[1]:.2f}")
```

```quiz
id: function-parameters
question: In the function `calculate_compound_interest(principal, annual_rate, years, compounds_per_year=1)`, what does the `=1` mean?
options:
  - id: assignment
    text: It assigns 1 to the variable compounds_per_year
    correct: false
    explanation: The = in function parameters doesn't create assignments like regular variables.
  - id: default-value
    text: It sets 1 as the default value if compounds_per_year is not provided
    correct: true
    explanation: Correct! This is a default parameter - if the caller doesn't provide compounds_per_year, it defaults to 1.
  - id: comparison
    text: It checks if compounds_per_year equals 1
    correct: false
    explanation: This syntax doesn't perform comparisons - that would be == in an if statement.
  - id: minimum
    text: It sets 1 as the minimum allowed value
    correct: false
    explanation: Default parameters don't enforce minimum values - they just provide defaults when arguments aren't given.
```

## Text Processing with Functions

Functions excel at text processing tasks:

```python-execute
def count_words(text):
    """Count words in a text string"""
    return len(text.split())

def count_characters(text, include_spaces=True):
    """Count characters in text"""
    if include_spaces:
        return len(text)
    else:
        return len(text.replace(" ", ""))

def capitalize_words(text):
    """Capitalize first letter of each word"""
    words = text.split()
    capitalized_words = []
    for word in words:
        if word:  # Make sure word isn't empty
            capitalized_word = word[0].upper() + word[1:].lower()
            capitalized_words.append(capitalized_word)
    return " ".join(capitalized_words)

def reverse_words(text):
    """Reverse the order of words in text"""
    words = text.split()
    reversed_words = []
    for i in range(len(words) - 1, -1, -1):
        reversed_words.append(words[i])
    return " ".join(reversed_words)

def analyze_text(text):
    """Perform comprehensive text analysis"""
    print(f"Text Analysis for: '{text}'")
    print(f"{'='*50}")
    print(f"Word count: {count_words(text)}")
    print(f"Characters (with spaces): {count_characters(text, True)}")
    print(f"Characters (no spaces): {count_characters(text, False)}")
    print(f"Capitalized: {capitalize_words(text)}")
    print(f"Reversed words: {reverse_words(text)}")
    print()

# Test text processing functions
sample_texts = [
    "hello world python programming",
    "functions make code cleaner and more reusable",
    "the quick brown fox jumps over the lazy dog"
]

for text in sample_texts:
    analyze_text(text)
```

```quiz
id: return-vs-print
question: The function `capitalize_words()` uses `return` to send back the result, while `analyze_text()` uses `print` to display output. When should you use return vs print?
options:
  - id: return-always
    text: Always use return - print should never be used in functions
    correct: false
    explanation: Both have their place. Print is fine for functions meant to display output to users.
  - id: depends-on-purpose
    text: Use return when you need the result for further processing, print when displaying final output to users
    correct: true
    explanation: Exactly! Return lets other parts of your program use the result, while print is for user display.
  - id: print-always
    text: Always use print - return is only for advanced programmers
    correct: false
    explanation: Return is fundamental and often necessary for functions to be useful in larger programs.
  - id: same-thing
    text: Return and print do the same thing in functions
    correct: false
    explanation: They serve very different purposes - return sends values back, print displays to users.
```

## Data Validation Functions

Functions are perfect for validating user input:

```python-execute
def is_valid_email(email):
    """Basic email validation"""
    if "@" not in email:
        return False
    if "." not in email:
        return False
    parts = email.split("@")
    if len(parts) != 2:
        return False
    if len(parts[0]) == 0 or len(parts[1]) == 0:
        return False
    return True

def is_valid_phone(phone):
    """Basic phone number validation"""
    # Remove common separators
    cleaned = phone.replace("-", "").replace("(", "").replace(")", "").replace(" ", "")
    
    # Check if all remaining characters are digits
    if not cleaned.isdigit():
        return False
    
    # Check length (assuming US phone numbers)
    return len(cleaned) == 10 or len(cleaned) == 11

def is_strong_password(password):
    """Check if password meets strength requirements"""
    if len(password) < 8:
        return False
    
    has_upper = any(c.isupper() for c in password)
    has_lower = any(c.islower() for c in password)  
    has_digit = any(c.isdigit() for c in password)
    has_special = any(not c.isalnum() for c in password)
    
    return has_upper and has_lower and has_digit and has_special

def validate_user_data(email, phone, password):
    """Validate all user registration data"""
    errors = []
    
    if not is_valid_email(email):
        errors.append("Invalid email format")
    
    if not is_valid_phone(phone):
        errors.append("Invalid phone number format")
        
    if not is_strong_password(password):
        errors.append("Password must be 8+ chars with upper, lower, digit, and special character")
    
    return errors

# Test validation functions
test_data = [
    ("alice@email.com", "555-123-4567", "StrongPass123!"),
    ("invalid-email", "123-456", "weak"),
    ("bob@test.org", "(555) 987-6543", "MySecure2024@")
]

for email, phone, password in test_data:
    print(f"Testing: {email}, {phone}, {password}")
    errors = validate_user_data(email, phone, password)
    if errors:
        print(f"  Errors: {', '.join(errors)}")
    else:
        print("  ✓ All data valid!")
    print()
```

```quiz
id: validation-functions
question: Why is it beneficial to create separate validation functions like `is_valid_email()` and `is_valid_phone()` rather than putting all validation logic in one function?
options:
  - id: required-syntax
    text: Python syntax requires separate functions for different data types
    correct: false
    explanation: Python doesn't enforce this - it's a design choice.
  - id: modular-testing
    text: Each function can be tested independently and reused in different contexts
    correct: true
    explanation: Correct! Separate functions are easier to test, debug, and reuse across different parts of your program.
  - id: performance
    text: Multiple small functions are always faster than one large function
    correct: false
    explanation: Performance is usually similar - the benefit is in code organization and maintainability.
  - id: memory-efficient
    text: Separate functions use less memory
    correct: false
    explanation: Memory usage is not the primary consideration in this design choice.
```

## Comprehensive Practice Problems

```exercise
id: statistics-calculator
title: Statistical Analysis Functions
description: Create functions to calculate basic statistics for a list of numbers. Focus on writing the statistical calculations - the testing system will handle data input and output formatting.
difficulty: medium
starterCode: |
  def calculate_mean(numbers):
      # Calculate the arithmetic mean (sum / count)
      pass
  
  def calculate_median(numbers):
      # Calculate the median (middle value when sorted)
      # Tip: sort first, then find middle element(s)
      pass
  
  def calculate_range(numbers):
      # Calculate range (max - min)
      pass
prepend: |
  # Read the data
  data = list(map(int, input().split()))
postpend: |
  mean = calculate_mean(data)
  median = calculate_median(data)
  range_val = calculate_range(data)
  print(f"Mean: {mean:.1f}")
  print(f"Median: {median:.1f}")  
  print(f"Range: {range_val}")
testCases:
  - input: "85 92 78 96 88 76 89 94"
    expectedOutput: "Mean: 87.2\nMedian: 88.5\nRange: 20"
  - input: "100 95 85 90 80"
    expectedOutput: "Mean: 90.0\nMedian: 90.0\nRange: 20"
  - input: "70 75 80 85 90"
    expectedOutput: "Mean: 80.0\nMedian: 80.0\nRange: 20"
    hidden: true
  - input: "95 87 91 83 89 94 86"
    expectedOutput: "Mean: 89.3\nMedian: 89.0\nRange: 12"
    hidden: true
  - input: "60 65 70 75 80 85"
    expectedOutput: "Mean: 72.5\nMedian: 72.5\nRange: 25"
    hidden: true
  - input: "100 90 80 70 60"
    expectedOutput: "Mean: 80.0\nMedian: 80.0\nRange: 40"
    hidden: true
  - input: "88 92 85 91 87 93 89"
    expectedOutput: "Mean: 89.3\nMedian: 89.0\nRange: 8"
    hidden: true
  - input: "50 60 70 80 90 100"
    expectedOutput: "Mean: 75.0\nMedian: 75.0\nRange: 50"
    hidden: true
  - input: "77 82 88 91 95"
    expectedOutput: "Mean: 86.6\nMedian: 88.0\nRange: 18"
    hidden: true
  - input: "65 70 75 80 85 90 95"
    expectedOutput: "Mean: 80.0\nMedian: 80.0\nRange: 30"
    hidden: true
  - input: "98 76 84 90 82 88 86"
    expectedOutput: "Mean: 86.3\nMedian: 86.0\nRange: 22"
    hidden: true
  - input: "72 78 81 85 89 92"
    expectedOutput: "Mean: 82.8\nMedian: 83.0\nRange: 20"
    hidden: true
hints:
  - "Mean = sum of all values / count of values"
  - "For median, sort the list first then find middle value(s)"
  - "Range = maximum value - minimum value"
  - "Use built-in functions like sum(), len(), min(), max(), sorted()"
solution: |
  def calculate_mean(numbers):
      return sum(numbers) / len(numbers)
  
  def calculate_median(numbers):
      sorted_nums = sorted(numbers)
      n = len(sorted_nums)
      if n % 2 == 0:
          return (sorted_nums[n//2 - 1] + sorted_nums[n//2]) / 2
      else:
          return sorted_nums[n//2]
  
  def calculate_range(numbers):
      return max(numbers) - min(numbers)
```

```exercise
id: number-system-converter
title: Number System Conversion Functions
description: Create functions to convert between decimal, binary, and hexadecimal number systems.
difficulty: medium
starterCode: |
  def decimal_to_binary(decimal_num):
      # Convert decimal to binary string
      # Use bin() function and remove '0b' prefix
      pass
  
  def decimal_to_hex(decimal_num):
      # Convert decimal to hexadecimal string  
      # Use hex() function, remove '0x' prefix, and convert to uppercase
      pass
  
  def binary_to_decimal(binary_str):
      # Convert binary string to decimal
      # Use int(binary_str, 2) to convert from base 2
      pass
prepend: |
  num = int(input())
postpend: |
  binary = decimal_to_binary(num)
  hex_val = decimal_to_hex(num)
  back_to_decimal = binary_to_decimal(binary)
  
  print(f"Decimal: {num}")
  print(f"Binary: {binary}")
  print(f"Hex: {hex_val}")
  print(f"Back to decimal: {back_to_decimal}")
testCases:
  - input: "42"
    expectedOutput: "Decimal: 42\nBinary: 101010\nHex: 2A\nBack to decimal: 42"
  - input: "15"
    expectedOutput: "Decimal: 15\nBinary: 1111\nHex: F\nBack to decimal: 15"
  - input: "255"
    expectedOutput: "Decimal: 255\nBinary: 11111111\nHex: FF\nBack to decimal: 255"
    hidden: true
  - input: "100"
    expectedOutput: "Decimal: 100\nBinary: 1100100\nHex: 64\nBack to decimal: 100"
    hidden: true
  - input: "7"
    expectedOutput: "Decimal: 7\nBinary: 111\nHex: 7\nBack to decimal: 7"
    hidden: true
  - input: "128"
    expectedOutput: "Decimal: 128\nBinary: 10000000\nHex: 80\nBack to decimal: 128"
    hidden: true
  - input: "63"
    expectedOutput: "Decimal: 63\nBinary: 111111\nHex: 3F\nBack to decimal: 63"
    hidden: true
  - input: "200"
    expectedOutput: "Decimal: 200\nBinary: 11001000\nHex: C8\nBack to decimal: 200"
    hidden: true
  - input: "31"
    expectedOutput: "Decimal: 31\nBinary: 11111\nHex: 1F\nBack to decimal: 31"
    hidden: true
  - input: "16"
    expectedOutput: "Decimal: 16\nBinary: 10000\nHex: 10\nBack to decimal: 16"
    hidden: true
  - input: "1"
    expectedOutput: "Decimal: 1\nBinary: 1\nHex: 1\nBack to decimal: 1"
    hidden: true
  - input: "85"
    expectedOutput: "Decimal: 85\nBinary: 1010101\nHex: 55\nBack to decimal: 85"
    hidden: true
hints:
  - "Use Python's built-in bin(), hex(), and int() functions"
  - "bin() returns '0b101010', so slice off the '0b' prefix"
  - "hex() returns '0x2a', so slice off '0x' and convert to uppercase"
  - "int(binary_string, 2) converts binary string to decimal"
solution: |
  def decimal_to_binary(decimal_num):
      return bin(decimal_num)[2:]  # Remove '0b' prefix
  
  def decimal_to_hex(decimal_num):
      return hex(decimal_num)[2:].upper()  # Remove '0x' and uppercase
  
  def binary_to_decimal(binary_str):
      return int(binary_str, 2)
```

## Algorithm Implementation with Functions

Let's implement some simple algorithms using functions:

```python-execute
def linear_search(data, target):
    """Search for target in data list, return index or -1 if not found"""
    for i in range(len(data)):
        if data[i] == target:
            return i
    return -1

def find_maximum(data):
    """Find maximum value in a list"""
    if not data:  # Empty list
        return None
    
    max_value = data[0]
    for item in data:
        if item > max_value:
            max_value = item
    return max_value

def count_occurrences(data, target):
    """Count how many times target appears in data"""
    count = 0
    for item in data:
        if item == target:
            count += 1
    return count

def bubble_sort(data):
    """Sort data using bubble sort algorithm"""
    # Make a copy to avoid modifying original
    sorted_data = data[:]
    n = len(sorted_data)
    
    for i in range(n):
        for j in range(0, n - i - 1):
            if sorted_data[j] > sorted_data[j + 1]:
                # Swap elements
                sorted_data[j], sorted_data[j + 1] = sorted_data[j + 1], sorted_data[j]
    
    return sorted_data

# Test algorithm functions
test_data = [64, 34, 25, 12, 22, 11, 90]

print("Original data:", test_data)
print(f"Index of 25: {linear_search(test_data, 25)}")
print(f"Maximum value: {find_maximum(test_data)}")
print(f"Count of 22: {count_occurrences(test_data, 22)}")
print(f"Sorted data: {bubble_sort(test_data)}")
print("Original unchanged:", test_data)
```

```quiz
id: algorithm-functions
question: In the `bubble_sort()` function, why do we create a copy of the data with `sorted_data = data[:]` instead of modifying the original list?
options:
  - id: faster
    text: Copying the data makes the sort run faster
    correct: false
    explanation: Making a copy actually adds a small performance cost, not a benefit.
  - id: preserve-original
    text: To preserve the original data so the caller's list isn't unexpectedly modified
    correct: true
    explanation: Correct! This prevents "side effects" - the function does its job without changing the caller's data unexpectedly.
  - id: python-requirement
    text: Python requires all functions to work on copies
    correct: false
    explanation: Python allows functions to modify their parameters - this is a design choice for safer code.
  - id: memory-management
    text: To help Python manage memory more efficiently
    correct: false
    explanation: This is about preventing unexpected modifications, not memory management.
```

## Higher-Order Functions: Map and Filter Combined

Let's practice creating higher-order functions by implementing a function that combines mapping and filtering. This demonstrates how functions can take multiple function parameters to create powerful, reusable code:

Now let's practice implementing this concept yourself!

```exercise
id: map-and-filter-implementation
title: Map and Filter Function
description: Implement a function that applies a transformation to items in a list, but only to items that satisfy a predicate condition.
difficulty: medium
starterCode: |
  def map_and_filter(items, transform_func, predicate_func):
      # Create a new list containing transform_func(item) for items where predicate_func(item) is True
      # Loop through items
      # For each item, first check if predicate_func(item) is True
      # If True, apply transform_func(item) and add result to output list
      pass
prepend: |
  def is_positive(num):
      return num > 0
  
  def is_long_word(word):
      return len(word) > 4
      
  def square(num):
      return num * num
      
  def make_uppercase(word):
      return word.upper()
  
  # Read test data
  numbers = list(map(int, input().split()))
  words = input().split()
postpend: |
  # Test: square positive numbers
  squared_positives = map_and_filter(numbers, square, is_positive)
  print(f"Squared positives: {squared_positives}")
  
  # Test: uppercase long words
  uppercase_long = map_and_filter(words, make_uppercase, is_long_word)
  print(f"Uppercase long words: {uppercase_long}")
  
  # Test: triple even numbers using lambda
  tripled_evens = map_and_filter(numbers, lambda x: x * 3, lambda x: x % 2 == 0)
  print(f"Tripled evens: {tripled_evens}")
testCases:
  - input: "1 -2 3 4 -5 6 7 8\napple dog elephant cat umbrella fish"
    expectedOutput: "Squared positives: [1, 9, 16, 36, 49, 64]\nUppercase long words: ['APPLE', 'ELEPHANT', 'UMBRELLA']\nTripled evens: [-6, 12, 18, 24]"
  - input: "10 -3 5 2 -1 8 9\noctopus cat igloo banana orange ant"
    expectedOutput: "Squared positives: [100, 25, 4, 64, 81]\nUppercase long words: ['OCTOPUS', 'IGLOO', 'BANANA', 'ORANGE']\nTripled evens: [30, 6, 24]"
  - input: "0 -4 7 -6 3 1 12\nice bird airplane monkey eagle tiger"
    expectedOutput: "Squared positives: [49, 9, 1, 144]\nUppercase long words: ['AIRPLANE', 'MONKEY', 'EAGLE', 'TIGER']\nTripled evens: [0, -12, -18, 36]"
    hidden: true
  - input: "2 -1 -3 5 8 -7 4\nunder boat ocean tree island mountain"
    expectedOutput: "Squared positives: [4, 25, 64, 16]\nUppercase long words: ['UNDER', 'OCEAN', 'ISLAND', 'MOUNTAIN']\nTripled evens: [6, 24, 12]"
    hidden: true
  - input: "-2 6 1 -5 9 3 -8\navocado snake eagle rabbit ostrich lion"
    expectedOutput: "Squared positives: [36, 1, 81, 9]\nUppercase long words: ['AVOCADO', 'SNAKE', 'EAGLE', 'RABBIT', 'OSTRICH']\nTripled evens: [-6, 18, -24]"
    hidden: true
  - input: "4 7 -1 2 -9 11 6\napple dog umbrella cat elephant whale"
    expectedOutput: "Squared positives: [16, 49, 4, 121, 36]\nUppercase long words: ['APPLE', 'UMBRELLA', 'ELEPHANT', 'WHALE']\nTripled evens: [12, 6, 18]"
    hidden: true
  - input: "-10 3 8 -2 1 5 -4\nice cream tiger eagle ant monkey parrot"
    expectedOutput: "Squared positives: [9, 64, 1, 25]\nUppercase long words: ['CREAM', 'TIGER', 'EAGLE', 'MONKEY', 'PARROT']\nTripled evens: [-30, 24, -6, -12]"
    hidden: true
  - input: "9 -6 -3 2 7 4 -1\noctopus dog island cat umbrella bird tree"
    expectedOutput: "Squared positives: [81, 4, 49, 16]\nUppercase long words: ['OCTOPUS', 'ISLAND', 'UMBRELLA']\nTripled evens: [-18, 6, 12]"
    hidden: true
  - input: "-7 1 6 -4 8 3 0\nelephant snake apple dog igloo whale fish"
    expectedOutput: "Squared positives: [1, 36, 64, 9]\nUppercase long words: ['ELEPHANT', 'SNAKE', 'APPLE', 'IGLOO', 'WHALE']\nTripled evens: [18, -12, 24, 0]"
    hidden: true
  - input: "5 -8 2 9 -3 7 4\nunder monkey eagle cat airplane tiger bird"
    expectedOutput: "Squared positives: [25, 4, 81, 49, 16]\nUppercase long words: ['UNDER', 'MONKEY', 'EAGLE', 'AIRPLANE', 'TIGER']\nTripled evens: [-24, 6, 12]"
    hidden: true
hints:
  - "First check predicate_func(item), then apply transform_func(item) if True"
  - "Only add transformed items to the result list"
  - "The pattern is: if predicate_func(item): result.append(transform_func(item))"
  - "Both functions are already provided - focus on the map-and-filter logic"
solution: |
  def map_and_filter(items, transform_func, predicate_func):
      result = []
      for item in items:
          if predicate_func(item):
              result.append(transform_func(item))
      return result
```

## Chapter Review Quiz

```quiz
id: function-concepts-review
questions:
  - id: q1
    question: What is the main benefit of using functions in programming?
    options:
      - id: a
        text: Functions make programs run faster
        correct: false
      - id: b
        text: Functions eliminate code repetition and improve organization
        correct: true
      - id: c
        text: Functions are required by Python
        correct: false
      - id: d
        text: Functions automatically fix bugs in your code
        correct: false
    explanation: Functions help organize code and eliminate repetition, making programs more maintainable and readable.
  
  - id: q2
    question: When should you use return instead of print in a function?
    options:
      - id: a
        text: When you want to use the function's result in other parts of your program
        correct: true
      - id: b
        text: When you want to display output to the user
        correct: false
      - id: c
        text: Print and return do the same thing
        correct: false
      - id: d
        text: Return is faster than print
        correct: false
    explanation: Return sends values back for program use; print displays information to users.

  - id: q3
    question: "What does this lambda expression do: `lambda x: x ** 2 + 1`?"
    options:
      - id: a
        text: "Squares x then adds 1"
        correct: true
      - id: b
        text: "Adds 1 to x then squares the result"
        correct: false
      - id: c
        text: "Raises x to the power of (2 + 1)"
        correct: false
      - id: d
        text: "Multiplies x by 2 then adds 1"
        correct: false
    explanation: "The expression evaluates x ** 2 first, then adds 1 to that result."
```

## Key Takeaways

- **Functions eliminate repetition**: Write once, use many times
- **Parameters provide flexibility**: Same function, different inputs
- **Return values enable composition**: Functions can work together
- **Lambda creates inline functions**: Perfect for simple, one-time use
- **Functions as values**: Store, pass, and manipulate functions like data
- **Modular design**: Break complex problems into manageable functions
- **Testing is easier**: Each function can be tested independently
- **Code becomes self-documenting**: Good function names explain what code does

```note title="Functions Transform Programming"
You've now learned one of the most important concepts in programming. Functions don't just reduce typing - they fundamentally change how you think about and solve problems. Instead of writing long scripts, you now think in terms of reusable building blocks that can be combined in countless ways.
```

## Your Programming Transformation

You've mastered one of programming's most fundamental concepts. Compare where you started to where you are now:

**Before Functions:**
```python
# Calculate area 1
length1 = 5
width1 = 3
area1 = length1 * width1
print(f"Area 1: {area1}")

# Calculate area 2  
length2 = 10
width2 = 7
area2 = length2 * width2
print(f"Area 2: {area2}")
```

**With Functions:**
```python
def calculate_area(length, width):
    return length * width

areas = [(5, 3), (10, 7), (8, 4)]
for i, (l, w) in enumerate(areas, 1):
    print(f"Area {i}: {calculate_area(l, w)}")
```

This represents a complete shift in how you solve problems - from repetitive scripts to reusable, composable solutions.

## Your Function Toolkit

You now have comprehensive function capabilities:

✅ **Function Creation**: Organize code and eliminate repetition  
✅ **Parameters & Returns**: Make functions flexible and composable  
✅ **Default Parameters**: Create convenient, user-friendly interfaces  
✅ **Higher-Order Functions**: Use functions as parameters for powerful abstractions  
✅ **Lambda Expressions**: Create concise inline functions  

## What's Next

In Chapter 6, you'll learn **recursion** - functions that call themselves to solve complex problems by breaking them into smaller pieces. Every algorithm and data structure from here forward will build on the function foundation you've established.

From there, you'll use functions as the foundation for:
- **Algorithms**: Step-by-step problem-solving procedures
- **Data Structures**: Organized ways to store and access data  
- **Object-Oriented Programming**: Bundling functions with data
- **Advanced Programming Patterns**: Professional development techniques

## Congratulations!

You've mastered one of the most important concepts in programming. Functions aren't just a Python feature - they're a fundamental way of thinking that applies to every programming language and every software project.

Every complex program you'll ever write will be built from functions working together. You now have the skills to write clean, organized, reusable code that other programmers will admire and that you'll be proud of.

Functions will be your constant companion in all future programming adventures. Welcome to the next level of programming!
# Parameters and Return Values

## Learning Objectives
- Write functions that accept input through parameters
- Pass data to functions using arguments
- Use return statements to send results back from functions
- Distinguish between printing output and returning values
- Apply default parameter values for optional inputs
- Call functions using parameter names instead of position
- Understand how Python passes different data types to functions
- Avoid common pitfalls with mutable default parameters

## Making Functions Flexible with Parameters

In Section 5.2, we created functions that organize code and eliminate repetition. However, all our functions had a significant limitation: they did exactly the same thing every time we called them.

Consider the grade calculation problem from Section 5.1:

```python-execute
# This is what we had to do before parameters
def calculate_quiz1_grade():
    points = 18
    total = 20
    percentage = (points / total) * 100
    print(f"Quiz 1: {percentage}%")

def calculate_quiz2_grade():
    points = 23
    total = 25
    percentage = (points / total) * 100
    print(f"Quiz 2: {percentage}%")

calculate_quiz1_grade()
calculate_quiz2_grade()
```

Notice how we're copying the same calculation logic but with different numbers. What if we could write **one function** that works with any values we give it?

### Introduction to Parameters

**Parameters** are variables that allow functions to accept input when they're called. Think of them as placeholders that get filled in with actual values:

```python-execute
def greet_person(name):
    print(f"Hello, {name}!")
    print(f"Welcome to our program, {name}!")

# Now we can greet different people with the same function
greet_person("Alice")
print()
greet_person("Bob")
print()
greet_person("Charlie")
```

Here's what happens:
- `name` is the **parameter** - a placeholder variable in our function definition
- `"Alice"`, `"Bob"`, and `"Charlie"` are **arguments** - the actual values we pass in
- Each time we call the function, the argument gets assigned to the parameter

This solves our flexibility problem! One function can now handle many different situations.

### Multiple Parameters

Functions can accept multiple parameters to handle more complex calculations:

```python-execute
def calculate_grade(points_earned, points_possible):
    percentage = (points_earned / points_possible) * 100
    print(f"Grade: {percentage:.1f}%")

# Now we can solve our original problem with one function
calculate_grade(18, 20)    # Quiz 1
calculate_grade(23, 25)    # Quiz 2
calculate_grade(85, 100)   # Midterm exam
```

We've solved the repetitive grade calculation problem from Section 5.1. Instead of writing separate functions, we:

1. **Wrote the calculation once** in a function with parameters
2. **Called it multiple times** with different values
3. **Got different results** based on the inputs

**Important**: When calling functions with multiple parameters, order matters! The first argument goes to the first parameter, the second argument to the second parameter, and so on.

### Default Parameter Values

Sometimes you want parameters to have standard values that get used when the caller doesn't provide them. **Default parameters** make this possible:

```python-execute
def greet_person(name, greeting="Hello"):
    print(f"{greeting}, {name}!")

# Use the default greeting
greet_person("Alice")

# Provide a custom greeting
greet_person("Bob", "Hi")
greet_person("Charlie", "Good morning")
```

Default parameters make functions more convenient to use while still allowing customization when needed.

**Rule**: Parameters with default values must come after parameters without defaults in your function definition.

### Keyword Arguments

When functions have multiple parameters, you can specify which argument goes to which parameter by using the parameter names:

```python-execute
def create_profile(name, age, city, country="USA"):
    print(f"Profile: {name}, age {age}, from {city}, {country}")

# Regular way (position matters)
create_profile("Alice", 25, "Seattle")

# Using keyword arguments (order doesn't matter!)
create_profile(city="Boston", name="Bob", age=30)

# Mix of both (positional first, then keyword)
create_profile("Charlie", 28, country="Canada", city="Toronto")
```

Keyword arguments make your function calls clearer and less error-prone, especially with functions that have many parameters.

### How Python Passes Values to Functions

This is an important concept that affects how your functions behave with different types of data. Understanding this will help you avoid bugs and write more predictable code.

#### Numbers and Strings (Can't Be Changed)

When you pass numbers or strings to a function, Python creates a reference to the value, but since these types can't be modified in place, your original variables stay unchanged:

```python-execute
def try_to_change_number(x):
    print(f"Inside function, x starts as: {x}")
    x = x + 10
    print(f"Inside function, x is now: {x}")

my_number = 5
print(f"Before function: {my_number}")
try_to_change_number(my_number)
print(f"After function: {my_number}")  # Still 5!
```

#### Lists (Can Be Changed)

When you pass lists to functions, modifications inside the function affect the original list:

```python-execute
def add_to_list(items):
    print(f"Inside function, list starts as: {items}")
    items.append("new item")
    print(f"Inside function, list is now: {items}")

my_list = ["apple", "banana"]
print(f"Before function: {my_list}")
add_to_list(my_list)
print(f"After function: {my_list}")  # Modified!
```

This happens because Python passes a reference to the same list object. When you modify the list, you're changing the actual list, not creating a new one.

### The Mutable Default Parameter Trap

Here's a common mistake that surprises many beginners. Can you guess what this code will output?

```python-execute
def add_item(item, shopping_list=[]):
    shopping_list.append(item)
    return shopping_list

print("Call 1:", add_item("apples"))
print("Call 2:", add_item("bananas"))
print("Call 3:", add_item("oranges"))
```

Surprised? Each call seems to "remember" the previous items! Here's why this happens:

The empty list `[]` is created **once** when the function is defined, not each time it's called. Every function call that uses the default gets the same list object, so changes accumulate.

**Solution**: Use `None` as the default and create a new list inside the function:

```python-execute
def add_item_fixed(item, shopping_list=None):
    if shopping_list is None:
        shopping_list = []  # Create a new list each time
    shopping_list.append(item)
    return shopping_list

print("Fixed Call 1:", add_item_fixed("apples"))
print("Fixed Call 2:", add_item_fixed("bananas"))
print("Fixed Call 3:", add_item_fixed("oranges"))
```

## Getting Results Back with Return Values

Parameters let us put data into functions, but how do we get computed results back out? That's where **return values** come in.

### The Return Statement

The `return` statement sends a computed value back to whoever called the function:

```python-execute
def add_numbers(a, b):
    result = a + b
    return result

# Now we can capture and use the result
sum_value = add_numbers(5, 3)
print(f"The sum is: {sum_value}")

# We can use the result in calculations
double_sum = sum_value * 2
print(f"Double the sum: {double_sum}")
```

### Return vs Print: A Crucial Difference

This is one of the most important concepts to understand. Let's see the difference:

```python-execute
def function_that_prints(x, y):
    result = x * y
    print(result)  # Shows the result to the user

def function_that_returns(x, y):
    result = x * y
    return result  # Gives the result back to our program

# Let's see what happens when we try to use the results
print("Using the function that prints:")
value1 = function_that_prints(4, 5)  # This prints 20
print(f"Captured value: {value1}")   # This prints None!

print("\nUsing the function that returns:")
value2 = function_that_returns(4, 5)  # This returns 20
print(f"Captured value: {value2}")    # This prints 20
```

**Key insight**: `print()` displays information for humans to read, but `return` provides data that your program can use in calculations.

### When to Use Print vs Return

- **Use `return`** when your function calculates something that other parts of your program need to use
- **Use `print`** when your function's job is to display information to the user

### Multiple Return Statements

Functions can have multiple return statements, but only one will execute per function call:

```python-execute
def get_letter_grade(percentage):
    if percentage >= 90:
        return "A"
    elif percentage >= 80:
        return "B"
    elif percentage >= 70:
        return "C"
    elif percentage >= 60:
        return "D"
    else:
        return "F"

# Test with different values
print(f"95% is grade: {get_letter_grade(95)}")
print(f"78% is grade: {get_letter_grade(78)}")
print(f"45% is grade: {get_letter_grade(45)}")
```

Once a return statement executes, the function stops immediately and sends the value back.


## Practice and Assessment

```quiz
id: parameter-argument-understanding
question: In the function call `calculate_area(5, 3)`, what are the numbers 5 and 3 called?
options:
  - id: a
    text: Parameters
    correct: false
    explanation: Parameters are the variable names in the function definition. The numbers 5 and 3 are the actual values being passed.
  - id: b
    text: Arguments
    correct: true
    explanation: Correct! Arguments are the actual values you pass to a function when calling it.
  - id: c
    text: Variables
    correct: false
    explanation: While they become variables inside the function, they are specifically called arguments when passed to the function.
  - id: d
    text: Return values
    correct: false
    explanation: Return values are what the function sends back, not what you send to it.
```

```exercise
id: temperature-converter
title: Temperature Converter Function
description: "Create a function that converts Fahrenheit to Celsius and returns the result. The formula is: C = (F - 32) × 5/9"
difficulty: easy
starterCode: |
  def fahrenheit_to_celsius(fahrenheit):
      # Convert fahrenheit to celsius and return the result
      pass
prepend: |
  temp_f = float(input())
postpend: |
  result = fahrenheit_to_celsius(temp_f)
  print(f"{result:.1f}")
testCases:
  - input: "32"
    expectedOutput: "0.0"
  - input: "100"
    expectedOutput: "37.8"
    hidden: true
  - input: "68"
    expectedOutput: "20.0"
    hidden: true
hints:
  - "Use the formula: C = (F - 32) × 5/9"
  - "Remember to use the return statement"
  - "Make sure to return the calculated value, don't print it"
solution: |
  def fahrenheit_to_celsius(fahrenheit):
      celsius = (fahrenheit - 32) * 5/9
      return celsius
```

```quiz
id: return-vs-print-decision
question: When should you use return instead of print in a function?
options:
  - id: a
    text: When you need the calculated result for use in other parts of your program
    correct: true
    explanation: Exactly! Return provides data that can be stored, used in calculations, or passed to other functions.
  - id: b
    text: When you want to display information to the user
    correct: false
    explanation: That's when you use print, not return.
  - id: c
    text: When the function is longer than 5 lines
    correct: false
    explanation: The length of the function doesn't determine whether to use print or return.
  - id: d
    text: Return and print do the same thing
    correct: false
    explanation: Return and print serve completely different purposes in programming.
```

## Key Takeaways

- **Parameters** make functions flexible by allowing them to work with different input values
- **Arguments** are the actual values you pass to parameters when calling functions
- **Default parameters** provide convenient fallback values for optional inputs
- **Keyword arguments** let you specify parameters by name for clearer, less error-prone function calls
- **Return statements** send calculated results back for use elsewhere in your program
- **Print vs Return**: Use print to show information to users, use return to provide data for calculations
- **Python passes references** to objects, which matters for mutable types like lists
- **Mutable default parameters** can cause unexpected behavior - use the `None` pattern to avoid this trap

Parameters and return values enable functions to accept input and provide output, making them suitable for solving computational problems. Section 5.4 introduces higher-order functions and lambda expressions for advanced function manipulation.
# Parameters and Return Values

## Learning Objectives
- Design functions that accept input through parameters
- Understand how to pass data to functions when calling them
- Use return statements to send results back from functions
- Distinguish between printing output and returning values
- Create function signatures that clearly define input and output
- Work with default parameter values for more flexible functions
- Understand how functions interact with different data types

## From Fixed to Flexible: The Need for Input

In Section 5.2, we learned to create functions that eliminate code repetition and organize our programs. But all our functions had a significant limitation: they did exactly the same thing every time.

Think back to the repetitive code problems from Section 5.1:
- The grade calculation that worked with different point values
- The rectangle area calculation that worked with different dimensions

Our current functions can't solve these problems because they can't accept **input**. We need a way to pass different values to our functions each time we call them.

This is where **parameters** transform functions from simple code organizers into flexible, powerful tools.

## The Power of Input: Function Parameters

**Parameters** are variables that allow functions to accept input when they're called. Think of them as placeholder variables that receive values from the outside world.

Let's see this in action by solving the greeting problem:

```python-execute
def greet_person(name):
    print(f"Hello, {name}!")
    print(f"Nice to meet you, {name}!")

# Call the function with different values
greet_person("Alice")
greet_person("Bob") 
greet_person("Charlie")
```

Look at what happened! The same function produced different output each time because we passed it different input values. Here's how it works:

1. **Parameter**: `name` is the parameter - a placeholder variable in the function definition
2. **Arguments**: `"Alice"`, `"Bob"`, and `"Charlie"` are arguments - the actual values we pass when calling the function
3. **Substitution**: Each time we call the function, the argument value gets assigned to the parameter variable

This solves our flexibility problem! One function can now handle many different situations.

```note title="Terminology: Parameters vs Arguments"
- **Parameter**: The variable identifier in the function definition that serves as a placeholder
- **Argument**: The actual value passed to the function during invocation that gets bound to the parameter
```

## Multiple Parameters: Solving Complex Problems

Functions become even more powerful when they can accept multiple pieces of input. Let's solve the rectangle area problem from Section 5.1:

```python-execute
def calculate_rectangle_area(length, width):
    area = length * width
    print(f"A rectangle with length {length} and width {width} has area {area}")

# Call with different values
calculate_rectangle_area(5, 3)
calculate_rectangle_area(10, 7)
calculate_rectangle_area(2.5, 4.2)
```

Perfect! We've solved the repetitive rectangle calculation problem from Section 5.1. Instead of copying the same calculation logic three times, we:

1. **Wrote the calculation once** in a function with two parameters: `length` and `width`
2. **Called it three times** with different argument values
3. **Got different results** each time based on the inputs

**Important**: When calling functions with multiple parameters, the order matters! The first argument (`5`) goes to the first parameter (`length`), the second argument (`3`) goes to the second parameter (`width`), and so on.

## Returning Values: Getting Results Back

Printing information is useful, but often you want a function to **return** a result that you can use in other parts of your program. The `return` statement sends a value back to wherever the function was called:

```python-execute
def add_numbers(a, b):
    result = a + b
    return result

# Now we can capture and use the returned value
sum1 = add_numbers(5, 3)
sum2 = add_numbers(10, 7)

print(f"First sum: {sum1}")
print(f"Second sum: {sum2}")
print(f"Total of both sums: {sum1 + sum2}")
```

The key difference: `print()` displays information to the user, while `return` sends data back to your program for further use.

## Return vs Print: A Critical Distinction

This is one of the most important concepts to understand:

```python-execute
def function_that_prints(x, y):
    result = x * y
    print(result)  # This shows the result to the user

def function_that_returns(x, y):
    result = x * y
    return result  # This sends the result back to be used

# Try to use the results
print("Using function that prints:")
value1 = function_that_prints(4, 5)  # This prints 20
print(f"Captured value: {value1}")   # This prints None!

print("\nUsing function that returns:")
value2 = function_that_returns(4, 5)  # This returns 20
print(f"Captured value: {value2}")    # This prints 20
```

```note title="Side Effects vs Return Values"
Functions that produce output via `print()` create **side effects** but don't provide values for further computation. Functions that return values enable **functional composition** - the output of one function becomes the input to another. For computational reusability, prefer return values over side effects.
```

```quiz
id: return-vs-print-concept
question: Which statement correctly explains when to use return vs print in functions?
options:
  - id: a
    text: Use return to display results to the user, use print for calculations
    correct: false
    explanation: This is backwards. Print displays to users, return provides values for calculations.
  - id: b
    text: Use print to display results to the user, use return when you need to use the result in other parts of your program
    correct: true
    explanation: Exactly right! Print is for user output, return is for program data flow.
  - id: c
    text: Print and return do exactly the same thing
    correct: false
    explanation: Print and return serve very different purposes in functions.
  - id: d
    text: You should always use both print and return in every function
    correct: false
    explanation: Functions should either print (for user output) or return (for data), but not necessarily both.
```

## Practical Examples: Real Problems Solved

Let's solve the grade calculation problem from Section 5.1 properly using parameters and return values:

```python-execute
def calculate_percentage(points_earned, points_possible):
    percentage = (points_earned / points_possible) * 100
    return percentage

# Now we can use this function for all our grade calculations
quiz1_grade = calculate_percentage(18, 20)
quiz2_grade = calculate_percentage(23, 25) 
midterm_grade = calculate_percentage(85, 100)

print(f"Quiz 1: {quiz1_grade:.1f}%")
print(f"Quiz 2: {quiz2_grade:.1f}%")
print(f"Midterm: {midterm_grade:.1f}%")

# We can even calculate an average using the returned values
average_grade = (quiz1_grade + quiz2_grade + midterm_grade) / 3
print(f"Average so far: {average_grade:.1f}%")
```

This is much more powerful than our original repetitive code!

## Building Calculation Functions

Let's create functions for common math operations:

```python-execute
def calculate_compound_interest(principal, rate, time):
    # A = P(1 + r)^t
    amount = principal * (1 + rate) ** time
    return amount

def calculate_distance(x1, y1, x2, y2):
    # Distance formula: sqrt((x2-x1)^2 + (y2-y1)^2)
    distance = ((x2 - x1)**2 + (y2 - y1)**2) ** 0.5
    return distance

# Use these functions in calculations
investment = calculate_compound_interest(1000, 0.05, 10)
print(f"$1000 invested at 5% for 10 years becomes: ${investment:.2f}")

distance = calculate_distance(0, 0, 3, 4)
print(f"Distance from origin to (3,4): {distance}")
```

## Function Signatures: The Contract

A function's **signature** is its name plus its parameters. It defines what input the function expects:

```python-execute
# Signature: convert_temperature(fahrenheit)
def convert_temperature(fahrenheit):
    celsius = (fahrenheit - 32) * 5/9
    return celsius

# Signature: calculate_tip(bill_amount, tip_percentage)  
def calculate_tip(bill_amount, tip_percentage):
    tip = bill_amount * (tip_percentage / 100)
    return tip

# Using functions with clear signatures
temp_celsius = convert_temperature(98.6)
print(f"98.6°F is {temp_celsius:.1f}°C")

tip_amount = calculate_tip(50.00, 18)
print(f"18% tip on $50.00 is ${tip_amount:.2f}")
```

When you see a function signature, you immediately know what arguments to provide.

## Early Returns and Multiple Return Points

Functions can have multiple return statements, though only one will execute per function call:

```python-execute
def get_letter_grade(percentage):
    if percentage >= 90:
        return "A"
    elif percentage >= 80:
        return "B"
    elif percentage >= 70:
        return "C" 
    elif percentage >= 60:
        return "D"
    else:
        return "F"

# Test with different values
print(f"95% is a {get_letter_grade(95)}")
print(f"78% is a {get_letter_grade(78)}")
print(f"45% is a {get_letter_grade(45)}")
```

Once a return statement executes, the function immediately stops and sends the value back.

## Practice: Parameters and Returns

```quiz
id: parameter-vs-argument
question: In the function call `calculate_area(5, 3)`, what are 5 and 3 called?
options:
  - id: a
    text: Parameters
    correct: false
    explanation: Parameters are the variable names in the function definition. The actual values passed are arguments.
  - id: b
    text: Arguments
    correct: true
    explanation: Correct! Arguments are the actual values you pass to a function when calling it.
  - id: c
    text: Variables
    correct: false
    explanation: While arguments become variables inside the function, they're specifically called arguments when passed during the function call.
  - id: d
    text: Return values
    correct: false
    explanation: Return values are what the function sends back, not what you send to it.
```

```exercise
id: area-calculator-function
title: Rectangle Area Function
description: Create a function that takes `length` and `width` as parameters and returns the area of a rectangle. Focus only on writing the function - the testing system will automatically handle reading inputs and calling your function.
difficulty: easy
starterCode: |
  def calculate_area(length, width):
      # Calculate and return the area
      pass
prepend: |
  length = float(input())
  width = float(input())
postpend: |
  print(calculate_area(length, width))
testCases:
  - input: "5\n3"
    expectedOutput: "15.0"
  - input: "10\n7"
    expectedOutput: "70.0"
  - input: "2.5\n4"
    expectedOutput: "10.0"
  - input: "1\n1"
    expectedOutput: "1.0"
    hidden: true
  - input: "0\n5"
    expectedOutput: "0.0"
    hidden: true
  - input: "12\n8"
    expectedOutput: "96.0"
    hidden: true
  - input: "3.5\n2.5"
    expectedOutput: "8.75"
    hidden: true
  - input: "100\n50"
    expectedOutput: "5000.0"
    hidden: true
  - input: "0.1\n0.2"
    expectedOutput: "0.02"
    hidden: true
  - input: "15\n4"
    expectedOutput: "60.0"
    hidden: true
  - input: "6.25\n8"
    expectedOutput: "50.0"
    hidden: true
  - input: "20\n25"
    expectedOutput: "500.0"
    hidden: true
  - input: "0.5\n0.5"
    expectedOutput: "0.25"
    hidden: true
hints:
  - "Area of rectangle = length × width"
  - "Use the return statement to send the result back"
  - "You only need to write the function logic - no input() or print() needed"
solution: |
  def calculate_area(length, width):
      return length * width
```

## Default Parameter Values: Making Functions More Flexible

Sometimes you want a parameter to have a standard value that gets used if the caller doesn't provide one. **Default parameters** solve this problem by specifying fallback values.

```python-execute
def greet_person(name, greeting="Hello"):
    print(f"{greeting}, {name}!")

# Call with just the name (uses default greeting)
greet_person("Alice")

# Call with both name and custom greeting
greet_person("Bob", "Hi")
greet_person("Charlie", "Good morning")
```

Here's how default parameters work:

1. **`greeting="Hello"`** sets "Hello" as the default value for the `greeting` parameter
2. **If you provide both arguments**, the function uses your custom greeting
3. **If you provide only the name**, the function automatically uses "Hello" for the greeting

This makes functions more convenient to use while still allowing customization when needed.

```python-execute
def calculate_interest(principal, rate, years, compound_frequency=1):
    """Calculate compound interest with optional compounding frequency."""
    amount = principal * (1 + rate/compound_frequency) ** (compound_frequency * years)
    return amount

# Simple annual compounding (uses default)
simple_interest = calculate_interest(1000, 0.05, 10)
print(f"Annual compounding: ${simple_interest:.2f}")

# Quarterly compounding (custom frequency)  
quarterly_interest = calculate_interest(1000, 0.05, 10, 4)
print(f"Quarterly compounding: ${quarterly_interest:.2f}")
```

```warning title="Parameter Ordering Constraint"
Python syntax requires positional parameters to precede default parameters in function definitions:

- **❌ Invalid**: `def func(x=5, y):` - default parameter comes before positional parameter
- **✅ Valid**: `def func(y, x=5)` - positional parameter comes before default parameter
- **Rule**: All parameters without defaults must be declared before any parameter with defaults
```

## Keyword Arguments: Calling Functions by Name

When functions have multiple parameters, you can specify which argument goes to which parameter by using the parameter names:

```python-execute
def create_user_profile(name, age, city, country="USA"):
    print(f"Profile: {name}, age {age}, from {city}, {country}")

# Positional arguments (order matters)
create_user_profile("Alice", 25, "Seattle")

# Keyword arguments (order doesn't matter)
create_user_profile(city="Boston", name="Bob", age=30)

# Mix of both (positional first, then keyword)
create_user_profile("Charlie", 28, country="Canada", city="Toronto")
```

Keyword arguments make your function calls more readable and less error-prone, especially with functions that have many parameters.

## Building Complex Functions

Functions can perform multi-step calculations:

```python-execute
def calculate_monthly_payment(loan_amount, annual_rate, years):
    # Convert annual rate to monthly rate
    monthly_rate = annual_rate / 12 / 100
    
    # Convert years to months
    num_payments = years * 12
    
    # Monthly payment formula
    if monthly_rate == 0:  # Handle case of 0% interest
        payment = loan_amount / num_payments
    else:
        payment = loan_amount * (monthly_rate * (1 + monthly_rate)**num_payments) / ((1 + monthly_rate)**num_payments - 1)
    
    return payment

# Calculate car loan payment
monthly_payment = calculate_monthly_payment(25000, 4.5, 5)
print(f"Monthly payment: ${monthly_payment:.2f}")
```

## Functions Working Together

Functions can use other functions' return values:

```python-execute
def celsius_to_fahrenheit(celsius):
    fahrenheit = celsius * 9/5 + 32
    return fahrenheit

def fahrenheit_to_celsius(fahrenheit):
    celsius = (fahrenheit - 32) * 5/9
    return celsius

def get_temperature_description(celsius):
    if celsius <= 0:
        return "Freezing"
    elif celsius <= 10:
        return "Cold"
    elif celsius <= 20:
        return "Cool"
    elif celsius <= 30:
        return "Warm"
    else:
        return "Hot"

# Chain functions together
temp_f = 75
temp_c = fahrenheit_to_celsius(temp_f)
description = get_temperature_description(temp_c)

print(f"{temp_f}°F is {temp_c:.1f}°C, which is {description}")
```

## How Arguments are Passed to Functions

This is a crucial concept that often confuses beginners. Understanding how Python passes arguments to functions helps you predict and control function behavior with different object types.

### Numbers and Strings (Immutable Types)

When you pass numbers or strings as arguments, Python passes a **reference** to the object. However, since these types are **immutable** (cannot be changed in-place), operations like `x = x + 10` create a new object rather than modifying the original. The original object remains unchanged:

```python-execute
def try_to_change_number(x):
    print(f"Inside function, x starts as: {x}")
    x = x + 10
    print(f"Inside function, x is now: {x}")

def try_to_change_string(text):
    print(f"Inside function, text starts as: {text}")
    text = text + " modified"
    print(f"Inside function, text is now: {text}")

# Test with a number
my_number = 5
print(f"Before function call: {my_number}")
try_to_change_number(my_number)
print(f"After function call: {my_number}")  # Still 5!

print()  # Blank line

# Test with a string  
my_text = "Hello"
print(f"Before function call: {my_text}")
try_to_change_string(my_text)
print(f"After function call: {my_text}")  # Still "Hello"!
```

### Lists (Mutable Types)

When you pass lists to functions, Python passes a **reference** to the same list object. Since lists are **mutable** (can be changed), modifications inside the function affect the original list:

```python-execute
def try_to_change_list(items):
    print(f"Inside function, items starts as: {items}")
    items.append("new item")
    print(f"Inside function, items is now: {items}")

def create_new_list(items):
    print(f"Inside function, items starts as: {items}")
    items = ["completely", "new", "list"]  # This creates a new list
    print(f"Inside function, items is now: {items}")

# Test with list modification
my_list = ["apple", "banana"]
print(f"Before function call: {my_list}")
try_to_change_list(my_list)
print(f"After function call: {my_list}")  # Modified!

print()  # Blank line

# Test with list reassignment
my_list2 = ["red", "blue"]
print(f"Before function call: {my_list2}")
create_new_list(my_list2)
print(f"After function call: {my_list2}")  # Unchanged!
```

```warning title="Mutability and Reference Semantics"
Python passes object references to functions. For mutable objects (lists, dictionaries), **in-place modifications** affect the original object. **Reference reassignment** within the function creates a new local binding without affecting the original object. Understanding this distinction is crucial for predicting function behavior.
```

This behavior explains why some functions seem to "change" their inputs while others don't. Understanding this will help you avoid bugs and design functions that behave as expected.

## A Surprising Example: Default Arguments

Here's a function that seems simple but produces unexpected behavior. Run this code and observe the output:

```python-execute
def add_item(item, shopping_list=[]):
    shopping_list.append(item)
    return shopping_list

print("Call 1:", add_item("apples"))
print("Call 2:", add_item("bananas")) 
print("Call 3:", add_item("oranges"))
```

Did you expect that result? Each call seems to "remember" the previous items! Now that you've seen this strange behavior, can you explain why it happens?

```quiz
id: mutable-default-argument-explanation
question: "Why does the function above produce this unexpected behavior where items accumulate across different function calls?"

options:
  - id: a
    text: "Python has a bug in how it handles default arguments"
    correct: false
    explanation: This is not a bug - it's the intended behavior based on how Python evaluates default arguments.
  - id: b
    text: "The empty list [] is created once when the function is defined, and the same list object is reused for all calls"
    correct: true
    explanation: Exactly! Default arguments are evaluated only once at function definition time, so all calls share the same list object.
  - id: c
    text: "The append() method doesn't work properly inside functions"
    correct: false
    explanation: The append() method works correctly - it modifies the list as expected.
  - id: d
    text: "Variables inside functions automatically become global"
    correct: false
    explanation: This isn't related to variable scope - it's about object references and when default arguments are created.
```

### The Mutable Default Argument Trap

This surprising behavior occurs because of how Python handles default arguments and object references:

**What Actually Happens:**
1. **Single Object Creation**: The empty list `[]` is created **once** when the function is defined, not each time it's called
2. **Same Reference Reused**: Every function call that uses the default gets a reference to the **same list object**
3. **Persistent Modifications**: Each `append()` operation modifies this shared list, so changes accumulate across calls

This demonstrates the key principle: **Python passes references to objects, and mutable objects can be modified through those references**.

```python-execute
def add_item_fixed(item, shopping_list=None):
    if shopping_list is None:
        shopping_list = []  # Create new list each time
    shopping_list.append(item)
    return shopping_list

print("Fixed Call 1:", add_item_fixed("apples"))
print("Fixed Call 2:", add_item_fixed("bananas")) 
print("Fixed Call 3:", add_item_fixed("oranges"))
```

**The Fix**: Use `None` as the default and create a new list inside the function when needed. This ensures each call gets its own fresh list.

## Key Takeaways

- **Parameters** make functions flexible by accepting input
- **Arguments** are the actual values you pass to parameters
- **Return statements** send results back to be used elsewhere
- **Print vs Return**: Print shows information to users; return provides data for your program
- **Function signatures** define what input a function expects
- **Returned values** can be stored, used in calculations, or passed to other functions
- **Multiple returns** are possible, but only one executes per function call
- **Default arguments** are evaluated once at function definition time
- **Mutable defaults** can cause unexpected behavior - use `None` pattern instead

## What's Coming Next: Functions as Flexible Tools

You now understand how to create flexible, reusable functions that can:
- Accept different inputs through parameters
- Provide sensible defaults for optional parameters  
- Return calculated results for use elsewhere in your program
- Handle different data types appropriately

But Python's function system has even more power to offer. In the next section, we'll discover that functions themselves can be treated as **values** - you can store them in variables, pass them to other functions, and create them on-the-fly with lambda expressions.

This might sound abstract now, but these advanced concepts will unlock powerful programming patterns that make complex problems much easier to solve. You'll learn techniques that professional programmers use every day to write flexible, maintainable code.
# Python Programming Fundamentals

In the previous section, you learned to think algorithmically and understand algorithms through three faces: logic, expression, and performance. You saw how the contact search problem can be expressed in natural language, then formalized in pseudocode. This section completes that progression by introducing Python—the programming language that transforms algorithmic thinking into executable computer instructions.

## From Algorithms to Programming Language

### Bridging Algorithmic Thinking and Code

Recall the contact search algorithm from section 1.1, where we expressed the logical approach in pseudocode:

```
ALGORITHM: Sequential Contact Search
INPUT: contacts, target_name
OUTPUT: contact_info or NOT_FOUND

BEGIN
  FOR each contact in contacts:
    IF contact.name = target_name:
      RETURN contact
    END IF
  END FOR

  RETURN NOT_FOUND
END
```

This pseudocode represents the algorithmic logic clearly but cannot execute on a computer. Python provides the syntax to transform this abstract specification into concrete, executable instructions. While we will implement the complete contact search algorithm in later sections after learning loops and conditionals, we can begin with the fundamental building blocks that make such implementation possible.

### Python as an Implementation Language

Python serves as an optimal choice for algorithmic implementation due to several characteristics that align with clear thinking:

```note title="Python Design Principles"
- Syntax resembles natural language structure
- Minimal punctuation reduces visual complexity
- Clear operation semantics match algorithmic thinking
- Immediate execution provides rapid feedback
```

The language design philosophy emphasizes readability and simplicity, allowing focus on algorithmic concepts rather than syntactic details. Programming concepts transfer across languages; Python provides accessible vocabulary for expressing computational ideas.

### Your First Python Instructions

Every programming language provides mechanisms for producing output—displaying results, communicating with users, and verifying correct operation. Python accomplishes this through the `print()` function:

```python-execute
print("Hello, World!")
```

This instruction directs Python to display the text "Hello, World!" on the screen. The `print()` function represents your primary tool for communicating computational results and verifying program behavior.

### Building Systematic Instructions

Just as algorithms consist of sequential steps, Python programs execute instructions in order from top to bottom. Multiple `print()` statements demonstrate this sequential processing:

```python-execute
print("Step 1: Initialize program")
print("Step 2: Process data")
print("Step 3: Generate results")
print("Step 4: Complete operation")
```

Each instruction executes completely before Python proceeds to the next line. This deterministic behavior ensures that your algorithmic logic translates into predictable program execution.

## Programming Building Blocks

Algorithms require precise expression of data and operations. Python provides fundamental building blocks—data types, variables, operations, and input/output mechanisms—that serve as vocabulary for implementing algorithmic solutions. Understanding these elements enables translation of algorithmic thinking into executable code.

### Data Types: Classifying Information

Python organizes information into different types. Each type determines what operations you can perform with that data. The three most important types are strings (text), integers (whole numbers), and floats (decimal numbers).

**String Literals: Textual Information**

Strings represent text enclosed in quotation marks. Python recognizes anything inside quotes as text, regardless of what it contains:

```python-execute
print("Sarah Johnson")
print("Search complete")
print("Target not found")
print("Contact list has 1000 entries")
```

Notice that the last string contains numbers, but because it's in quotes, Python treats the entire thing as text, not mathematics.

Python treats uppercase and lowercase letters as completely different:

```python-execute
print("Sarah")
print("sarah")
print("Are these the same? Let's see...")
print("Sarah" == "sarah")
```

Python can also compare strings alphabetically, which is essential for search and sorting algorithms:

```python-execute
print("Alphabetical comparison:")
print("Alice" < "Bob")
print("Bob" < "Charlie")
print("Alice" < "Charlie")
print("All comparisons return True - they're in alphabetical order!")
```

**Integer Literals: Whole Numbers**

Integers represent whole numbers without decimal points. Notice they have no quotation marks—this tells Python to treat them as numbers for mathematical operations:

```python-execute
print(42)
print(-17)
print(1000)
print(0)
```

Integers work exactly as you expect from mathematics. Python can perform all standard arithmetic operations and give precise answers:

```python-execute
print("Addition:", 1000 + 500)
print("Subtraction:", 1000 - 500)
print("Multiplication:", 25 * 4)
print("Integer division:", 100 // 4)
print("Remainder:", 17 % 5)
print("Exponentiation:", 2 ** 8)
```

Notice the different division operators: `//` gives you whole number division (no decimals), while `%` gives you the remainder after division.

The key difference between integers and strings becomes clear when we compare:

```python-execute
print("String addition:", "5" + "3")
print("Integer addition:", 5 + 3)
print("Notice the different results!")
```

**Float Literals: Decimal Numbers**

Floats represent numbers with decimal points. Like integers, they have no quotation marks, so Python treats them as numbers for mathematical operations:

```python-execute
print(3.14159)
print(-2.5)
print(0.0)
print(95.7)
```

Floats handle all mathematical operations, including regular division that produces decimal results:

```python-execute
print("Decimal addition:", 3.5 + 2.1)
print("Decimal subtraction:", 10.7 - 3.2)
print("Decimal multiplication:", 2.5 * 4.0)
print("Regular division:", 15 / 4)
print("Float exponentiation:", 2.5 ** 2)
print("Percentage calculation:", 95.7 / 100)
```

The key difference: regular division `/` always produces decimal results, while integer division `//` produces whole numbers only.

Sometimes float calculations show tiny differences due to computer representation, but this rarely affects practical work:

```python-execute
print("Simple calculation:")
print(0.1 + 0.2)
print("Expected 0.3, but got a very close approximation")
```

```note title="Type Selection Guidelines"
- Use **strings** for text like names, messages, and labels
- Use **integers** for whole numbers like counts and positions
- Use **floats** for decimal numbers like measurements and percentages
```

```quiz
id: string-vs-number
question: "What result does print('5' + '3') produce?"
options:
  - id: a
    text: "8"
    correct: false
    explanation: This would result from mathematical addition, but quotes indicate strings.
  - id: b
    text: "53"
    correct: true
    explanation: Correct. String concatenation joins '5' and '3' to produce '53'.
  - id: c
    text: "An error message"
    correct: false
    explanation: Python successfully concatenates strings using the + operator.
  - id: d
    text: "5.3"
    correct: false
    explanation: String concatenation does not create decimal numbers.
```


### Variables: Named Storage for Data

Variables allow you to store data and give it a name so you can use it later. Think of a variable as a labeled box that holds information.

**Variable Assignment Syntax**

The assignment operator `=` stores values in variables. This enables us to save data and use it later in our programs:

```python-execute
# Storing different types of data
contact_name = "Sarah Johnson"
list_size = 1000
search_time = 0.003
found = True

print(f"Contact: {contact_name}")
print(f"List size: {list_size}")
print(f"Search time: {search_time} seconds")
print(f"Found: {found}")
```

```note title="Assignment Operator"
The `=` operator stores a value in a variable. Don't confuse this with mathematics—in Python, `=` means "store this value" not "equals."
```

### Variable Naming Rules

Python has rules for variable names, and following good naming practices makes programs easier to understand:

**Naming Requirements:**
- Begin with letter or underscore
- Contain only alphanumeric characters and underscores
- Avoid Python reserved words
- Use descriptive names that explain what the variable stores

```python-execute
# Good variable names
student_name = "Alex"
test_score = 95
is_passing = True

# Poor variable names (but still legal)
x = "Alex"
n = 95
b = True

print("Clear names make code easier to understand")
```

```quiz
id: variable-naming
question: "Which is a valid Python variable name?"
options:
  - id: a
    text: "2_cats"
    correct: false
    explanation: "Variable names cannot start with a number."
  - id: b
    text: "my-age"
    correct: false
    explanation: "Variable names cannot contain dashes. Use underscores instead."
  - id: c
    text: "student_grade"
    correct: true
    explanation: "Correct. This follows all the rules: starts with a letter, uses underscores, and is descriptive."
  - id: d
    text: "first name"
    correct: false
    explanation: "Variable names cannot contain spaces."
```

### Displaying Variables with F-Strings

You've already seen f-strings in our examples above. F-strings provide a clean way to include variable values inside text:

```python-execute
# Simple f-string examples
name = "Sarah"
age = 17
score = 95.7

print(f"Student: {name}")
print(f"Age: {age}")
print(f"Score: {score}")
print(f"{name} is {age} years old and scored {score}%")
```

F-strings work by putting an `f` before the quotes and using `{}` around variable names. Python automatically replaces `{name}` with the value stored in the `name` variable.

### Interactive Data Collection

Algorithms often require external input for processing. Python's `input()` function enables data collection during program execution:

```python-execute
print("Algorithm Parameter Input")
print("Enter target contact name:")
user_target = input()
print(f"Searching for: {user_target}")

print("Enter maximum search time (seconds):")
max_time = float(input())
print(f"Maximum search time: {max_time:.2f} seconds")
```

```note title="Input Type Conversion"
The `input()` function returns string data. Use `int()` or `float()` for numeric conversion when implementing mathematical algorithms.
```

Interactive input enables dynamic algorithmic execution with user-specified parameters, transforming static procedures into flexible computational tools.

```quiz
id: f-string-practice
question: "Which f-string correctly displays 'Hello, Sarah! You are 17 years old.' given `name='Sarah'` and `age=17`?"
options:
  - id: a
    text: "`print('Hello, {name}! You are {age} years old.')`"
    correct: false
    explanation: Missing the 'f' before the string - this won't substitute the variables.
  - id: b
    text: "`print(f'Hello, {name}! You are {age} years old.')`"
    correct: true
    explanation: Perfect! The 'f' before the string tells Python to substitute variables inside {}.
  - id: c
    text: "`print(f'Hello, name! You are age years old.')`"
    correct: false
    explanation: Variables need to be inside {} brackets to be substituted.
  - id: d
    text: "`print(f'Hello, [name]! You are [age] years old.')`"
    correct: false
    explanation: F-strings use {} brackets, not [] brackets for variables.
```


## Summary

You now have the essential building blocks for Python programming:

**Programming Vocabulary You've Learned:**
- **Variables:** Store and name your data
- **Data types:** Strings for text, integers for whole numbers, floats for decimals
- **Mathematical operations:** Addition, subtraction, multiplication, division
- **Input and output:** Get data from users with `input()`, show results with `print()`
- **F-strings:** Display variables inside text clearly

**Examples of Each Building Block:**
```python
# Variables and types
name = "Sarah"           # String
age = 17                # Integer
score = 95.7            # Float

# Math operations
total = 100 + 50        # Addition
result = total * 0.85   # Multiplication

# Input and output
user_input = input()    # Get data
print(f"Hello {name}")  # Show results
```

**What's Next:**
Now that you have the programming vocabulary, the next section shows how to combine these building blocks into complete programs that implement algorithms. You'll learn to translate the step-by-step thinking from section 1.1 into step-by-step code.
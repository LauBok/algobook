# Converting Algorithmic Ideas into Code

The previous sections established the foundation for computational problem-solving: systematic algorithmic reasoning and Python's basic programming constructs. This section demonstrates how to apply Python's vocabulary to implement the step-by-step solutions developed through algorithmic analysis. Since Python executes instructions sequentially, each step in an algorithmic solution corresponds directly to executable code statements, creating a natural translation process from logical reasoning to program implementation.

**Learning Objectives:**
- Translate algorithmic steps into lines of code
- Organize programs using the input-process-output pattern
- Implement complete sequential algorithms
- Connect algorithmic thinking to programming implementation

## From Algorithmic Steps to Code Lines

Recall the contact search example from section 1.1. We expressed it as a step-by-step algorithm:

> **ALGORITHM: Sequential Contact Search**
> 1. Start at the first contact in the list
> 2. Compare current contact with target name
> 3. If match found, return contact information
> 4. If no match, move to next contact
> 5. Repeat until target found or list exhausted

This algorithm requires two programming structures we haven't learned yet: **branching** (making decisions with "if") and **looping** (repeating steps). These will be covered in the next two sections. For now, we'll focus on **sequential** algorithms that execute one step at a time without decisions or repetition.

```note title="Three Types of Program Structure"
- **Sequential:** Execute instructions one after another, top to bottom
- **Branching:** Make decisions and choose different paths (if/else statements)
- **Looping:** Repeat instructions multiple times (for/while loops)
```

Let's see how sequential algorithms translate to code using temperature conversion:

**Algorithmic Steps for Temperature Conversion:**
1. Get temperature in Fahrenheit from user
2. Apply conversion formula: $C = (F - 32) \times \frac{5}{9}$
3. Display the result

**Converting Steps to Code:**

```python-execute
# Step 1: Get temperature from user
print("Enter temperature in Fahrenheit:")
fahrenheit = float(input())

# Step 2: Apply conversion formula
celsius = (fahrenheit - 32) * 5 / 9

# Step 3: Display the result
print(f"{fahrenheit}°F = {celsius:.1f}°C")
```

Notice how each algorithmic step translates directly into code. This is the fundamental process of programming: converting step-by-step thinking into step-by-step execution.


## The Input-Process-Output Pattern

Every algorithm and every program follows the same fundamental pattern:
1. **Input:** Get the data you need
2. **Process:** Transform the data using calculations or operations
3. **Output:** Show the results

This pattern comes directly from algorithmic thinking. Remember the contact search from section 1.1:
- **Input:** Contact list and target name
- **Process:** Compare each contact with target
- **Output:** Contact information or "not found"

Python programs work the same way, executing one line at a time. Let's see this pattern in action:

### Example: Circle Area Calculator

**Algorithmic Steps:**
1. Get radius from user (Input)
2. Calculate area using $A = \pi r^2$ (Process)
3. Display the result (Output)

**Implementation:**

```python-execute
# Circle Area Calculator
print("=== Circle Area Calculator ===")

# INPUT: Get the radius
print("Enter the radius of the circle:")
radius = float(input())

# PROCESS: Calculate area using formula A = π × r²
pi = 3.14159
area = pi * radius * radius

# OUTPUT: Display the result
print(f"A circle with radius {radius} has area {area:.2f}")
```

### Example: Distance Between Two Points

**Algorithmic Steps:**
1. Get coordinates of two points (Input)
2. Apply distance formula: $d = \sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$ (Process)
3. Display the distance (Output)

**Implementation:**

```python-execute
# Distance Calculator
print("=== Distance Between Two Points ===")

# INPUT: Get coordinates for both points
print("Enter first point coordinates:")
x1 = float(input("x1: "))
y1 = float(input("y1: "))

print("Enter second point coordinates:")
x2 = float(input("x2: "))
y2 = float(input("y2: "))

# PROCESS: Apply distance formula
dx = x2 - x1
dy = y2 - y1
distance = (dx * dx + dy * dy) ** 0.5

# OUTPUT: Display the result
print(f"Distance between ({x1}, {y1}) and ({x2}, {y2}) is {distance:.2f}")
```

Notice how each program follows the same pattern: gather input, process the data step by step, then output the results. This mirrors exactly how you think through problems algorithmically.

### Example: Interest Calculator

Let's see how to implement a complete sequential algorithm:

**Algorithmic Steps:**
1. Get principal amount, interest rate, and time period (Input)
2. Calculate simple interest: $Interest = \frac{Principal \times Rate \times Time}{100}$ (Process)
3. Calculate total amount and display results (Output)

**Implementation:**

```python-execute
# Simple Interest Calculator
print("=== Simple Interest Calculator ===")

# INPUT: Get financial information
print("Enter your initial savings amount:")
principal = float(input())

print("Enter the annual interest rate (as percentage, e.g., 5 for 5%):")
rate = float(input())

print("Enter the number of years:")
time = float(input())

# PROCESS: Calculate interest and total
interest = (principal * rate * time) / 100
total = principal + interest

# OUTPUT: Display results
print(f"\nInitial amount: ${principal:.2f}")
print(f"Interest earned: ${interest:.2f}")
print(f"Total after {time} years: ${total:.2f}")
```

## Practice: Sequential Algorithm Implementation

Now apply the input-process-output pattern to complete this sequential algorithm:

### Rectangle Calculator

**Your Turn:** Complete this program following the input-process-output pattern:

```python-execute
# Rectangle Area and Perimeter Calculator
print("=== Rectangle Calculator ===")

# INPUT: Get dimensions
print("Enter the length:")
length = float(input())

print("Enter the width:")
width = float(input())

# PROCESS: Calculate area and perimeter
# Area = length × width
# Perimeter = 2 × (length + width)
# Add your calculations here:


# OUTPUT: Display results
# Add your output statements here:

```

```quiz
id: sequential-programming
question: "What makes a program 'sequential'?"
options:
  - id: a
    text: It uses loops to repeat instructions
    correct: false
    explanation: Sequential programs execute each line once, in order, without loops.
  - id: b
    text: It executes instructions one line at a time, from top to bottom
    correct: true
    explanation: Correct! Sequential execution means following instructions in order without jumping around.
  - id: c
    text: It makes decisions using if-else statements
    correct: false
    explanation: Sequential programs don't make decisions - they follow every instruction in order.
  - id: d
    text: It can only work with numbers
    correct: false
    explanation: Sequential programs can work with any data type, not just numbers.
```

### Testing Your Programs

Always test your programs with values you can verify:

**For Temperature Conversion:**
- 32°F should give 0°C (freezing point)
- 212°F should give 100°C (boiling point)

**For Circle Area:**
- Radius 1 should give area ≈ 3.14
- Radius 2 should give area ≈ 12.57

**For Distance:**
- Points (0,0) and (3,4) should give distance 5
- Points (0,0) and (0,5) should give distance 5

```note title="Error Awareness"
If your program gives unexpected results, check:
- Did you convert input to the right type (`int()` or `float()`)?
- Are your formulas correct (check parentheses)?
- Are you using the right operators (`**` for power, not `^`)?
```

### Understanding Errors

As you write programs, you'll encounter three types of errors:

**Syntax Errors** - Python can't understand your code:
```python
print("Hello World"  # Missing closing parenthesis
```

**Runtime Errors** - Your program crashes while running:
```python
result = 10 / 0  # Can't divide by zero
```

**Logic Errors** - Your program runs but gives wrong results:
```python
celsius = fahrenheit - 32 * 5 / 9  # Missing parentheses in formula
```

Logic errors are the trickiest because your program doesn't crash - it just gives the wrong answer.

### Simple Debugging

When your program doesn't work as expected, you can debug it by adding print statements to see what's happening:

```python-execute
# Example: Debugging a temperature converter
print("=== Temperature Converter (with debugging) ===")

fahrenheit = float(input("Enter Fahrenheit temperature: "))
print(f"DEBUG: fahrenheit = {fahrenheit}")

# Apply conversion formula
celsius = (fahrenheit - 32) * 5 / 9
print(f"DEBUG: celsius = {celsius}")

# Show final result
print(f"Result: {fahrenheit}°F = {celsius:.1f}°C")
```

The DEBUG print statements help you see what values your variables have. Remove them once your program works correctly.

## Summary

You've learned to translate algorithmic thinking into executable code:

**Key Skills:**
- **Algorithm to code translation:** Converting step-by-step thinking into step-by-step execution
- **Input-Process-Output pattern:** The fundamental structure of all programs
- **Sequential execution:** Programs that execute one line at a time from top to bottom
- **Practical implementation:** Building complete programs that solve real problems

**Examples You Built:**
- Temperature converter
- Circle area calculator
- Distance calculator
- Interest calculator

**What's Next:**
The next section introduces loops and conditionals that will let you implement more sophisticated algorithms, including the complete contact search from section 1.1.

```note title="Learning Path"
- **Section 1.1:** Algorithmic thinking framework
- **Section 1.2:** Programming building blocks
- **Section 1.3:** Converting ideas to sequential code
- **Next sections:** Adding loops and decisions to implement complete algorithms
```
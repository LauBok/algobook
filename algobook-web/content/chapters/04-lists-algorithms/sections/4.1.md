# Python Lists: Your First Data Structure

## The Problem We Need to Solve

Imagine you're writing a program to track the daily temperatures for a week. With the tools you've learned so far—variables and basic operations—you might naturally approach it like this:

```python-execute
print("=== Tracking Temperatures the Hard Way ===")
# Monday through Sunday temperatures
temp_monday = 72
temp_tuesday = 75
temp_wednesday = 68
temp_thursday = 70
temp_friday = 73
temp_saturday = 76
temp_sunday = 74

print("Monday:", temp_monday)
print("Tuesday:", temp_tuesday) 
print("Wednesday:", temp_wednesday)
print("Thursday:", temp_thursday)
print("Friday:", temp_friday)
print("Saturday:", temp_saturday)
print("Sunday:", temp_sunday)
```

At first glance, this approach seems perfectly reasonable. Each day gets its own variable, and we can print them all out. But then reality hits—your requirements change: *"Actually, can you calculate the average temperature?"*

Suddenly, what seemed simple becomes unwieldy:

```python-execute
print("=== Calculating Average - Getting Unwieldy ===")
temp_monday = 72
temp_tuesday = 75
temp_wednesday = 68
temp_thursday = 70
temp_friday = 73
temp_saturday = 76
temp_sunday = 74

# This is becoming painful...
total = temp_monday + temp_tuesday + temp_wednesday + temp_thursday + temp_friday + temp_saturday + temp_sunday
average = total / 7
print("Average temperature:", average)
print("Had to list all seven variable names - this is getting ridiculous!")
```

```danger title="The Breaking Point"
What if they ask for a month of temperatures? You'd need 30 variables! What about a year? 365 variables! And imagine trying to find the highest temperature among 365 individual variables...
```

To see how quickly this approach breaks down, let's try finding the highest temperature with just our seven days:

```python-execute
print("=== Finding Maximum - This is Madness! ===")
temp_monday = 72
temp_tuesday = 75
temp_wednesday = 68
temp_thursday = 70
temp_friday = 73
temp_saturday = 76
temp_sunday = 74

# Find the maximum - prepare for pain!
maximum = temp_monday

if temp_tuesday > maximum:
    maximum = temp_tuesday

if temp_wednesday > maximum:
    maximum = temp_wednesday
    
if temp_thursday > maximum:
    maximum = temp_thursday
    
if temp_friday > maximum:
    maximum = temp_friday
    
if temp_saturday > maximum:
    maximum = temp_saturday
    
if temp_sunday > maximum:
    maximum = temp_sunday

print("Highest temperature:", maximum)
print("This is completely unsustainable!")
```

```quiz
id: problem-recognition
question: "You need to track test scores for 25 students. Using individual variables (score1, score2, etc.), what would be the biggest problem?"
options:
  - id: memory
    text: "The computer would run out of memory"
    correct: false
    explanation: "Memory isn't the issue - modern computers can handle thousands of variables easily."
  - id: repetitive
    text: "Writing repetitive, error-prone code that doesn't scale"
    correct: true
    explanation: "Exactly! Managing 25 individual variables means repetitive code, easy mistakes, and code that breaks when requirements change."
  - id: syntax
    text: "Python doesn't allow that many variables"
    correct: false
    explanation: "Python has no practical limit on the number of variables you can create."
  - id: speed
    text: "The program would run too slowly"
    correct: false
    explanation: "Speed isn't the main concern here - it's the code complexity and maintainability."
```

If you're feeling frustrated just reading this code, you're experiencing exactly what every programmer faces when they try to manage multiple related pieces of data with individual variables. This approach has several crushing problems:

- **Doesn't scale** - Need 30 days? 365 days? The code becomes impossibly long
- **Repetitive nightmare** - Nearly identical lines for every single operation
- **Error-prone** - Easy to mistype variable names or forget one entirely
- **Impossible to extend** - Adding just one more day means rewriting everything
- **Can't use patterns** - Each variable has a different name, so loops won't work

You're probably thinking: *"There has to be a better way!"*

**There is. And you're about to discover one of programming's most powerful solutions.**

## The Elegant Solution: Python Lists

Meet the **list**—Python's elegant solution to the "multiple related values" problem. Think of a list as a **container** that can hold multiple pieces of related information, all organized and accessible through a single name:

```python-execute
print("=== The Elegant List Solution ===")
# All temperatures in ONE data structure
temperatures = [72, 75, 68, 70, 73, 76, 74]

print("All temperatures:", temperatures)
print("This single line replaces seven variable declarations!")

# Now watch the magic happen...
print("Number of days:", len(temperatures))
print("Total temperature:", sum(temperatures))
print("Average temperature:", sum(temperatures) / len(temperatures))
print("Highest temperature:", max(temperatures))
print("Lowest temperature:", min(temperatures))

print("\nOne data structure. Five powerful operations. No repetitive code.")
```

```note title="The Data Structure Revolution"
You just witnessed the power of **data structures**—intelligent ways to organize multiple pieces of related information. Lists are your first data structure, and they're about to change how you think about programming problems forever.
```

Notice how lists solve every problem we faced with individual variables:
- ✅ **Scales effortlessly** - 7 items or 7000 items, the code stays exactly the same
- ✅ **Clean and readable** - no more repetitive variable declarations  
- ✅ **Built-in operations** - functions like `sum()`, `max()`, and `len()` work automatically
- ✅ **Flexible** - add, remove, or modify items as your program runs
- ✅ **Loop-friendly** - perfect for the loop patterns you learned in Chapter 3

## Understanding Lists: Your First Data Structure

Now that you've seen why lists matter, let's understand exactly what they are. A **list** is Python's fundamental way of storing multiple related items in a single, organized container:

```python-execute
print("=== What Lists Can Hold ===")
# Lists organize different types of related data
numbers = [10, 20, 30, 40, 50]
student_names = ["Alice", "Bob", "Carol", "David"]
test_scores = [85, 92, 78, 96, 89]
quiz_results = [True, False, True, True, False]

print("Numbers:", numbers)
print("Names:", student_names) 
print("Scores:", test_scores)
print("Results:", quiz_results)

print("\nEach list keeps its data organized and accessible!")
```

**Four key properties make lists incredibly powerful:**
- **Ordered** - items have specific, reliable positions (first, second, third...)
- **Changeable** - you can modify them after creation (unlike strings which are permanent)
- **Consistent** - typically hold the same type of data (all numbers, all names, etc.)
- **Dynamic** - they can grow and shrink as your program runs

## Creating Lists: Empty and Pre-filled

### Empty Lists: Ready for Data
Start with empty lists when you'll add items later:

```python-execute
print("=== Creating Empty Lists ===")
# Create empty containers for future data
student_grades = []
shopping_cart = []
user_inputs = []

print("Empty grades:", student_grades)
print("Empty cart:", shopping_cart)
print("Empty inputs:", user_inputs)

# Check if empty (very useful pattern!)
if not student_grades:
    print("No grades yet - ready to collect data!")
```

### Lists with Data: Hit the Ground Running

```python-execute
print("=== Creating Lists with Initial Data ===")
# Start with data when you know what you need
daily_temperatures = [68, 72, 75, 71, 69, 74, 76]
weekday_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
fibonacci_numbers = [0, 1, 1, 2, 3, 5, 8, 13, 21]
price_list = [9.99, 14.50, 22.00, 8.75]

print("Temperatures:", daily_temperatures)
print("Weekdays:", weekday_names)
print("Fibonacci:", fibonacci_numbers) 
print("Prices:", price_list)

# Any size works!
single_item = [42]
ten_items = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print("Single:", single_item)
print("Many:", ten_items)
```

## Accessing List Elements: The Index System

Now that you can create lists, you need to know how to get information back out of them. Each item in a list has a specific **position** called an **index**. Here's where Python does something that might seem a bit odd at first—it starts counting positions from **0** instead of 1:

```python-execute
print("=== Understanding List Positions ===")
colors = ["red", "green", "blue", "yellow", "purple"]
#         [0]    [1]     [2]     [3]      [4]

print("The list:", colors)
print("Total items:", len(colors))
print()

# Access each position
print("Position 0 (first):", colors[0])
print("Position 1 (second):", colors[1])
print("Position 2 (third):", colors[2])
print("Position 3 (fourth):", colors[3])
print("Position 4 (fifth):", colors[4])

print("Remember: Python starts counting positions at 0!")
```

```hint title="Why Start at Zero?"
Think of indices as "steps from the beginning." Index 0 means "0 steps from start" (you're already at the first item), index 1 means "1 step from start" (now you're at the second item), and so on. This zero-based system makes the math work beautifully in the algorithms you'll learn later!
```

```quiz
id: indexing-understanding
question: "If a list has 5 items, what are the valid index values?"
options:
  - id: one-to-five  
    text: "1, 2, 3, 4, 5"
    correct: false
    explanation: "This would be one-based indexing. Python uses zero-based indexing."
  - id: zero-to-four
    text: "0, 1, 2, 3, 4" 
    correct: true
    explanation: "Correct! With 5 items, valid indices are 0 (first) through 4 (last)."
  - id: zero-to-five
    text: "0, 1, 2, 3, 4, 5"
    correct: false
    explanation: "This would give you 6 positions, but the list only has 5 items."
  - id: negative-only
    text: "Only negative numbers like -1, -2"
    correct: false
    explanation: "Negative indices work, but positive indices are the primary way to access elements."
```

### Negative Indexing: Counting Backwards

Here's one of Python's most convenient features—you can also count backwards from the end of the list using negative numbers:

```python-execute
print("=== Negative Indexing: Counting Backwards ===")
fruits = ["apple", "banana", "orange", "grape", "kiwi"]
#         [-5]     [-4]      [-3]     [-2]    [-1]

print("The list:", fruits)
print()

# Access from the end
print("Last item (index -1):", fruits[-1])
print("Second to last (index -2):", fruits[-2])
print("Third from end (index -3):", fruits[-3])

print("\nComparing positive and negative:")
print("First item: fruits[0] =", fruits[0])
print("First item: fruits[-5] =", fruits[-5])
print("Last item: fruits[4] =", fruits[4])
print("Last item: fruits[-1] =", fruits[-1])
```

```hint title="When to Use Negative Indexing"
Negative indexing is incredibly handy when you want the last few items but don't know (or don't want to calculate) the list's exact length. `some_list[-1]` always gets the last item, whether your list has 5 items or 5000!
```

## Essential List Operations

### Built-in Functions: Your Data Analysis Toolkit

Lists become even more powerful when you combine them with Python's built-in functions. These functions can instantly analyze your entire collection:

```python-execute
print("=== List Information and Analysis ===")
test_scores = [85, 92, 78, 96, 89, 73, 88]

print("Test scores:", test_scores)
print("Number of tests:", len(test_scores))
print("Total points:", sum(test_scores))
print("Average score:", sum(test_scores) / len(test_scores))
print("Highest score:", max(test_scores))
print("Lowest score:", min(test_scores))

# Check if specific values exist
print("Did anyone score 90?", 90 in test_scores)
print("Did anyone score 85?", 85 in test_scores)
```

## List Slicing: Extracting Sublists

So far we've learned to access individual elements with indexing (`my_list[0]`). But what if you want to extract a portion of a list - multiple elements at once? This is where **list slicing** becomes incredibly powerful.

List slicing uses the same syntax pattern as the `range()` function you learned earlier: `start:stop:step`. The syntax is:

```python
my_list[start:stop:step]
```

Just like `range()`, slicing follows these rules:
- **start**: where to begin (inclusive)
- **stop**: where to end (exclusive - not included)
- **step**: how many positions to jump each time (optional, defaults to 1)

### Basic Slicing: Getting Sublists

Let's start with the most common slicing patterns:

```python-execute
scores = [85, 92, 78, 96, 88, 91, 83, 89]

# Get first 3 scores (indices 0, 1, 2)
first_three = scores[0:3]
print("First 3 scores:", first_three)

# Get scores from index 2 to 5 (indices 2, 3, 4)
middle_scores = scores[2:5]
print("Middle scores:", middle_scores)

# Get last 2 scores (indices 6, 7)
last_two = scores[6:8]
print("Last 2 scores:", last_two)
```

Notice how slicing creates a **new list** containing copies of the selected elements - it doesn't modify the original list.

### Slicing Shortcuts: Omitting Start and Stop

Python provides convenient shortcuts when you want to slice from the beginning or to the end:

```python-execute
numbers = [10, 20, 30, 40, 50, 60, 70]

# From beginning to index 4 (exclusive)
first_half = numbers[:4]
print("First half:", first_half)

# From index 3 to the end
second_half = numbers[3:]
print("Second half:", second_half)

# Entire list (copy of the whole thing)
full_copy = numbers[:]
print("Full copy:", full_copy)
```

### Negative Indices in Slicing

Remember negative indices? They work beautifully with slicing too:

```python-execute
playlist = ["Song A", "Song B", "Song C", "Song D", "Song E"]

# Last 2 songs
last_two_songs = playlist[-2:]
print("Last 2 songs:", last_two_songs)

# All but the last song
all_but_last = playlist[:-1]
print("All but last:", all_but_last)

# From second-to-last to third song (backwards indexing)
middle_section = playlist[-4:-1]
print("Middle section:", middle_section)
```

### Step Slicing: Skipping Elements

Here's where slicing gets really powerful - the step parameter lets you skip elements, just like in `range()`:

```python-execute
alphabet = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J']

# Every other letter starting from index 0
every_other = alphabet[0::2]  # start:stop:step where stop is omitted
print("Every other letter:", every_other)

# Every third letter starting from index 1
every_third = alphabet[1::3]
print("Every third from index 1:", every_third)

# First 6 letters, every 2nd one
selective = alphabet[:6:2]
print("First 6, every 2nd:", selective)
```

### The Magic of `[::-1]` - Reversing Lists

One of the most elegant slicing tricks is using a negative step to reverse a list:

```python-execute
original = [1, 2, 3, 4, 5]

# Reverse the entire list
reversed_list = original[::-1]
print("Original:", original)
print("Reversed:", reversed_list)

# Reverse just a portion
numbers = [10, 20, 30, 40, 50, 60]
reverse_middle = numbers[1:5][::-1]  # Get middle, then reverse
print("Original middle:", numbers[1:5])
print("Reversed middle:", reverse_middle)
```

The `[::-1]` pattern means:
- **start**: omitted (defaults to end of list when step is negative)
- **stop**: omitted (defaults to beginning of list when step is negative)  
- **step**: -1 (go backwards by 1 each time)

### Real-World Slicing Applications

Slicing shines in practical scenarios. Here are common patterns you'll use constantly:

```python-execute
# Processing data in chunks
daily_temperatures = [72, 75, 78, 82, 79, 77, 74, 71, 69, 73, 76, 80]

# Get weekdays vs weekend data
weekdays = daily_temperatures[:5]
weekend = daily_temperatures[5:7]
print("Weekday temps:", weekdays)
print("Weekend temps:", weekend)

# Get every other day's data
alternate_days = daily_temperatures[::2]
print("Every other day:", alternate_days)

# Last week's data (assuming 12 days total, last 7 days)
last_week = daily_temperatures[-7:]
print("Last week:", last_week)
```

```quiz
id: list-slicing-basics
question: "What will `[10, 20, 30, 40, 50][1:4]` return?"
options:
  - id: a
    text: "[10, 20, 30, 40]"
    correct: false
    explanation: "This would be [0:4]. Slicing [1:4] starts at index 1, not 0."
  - id: b
    text: "[20, 30, 40]"  
    correct: true
    explanation: "Correct! [1:4] gets elements at indices 1, 2, 3 (remember: stop is exclusive), which are 20, 30, 40."
  - id: c
    text: "[20, 30, 40, 50]"
    correct: false
    explanation: "This would be [1:5] or [1:]. The stop index 4 is exclusive, so element at index 4 (which is 50) is not included."
  - id: d
    text: "[30, 40]"
    correct: false
    explanation: "This would be [2:4]. The slice [1:4] starts at index 1 (value 20), not index 2."
```

```quiz
id: reverse-slicing
question: "Which slicing pattern will reverse a list?"
options:
  - id: a
    text: "[:1:-1]"
    correct: false
    explanation: "This would get elements from the end up to (but not including) index 1, in reverse order. It doesn't include the element at index 0."
  - id: b
    text: "[::-1]"
    correct: true
    explanation: "Perfect! [::-1] reverses the entire list by using a negative step with default start and stop values."
  - id: c
    text: "[:-1]"
    correct: false
    explanation: "This gets all elements except the last one, in normal order. It doesn't reverse anything."
  - id: d
    text: "[-1:]"
    correct: false
    explanation: "This gets just the last element as a single-item list. It doesn't reverse the list."
```

### Key Slicing Patterns to Remember

- **`list[:]`** - Copy entire list
- **`list[:n]`** - First n elements  
- **`list[n:]`** - From index n to end
- **`list[-n:]`** - Last n elements
- **`list[:-n]`** - All except last n elements
- **`list[::2]`** - Every other element
- **`list[::-1]`** - Reverse entire list
- **`list[start:stop:step]`** - Like `range(start, stop, step)` but for list extraction

```note title="Slicing vs range() - The Connection"
List slicing syntax mirrors `range()` function parameters:
- `range(1, 10, 2)` generates numbers: 1, 3, 5, 7, 9
- `my_list[1:10:2]` extracts elements at indices: 1, 3, 5, 7, 9
Both use the same `start:stop:step` pattern with the same inclusive/exclusive rules!
```

### Safe Indexing: Staying Within Bounds

Before we move on to more complex examples, there's one crucial concept you need to understand to avoid frustrating errors:

```warning title="Index Out of Bounds"
Always remember: if a list has N items, valid indices are 0 to N-1. Trying to access index N (or higher) will crash your program with an "index out of range" error!
```

```python-execute
print("=== Safe Indexing Practices ===")
data = [10, 20, 30]

print("List:", data)
print("Length:", len(data))
print("Valid indices: 0 to", len(data) - 1)

# Safe way to access all elements
print("Accessing all elements safely:")
for i in range(len(data)):
    print(f"Index {i}: {data[i]}")

print("Always check bounds before accessing!")
```

## Putting It All Together: Real-World Examples

Now that you understand the fundamentals, let's see how lists solve real problems. These examples show you the kind of practical applications you'll build throughout your programming career.

### Student Grade Analysis System

```python-execute
print("=== Student Grade Analysis System ===")
# Imagine trying this with individual variables!
student_grades = [87, 92, 78, 85, 94, 88, 76, 91, 83, 89]

print("All grades:", student_grades)
print("Number of students:", len(student_grades))

# Instant analytics
total_points = sum(student_grades)
class_average = total_points / len(student_grades)
highest_grade = max(student_grades)
lowest_grade = min(student_grades)
grade_range = highest_grade - lowest_grade

print(f"Class average: {class_average:.1f}")
print(f"Highest grade: {highest_grade}")
print(f"Lowest grade: {lowest_grade}")
print(f"Grade range: {grade_range} points")

# Now we can combine lists with the loops you learned in Chapter 3!
print(f"\nStudents above average ({class_average:.1f}):")
above_average_count = 0
for i in range(len(student_grades)):
    if student_grades[i] > class_average:
        print(f"  Student {i+1}: {student_grades[i]} points")
        above_average_count += 1

print(f"Students above average: {above_average_count}/{len(student_grades)}")
```

### Daily Sales Tracking Dashboard

```python-execute
print("=== Sales Analytics Dashboard ===")
# Sales for each day of the week
daily_sales = [1250, 1180, 1420, 1680, 1890, 2100, 1750]
weekdays = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]

print("📊 Weekly Sales Report:")
for i in range(len(daily_sales)):
    day = weekdays[i]
    sales = daily_sales[i]
    print(f"  {day}: ${sales}")

# Business intelligence in just a few lines!
total_sales = sum(daily_sales)
average_daily = total_sales / len(daily_sales)
best_day_sales = max(daily_sales)
worst_day_sales = min(daily_sales)

# Find the actual days (not just amounts)
for i in range(len(daily_sales)):
    if daily_sales[i] == best_day_sales:
        best_day = weekdays[i]
    if daily_sales[i] == worst_day_sales:
        worst_day = weekdays[i]

print(f"\n📈 Business Intelligence:")
print(f"Total weekly sales: ${total_sales}")
print(f"Average daily sales: ${average_daily:.2f}")
print(f"Best sales day: {best_day} (${best_day_sales})")
print(f"Worst sales day: {worst_day} (${worst_day_sales})")
print(f"Performance range: ${best_day_sales - worst_day_sales}")
```

## Your First Algorithm: Finding the Maximum

Here's where things get really exciting. Lists don't just store data—they unlock the world of **algorithms**. An algorithm is simply a step-by-step procedure for solving a problem. Let's implement your very first algorithm:

```python-execute
print("=== Algorithm: Linear Search for Maximum ===")
numbers = [45, 23, 67, 12, 89, 34, 56]

print("Finding the maximum value step by step:")
print("Numbers:", numbers)

# The Linear Maximum Finding Algorithm
current_max = numbers[0]  # Start with first element as our assumption
print(f"Step 1: Assume first element is maximum: {current_max}")

for i in range(1, len(numbers)):  # Check each remaining element
    current = numbers[i]
    print(f"Step {i+1}: Checking position {i} -> {current}")
    
    if current > current_max:
        current_max = current
        print(f"         New maximum found: {current_max}")
    else:
        print(f"         {current} ≤ {current_max}, no change")

print(f"\n🎯 Algorithm result: {current_max}")
print(f"✓ Verification with max(): {max(numbers)}")
```

```note title="You Just Implemented an Algorithm!"
Congratulations! You just implemented the **linear search for maximum** algorithm—a fundamental technique in computer science. Notice the systematic approach: examine each element, compare it to your current best, and update if you find something better. This exact pattern appears in countless programming applications!
```

## Key Takeaways: Your Programming Foundation Just Got Stronger

### The Problem Lists Solve
- **Multiple variables are unmanageable** → leads to repetitive, error-prone code
- **Related data belongs together** → scattered variables make no logical sense  
- **Processing collections is common** → most real problems involve multiple data items
- **Scale matters** → solutions must work for 7 items or 7000 items

### List Fundamentals You Now Know
- **Lists are ordered containers** → hold multiple values with reliable positions
- **Zero-based indexing** → first element is at position 0, second at position 1
- **Negative indexing** → count backwards with -1 (last), -2 (second to last)
- **Length and bounds** → use `len()` to find size, valid indices are 0 to N-1

### Core Operations You Can Use
- **Creation** → `[]` for empty, `[1, 2, 3]` for data-filled lists
- **Access** → `list[index]` to get/set individual elements
- **Information** → `len()`, `sum()`, `max()`, `min()`, `in` operator
- **Safety** → always check bounds, use `range(len(list))` for safe iteration

### Why This Matters for Your Future
- **Foundation for all algorithms** → most computational solutions process collections
- **Real-world relevance** → data naturally comes in groups (students, sales, temperatures)  
- **Professional code quality** → clean, maintainable, scalable solutions
- **Algorithmic thinking** → enables step-by-step problem-solving procedures

```quiz
id: lists-comprehension-check
question: "A program needs to track scores for a basketball team's 15 games. What's the strongest reason to use a list instead of 15 individual variables?"
options:
  - id: faster
    text: "Lists make the program run faster"
    correct: false  
    explanation: "Performance isn't the main benefit here - both approaches run at similar speeds."
  - id: less-memory
    text: "Lists use less computer memory"
    correct: false
    explanation: "Memory usage is similar between the two approaches."
  - id: enable-algorithms
    text: "Lists enable you to use loops and algorithms to process the data"
    correct: true
    explanation: "Exactly! Lists allow you to write algorithmic solutions that work regardless of data size, use loops for processing, and apply functions like max() and sum()."
  - id: required
    text: "Python requires related data to be in lists"
    correct: false
    explanation: "Python allows individual variables, but lists are a much better design choice."
```

## Practice: Master List Fundamentals

```exercise
id: list-fundamentals-mastery
title: List Fundamentals Practice
description: Practice creating lists and using basic list operations you just learned
difficulty: easy
echoInput: false
starterCode: |
  # List Fundamentals Practice
  # Create a list with exam scores and perform basic operations
  
  print("=== Exam Score Analysis ===")
  
  # TODO: Create a list called 'exam_scores' with these scores:
  # 78, 85, 92, 88, 76, 94, 89
  exam_scores = [0]  # Replace this line with the correct list
  
  # TODO: Print the list of exam scores
  print("Exam scores:", [])
  
  # TODO: Print the number of exams using len()
  print("Number of exams:", 0)
  
  # TODO: Print the first exam score (index 0)
  print("First exam score:", 0)
  
  # TODO: Print the last exam score using negative indexing (-1)
  print("Last exam score:", 0)
  
  # TODO: Calculate and print the total points using sum()
  print("Total points:", 0)
  
  # TODO: Calculate and print the average score
  # Hint: average = sum(exam_scores) / len(exam_scores)
  print("Average score:", 0.0)
  
  # TODO: Find and print the highest score using max()
  print("Highest score:", 0)
  
  # TODO: Find and print the lowest score using min()
  print("Lowest score:", 0)
testCases:
  - input: ""
    expectedOutput: |
      === Exam Score Analysis ===
      Exam scores: [78, 85, 92, 88, 76, 94, 89]
      Number of exams: 7
      First exam score: 78
      Last exam score: 89
      Total points: 602
      Average score: 86.0
      Highest score: 94
      Lowest score: 76
    hidden: false
hints:
  - Create the list with square brackets: [78, 85, 92, 88, 76, 94, 89]
  - Use len(exam_scores) to get the number of items
  - Access first element with exam_scores[0]
  - Access last element with exam_scores[-1]  
  - Use sum(exam_scores) to add all scores
  - Calculate average: sum(exam_scores) / len(exam_scores)
  - Use max(exam_scores) and min(exam_scores) for highest/lowest
solution: |
  print("=== Exam Score Analysis ===")
  
  exam_scores = [78, 85, 92, 88, 76, 94, 89]
  
  print("Exam scores:", exam_scores)
  print("Number of exams:", len(exam_scores))
  print("First exam score:", exam_scores[0])
  print("Last exam score:", exam_scores[-1])
  print("Total points:", sum(exam_scores))
  print("Average score:", sum(exam_scores) / len(exam_scores))
  print("Highest score:", max(exam_scores))
  print("Lowest score:", min(exam_scores))
```

## Looking Ahead: The Real Magic Begins

You now understand **what** lists are and **why** they're essential. But you've only seen the beginning. In the next section, you'll discover where the real magic happens: **combining lists with the loop patterns you mastered in Chapter 3**.

Get ready to learn how to:
- **Process every element** in a list systematically using loops
- **Implement fundamental algorithms** like linear search and data analysis
- **Extract insights and patterns** from any collection of data
- **Think algorithmically** — the core skill that powers all of computer science

Lists are your gateway to real computational problem-solving. Once you can combine them with loops, you'll have the tools to tackle the kinds of meaningful, complex problems that professional programmers solve every day. 

**The foundation is set. Now let's build something amazing.**
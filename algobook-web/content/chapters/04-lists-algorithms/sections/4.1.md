# Python Lists: Your First Data Structure

## Introduction to Lists

In previous chapters, you've seen lists used briefly in examples, but now it's time to understand them properly. A **list** is Python's way of storing multiple items in a single, organized container. Lists work naturally with the loop patterns from Chapter 3:

```python-execute
print("=== Contact Search with Lists ===")
# All contacts in ONE data structure
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown", "Emma Davis"]
target_name = "Sarah Johnson"

print("All contacts:", contacts)

# Now we can use loops from Chapter 3!
print(f"\nSearching for {target_name}...")
found = False

for contact in contacts:
    if contact == target_name:
        print(f"Found {target_name}!")
        found = True
        break
    else:
        print(f"{contact} is not the target")

if not found:
    print(f"{target_name} not found in contacts.")

print("\nLists enable efficient loop-based algorithms!")
```

```note title="Introduction to Data Structures"
**Data structures** are systematic ways to organize multiple pieces of related information. Lists are the fundamental data structure for managing collections of related values.
```

Lists provide key advantages for working with collections:
- **Organized storage** - multiple related items in one container
- **Loop compatibility** - work naturally with Chapter 3's loop patterns
- **Built-in operations** - functions like `len()` and `max()` work automatically
- **Scalable** - same code works for 5 contacts or 500 contacts

## List Fundamentals

A **list** is Python's fundamental way of storing multiple related items in a single, organized container. Lists can hold different types of data:

```python-execute
print("=== What Lists Can Hold ===")
# Contact-related examples
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson"]
contact_ages = [25, 30, 28]
has_email = [True, False, True]

print("Contact names:", contact_names)
print("Contact ages:", contact_ages)
print("Has email:", has_email)

print("\nEach list organizes related information systematically.")
```

Lists have key properties that make them useful for contact management:

- **Ordered** - contacts have specific, reliable positions. The first contact is always at position 0, the second at position 1, and so on. This order never changes unless you explicitly modify the list.

- **Changeable** - you can modify lists after creation. Unlike strings (which cannot be changed), you can update contact information, add new contacts, or remove existing ones.

- **Consistent** - while lists can technically hold different data types, they work best when holding the same type of data (all strings, all numbers, etc.). A contact list typically contains all strings.

- **Dynamic** - lists automatically adjust their size. You can start with an empty contact list and add contacts one by one, or remove contacts as needed. The list grows and shrinks automatically.

### Creating Lists

#### Empty Lists
Start with empty lists when you'll add data later:

```python-execute
print("=== Creating Empty Lists ===")
# Create empty containers for contact information
contact_list = []
phone_numbers = []

print("Empty contact list:", contact_list)
print("Empty phone numbers:", phone_numbers)

# Check if empty
if not contact_list:
    print("No contacts yet - ready to add data.")
```

#### Lists with Initial Data

```python-execute
print("=== Creating Lists with Initial Data ===")
# Start with data when you know the contacts
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson"]
phone_numbers = ["555-1234", "555-5678", "555-9012"]

print("Contacts:", contacts)
print("Phone numbers:", phone_numbers)

# Any size works
single_contact = ["Emergency Contact"]
many_contacts = ["Contact 1", "Contact 2", "Contact 3", "Contact 4", "Contact 5"]
print("Single:", single_contact)
print("Multiple:", many_contacts)
```

### Accessing List Elements

Now that you can create lists, you need to know how to access individual contacts. Each item in a list has a specific **position** called an **index**. Python starts counting positions from **0** instead of 1:

```python-execute
print("=== Understanding List Positions ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
#           [0]           [1]          [2]             [3]

print("Contact list:", contacts)
print("Total contacts:", len(contacts))
print()

# Access each position
print("Position 0 (first):", contacts[0])
print("Position 1 (second):", contacts[1])
print("Position 2 (third):", contacts[2])
print("Position 3 (fourth):", contacts[3])

print("Remember: Python starts counting positions at 0!")
```

```note title="Zero-Based Indexing"
Indices represent "steps from the beginning." Index 0 means "0 steps from start" (the first item), index 1 means "1 step from start" (the second item), and so on. This zero-based system simplifies mathematical operations in algorithms.
```

```quiz
id: indexing-understanding
question: "If a list has 5 items, what are the valid index values?"
options:
  - id: one-to-five  
    text: "1, 2, 3, 4, 5"
    correct: false
    explanation: "This would be one-based indexing. Python uses zero-based indexing."
  - id: zero-to-four
    text: "0, 1, 2, 3, 4" 
    correct: true
    explanation: "Correct! With 5 items, valid indices are 0 (first) through 4 (last)."
  - id: zero-to-five
    text: "0, 1, 2, 3, 4, 5"
    correct: false
    explanation: "This would give you 6 positions, but the list only has 5 items."
  - id: negative-only
    text: "Only negative numbers like -1, -2"
    correct: false
    explanation: "Negative indices work, but positive indices are the primary way to access elements."
```

#### Negative Indexing: Counting Backwards

Python allows counting backwards from the end of the list using negative numbers:

```python-execute
print("=== Negative Indexing: Counting Backwards ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
#           [-4]          [-3]         [-2]            [-1]

print("Contact list:", contacts)
print()

# Access from the end
print("Last contact (index -1):", contacts[-1])
print("Second to last (index -2):", contacts[-2])

print("\nComparing positive and negative:")
print("First contact: contacts[0] =", contacts[0])
print("Last contact: contacts[3] =", contacts[3])
print("Last contact: contacts[-1] =", contacts[-1])
```

```note title="Negative Indexing Usage"
Negative indexing provides access to elements from the end without calculating list length. `some_list[-1]` always returns the last item regardless of list size.
```

### Essential List Operations

Lists work with Python's built-in functions for analysis:

```python-execute
print("=== List Information and Analysis ===")
contact_ids = [101, 102, 103, 104, 105]

print("Contact IDs:", contact_ids)
print("Number of contacts:", len(contact_ids))
print("Total IDs:", sum(contact_ids))
print("Highest ID:", max(contact_ids))
print("Lowest ID:", min(contact_ids))

# Check if specific values exist
print("Is contact 103 in list?", 103 in contact_ids)
print("Is contact 200 in list?", 200 in contact_ids)
```

### Basic List Slicing

You can extract multiple elements from a list using **slicing**. List slicing uses familiar syntax from the `range()` function:

```python-execute
print("=== Basic List Slicing ===")
contacts = ["Alice", "Bob", "Sarah", "David", "Emma", "Frank"]

# Get first 3 contacts
first_three = contacts[0:3]
print("First 3 contacts:", first_three)

# Get contacts from index 2 to end
remaining = contacts[2:]
print("From index 2 to end:", remaining)

# Get last 2 contacts
last_two = contacts[-2:]
print("Last 2 contacts:", last_two)
```

Common slicing patterns:
- `contacts[0:3]` - first 3 elements (indices 0, 1, 2)
- `contacts[2:]` - from index 2 to end
- `contacts[-2:]` - last 2 elements

#### Safe Indexing: Staying Within Bounds

Before proceeding to more complex examples, understanding index bounds is crucial to avoid errors:

```warning title="Index Out of Bounds"
If a list has N items, valid indices are 0 to N-1. Accessing index N (or higher) will generate an "index out of range" error.
```

```python-execute
print("=== Safe Indexing Practices ===")
data = [10, 20, 30]

print("List:", data)
print("Length:", len(data))
print("Valid indices: 0 to", len(data) - 1)

# Safe way to access all elements
print("Accessing all elements safely:")
for i in range(len(data)):
    print(f"Index {i}: {data[i]}")

print("Always check bounds before accessing!")
```

## Lists with Loops: Practical Applications

### Contact Processing System

Now that you understand list fundamentals, let's see how lists work with the loops from Chapter 3 to solve practical problems:

```python-execute
print("=== Contact Processing System ===")
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
contact_ages = [25, 30, 28, 22]

print("Contact directory:")
for i in range(len(contact_names)):
    name = contact_names[i]
    age = contact_ages[i]
    print(f"{i+1}. {name} (Age: {age})")

# Find contacts over 25
print("\nContacts over 25:")
for i in range(len(contact_ages)):
    if contact_ages[i] > 25:
        print(f"  {contact_names[i]} is {contact_ages[i]} years old")
```

### Basic Algorithm: Finding Maximum Value

Lists enable algorithmic solutions. Here's a fundamental algorithm for finding the maximum value:

```python-execute
print("=== Finding Maximum Contact Age ===")
ages = [25, 30, 28, 22, 35, 19]

print("Ages:", ages)

# Linear search for maximum
current_max = ages[0]
print(f"Start with first age: {current_max}")

for i in range(1, len(ages)):
    current_age = ages[i]
    print(f"Checking age {current_age}")

    if current_age > current_max:
        current_max = current_age
        print(f"  New maximum: {current_max}")
    else:
        print(f"  {current_age} â‰¤ {current_max}, no change")

print(f"\nOldest contact age: {current_max}")
print(f"Verification with max(): {max(ages)}")
```

## Key Takeaways

#### What Lists Enable
- **Organized data storage** - multiple related items in one container
- **Loop integration** - apply Chapter 3's patterns to collections
- **Algorithmic solutions** - step-by-step processing of data sets
- **Scalable code** - same approach works for small or large collections

#### Essential List Skills
- **Creation** - `[]` for empty lists, `[item1, item2]` for initial data
- **Access** - `list[index]` with zero-based indexing (0, 1, 2, ...)
- **Information** - `len()`, `max()`, `min()`, `in` operator for analysis
- **Safety** - check bounds, use `range(len(list))` for safe iteration

#### Connection to Algorithm Development
- **Data structures** - systematic organization of related information
- **Loop patterns** - process collections efficiently using Chapter 3 techniques
- **Problem solving** - break down complex tasks into list operations

```quiz
id: lists-comprehension-check
question: "A program needs to track scores for a basketball team's 15 games. What's the strongest reason to use a list instead of 15 individual variables?"
options:
  - id: faster
    text: "Lists make the program run faster"
    correct: false  
    explanation: "Performance isn't the main benefit here - both approaches run at similar speeds."
  - id: less-memory
    text: "Lists use less computer memory"
    correct: false
    explanation: "Memory usage is similar between the two approaches."
  - id: enable-algorithms
    text: "Lists enable you to use loops and algorithms to process the data"
    correct: true
    explanation: "Exactly! Lists allow you to write algorithmic solutions that work regardless of data size, use loops for processing, and apply functions like max() and sum()."
  - id: required
    text: "Python requires related data to be in lists"
    correct: false
    explanation: "Python allows individual variables, but lists are a much better design choice."
```

## Practice and Assessment

```exercise
id: list-fundamentals-mastery
title: Contact List Practice
description: Practice basic list operations with contact data
difficulty: easy
echoInput: false
starterCode: |
  print("=== Contact Management System ===")

  # Create contact lists with the given data
  contact_names = []  # Add: "Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"
  contact_ages = []   # Add: 25, 30, 28, 22

  print("Contact names:", contact_names)
  print("Number of contacts:", len(contact_names))
  print("First contact:", contact_names[0])
  print("Last contact:", contact_names[-1])
  print("Oldest contact age:", max(contact_ages))
  print("Youngest contact age:", min(contact_ages))
  print("Sarah Johnson in contacts:", "Sarah Johnson" in contact_names)
testCases:
  - input: ""
    expectedOutput: |
      === Contact Management System ===
      Contact names: ['Alice Smith', 'Bob Wilson', 'Sarah Johnson', 'David Brown']
      Number of contacts: 4
      First contact: Alice Smith
      Last contact: David Brown
      Oldest contact age: 30
      Youngest contact age: 22
      Sarah Johnson in contacts: True
    hidden: false
hints:
  - "Create lists using square brackets: ['Alice Smith', 'Bob Wilson', 'Sarah Johnson', 'David Brown']"
  - "Ages list: [25, 30, 28, 22]"
  - "Use max() and min() functions on the ages list"
solution: |
  print("=== Contact Management System ===")

  contact_names = ['Alice Smith', 'Bob Wilson', 'Sarah Johnson', 'David Brown']
  contact_ages = [25, 30, 28, 22]

  print("Contact names:", contact_names)
  print("Number of contacts:", len(contact_names))
  print("First contact:", contact_names[0])
  print("Last contact:", contact_names[-1])
  print("Oldest contact age:", max(contact_ages))
  print("Youngest contact age:", min(contact_ages))
  print("Sarah Johnson in contacts:", "Sarah Johnson" in contact_names)
```

## Looking Ahead

This section introduced lists as Python's fundamental data structure for managing collections of related information. You learned how to create lists, access elements, and perform basic operations.

The next section explores combining lists with the loop patterns from Chapter 3 to process collections systematically. You'll learn to implement algorithms that search, analyze, and transform list data using the programming foundations from previous chapters.

Lists provide the data organization foundation that makes algorithmic problem-solving possible.
# Chapter 4 Practice Problems

## Assessment

Test your mastery of lists and algorithms with these LeetCode-style problems.

## Problem 1: Two Sum
**Difficulty**: Easy  
**Topics**: Array Search, Linear Search

Given an array of integers and a target sum, return indices of two numbers that add up to target.

```exercise
id: two-sum
title: Two Sum
description: Find indices of two numbers that add up to target (return first valid pair found)
difficulty: easy
starterCode: |
  # Read input: first line is array, second line is target
  nums = list(map(int, input().split()))
  target = int(input())
  
  # Find indices i, j where nums[i] + nums[j] = target
  # Return the first valid pair found when checking i=0,1,2... then j=i+1,i+2...
  # Output format: two integers separated by single space
  
  print("0 1")  # Replace with your solution
testCases:
  - input: |
      2 7 11 15
      9
    expectedOutput: "0 1"
    hidden: false
  - input: |
      3 2 4
      6
    expectedOutput: "1 2"
    hidden: true
  - input: |
      3 3
      6
    expectedOutput: "0 1"
    hidden: true
  - input: |
      1 5 3 8 2
      10
    expectedOutput: "3 4"
    hidden: true
  - input: |
      10 20 30 40
      50
    expectedOutput: "0 3"
    hidden: true
  - input: |
      1 2 3 4 5
      8
    expectedOutput: "2 4"
    hidden: true
  - input: |
      0 4 3 0
      0
    expectedOutput: "0 3"
    hidden: true
  - input: |
      -1 -2 -3 -4 -5
      -8
    expectedOutput: "2 4"
    hidden: true
  - input: |
      5 5 5 5
      10
    expectedOutput: "0 1"
    hidden: true
  - input: |
      100 200 300
      500
    expectedOutput: "1 2"
    hidden: true
solution: |
  nums = list(map(int, input().split()))
  target = int(input())
  
  # Brute force approach using nested loops
  for i in range(len(nums)):
      for j in range(i + 1, len(nums)):
          if nums[i] + nums[j] == target:
              print(f"{i} {j}")
              break
      else:
          continue
      break
```

## Problem 2: Find Peak Element
**Difficulty**: Medium  
**Topics**: Array Search, Linear Search

A peak element is greater than its neighbors. Find the index of the peak element. (Exactly one peak exists in test data)

```exercise
id: find-peak-element
title: Find Peak Element
description: Find index of the peak element (greater than both neighbors)
difficulty: medium
starterCode: |
  # Read input array
  nums = list(map(int, input().split()))
  
  # Find index of the peak element
  # Peak: nums[i] > nums[i-1] and nums[i] > nums[i+1]
  # Edge elements: compare with existing neighbor only
  # Output format: single integer on one line
  
  print(0)  # Replace with your solution
testCases:
  - input: "1 3 1"
    expectedOutput: "1"
    hidden: false
  - input: "1 2 3 4 5"
    expectedOutput: "4"
    hidden: true
  - input: "5 4 3 2 1"
    expectedOutput: "0"
    hidden: true
  - input: "1"
    expectedOutput: "0"
    hidden: true
  - input: "1 2"
    expectedOutput: "1"
    hidden: true
  - input: "2 1"
    expectedOutput: "0"
    hidden: true
  - input: "1 4 2"
    expectedOutput: "1"
    hidden: true
  - input: "1 2 4 3"
    expectedOutput: "2"
    hidden: true
  - input: "1 3 2 1"
    expectedOutput: "1"
    hidden: true
  - input: "0 1 3 2 0"
    expectedOutput: "2"
    hidden: true
solution: |
  nums = list(map(int, input().split()))
  
  if len(nums) == 1:
      print(0)
  elif len(nums) == 2:
      if nums[0] > nums[1]:
          print(0)
      else:
          print(1)
  else:
      # Check first element
      if nums[0] > nums[1]:
          print(0)
      # Check last element  
      elif nums[-1] > nums[-2]:
          print(len(nums) - 1)
      else:
          # Check middle elements
          for i in range(1, len(nums) - 1):
              if nums[i] > nums[i-1] and nums[i] > nums[i+1]:
                  print(i)
                  break
```

## Problem 3: Remove Duplicates
**Difficulty**: Easy  
**Topics**: Array Processing, Filtering

Remove duplicates from sorted array in-place. Return length of unique elements.

```exercise
id: remove-duplicates
title: Remove Duplicates from Sorted Array
description: Remove duplicates in-place, return length of unique elements
difficulty: easy
starterCode: |
  # Read sorted array
  nums = list(map(int, input().split()))
  
  # Remove duplicates in-place
  # Return length of array with unique elements
  # Output format: single integer on one line
  
  print(len(nums))  # Replace with your solution
testCases:
  - input: "1 1 2"
    expectedOutput: "2"
    hidden: false
  - input: "0 0 1 1 1 2 2 3 3 4"
    expectedOutput: "5"
    hidden: true
  - input: "1"
    expectedOutput: "1"
    hidden: true
  - input: "1 1 1 1"
    expectedOutput: "1"
    hidden: true
  - input: "1 2 3 4 5"
    expectedOutput: "5"
    hidden: true
  - input: "1 1 2 2 3 3"
    expectedOutput: "3"
    hidden: true
  - input: "5 5 5 5 5 5"
    expectedOutput: "1"
    hidden: true
  - input: "1 2 2 3 3 3 4 4 4 4"
    expectedOutput: "4"
    hidden: true
  - input: "0 1 2 3 4 5 6 7 8 9"
    expectedOutput: "10"
    hidden: true
  - input: "2 2 2 3 4 4 5"
    expectedOutput: "4"
    hidden: true
solution: |
  nums = list(map(int, input().split()))
  
  if len(nums) <= 1:
      print(len(nums))
  else:
      # Two pointer approach
      write_pos = 1
      for read_pos in range(1, len(nums)):
          if nums[read_pos] != nums[read_pos - 1]:
              nums[write_pos] = nums[read_pos]
              write_pos += 1
      print(write_pos)
```

## Mastery Check

```quiz
id: chapter-4-mastery
questions:
  - id: array-vs-variables
    question: "What's the main advantage of arrays over individual variables?"
    options:
      - id: speed
        text: "Arrays make programs run faster"
        correct: false
        explanation: "Speed isn't the primary benefit."
      - id: scalability
        text: "Arrays handle any amount of data with the same code"
        correct: true
        explanation: "Correct! Arrays enable scalable solutions."
      - id: memory
        text: "Arrays use less memory"
        correct: false
        explanation: "Memory usage is similar - scalability is the key benefit."
      - id: syntax
        text: "Arrays have simpler syntax than variables"
        correct: false
        explanation: "Syntax complexity isn't the main advantage - it's about organizing and scaling data."

  - id: bubble-sort-property
    question: "What guarantees bubble sort eventually sorts the array?"
    options:
      - id: luck
        text: "Random comparisons eventually work"
        correct: false
        explanation: "Bubble sort is deterministic, not random."
      - id: positioning
        text: "Each pass positions at least one element correctly"
        correct: true
        explanation: "Exactly! Each pass bubbles largest element to final position."
      - id: checking
        text: "It checks if sorted after each swap"
        correct: false
        explanation: "The fundamental guarantee comes from the positioning property."
      - id: magic
        text: "It uses advanced mathematical properties"
        correct: false
        explanation: "While bubble sort can be proven mathematically, the key insight is the simple positioning guarantee."

  - id: algorithm-choice
    question: "When should you use linear search vs other algorithms?"
    options:
      - id: always
        text: "Always use linear search - it's simplest"
        correct: false
        explanation: "Simple doesn't always mean best choice."
      - id: unsorted-small
        text: "For unsorted data or small datasets"
        correct: true
        explanation: "Correct! Linear search works on any data but better algorithms exist for sorted/large data."
      - id: never
        text: "Never - other algorithms are always better"
        correct: false
        explanation: "Linear search has its place for certain scenarios."
      - id: sorted-only
        text: "Only when data is already sorted"
        correct: false
        explanation: "Linear search works on any data, but for sorted data, binary search would be more efficient."
```

## Chapter 4 Complete!

### Skills Mastered:
- **Array Fundamentals**: Creation, indexing, built-in functions
- **Processing Patterns**: Search, filter, transform, aggregate
- **Algorithm Implementation**: Bubble sort, linear search
- **Problem Solving**: Apply algorithms to real challenges

### Ready for Chapter 5:
- ✅ Manipulate arrays confidently 
- ✅ Implement basic algorithms from scratch
- ✅ Choose appropriate techniques for each problem
- ✅ Write clean, efficient solutions

**Congratulations!** You've mastered fundamental data structures and algorithms - the foundation for all advanced programming!
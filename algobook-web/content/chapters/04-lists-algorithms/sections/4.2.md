# List Processing with Loops

## Introduction

Section 4.1 introduced lists and demonstrated basic contact search. Now you'll learn to combine lists with Chapter 3's loop patterns to implement complete algorithms. This combination allows you to process any number of contacts using the same code structure.

```python-execute
print("=== Contact Processing: Any Size List ===")
# Small contact list
small_contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson"]

# Larger contact list
large_contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown",
                  "Emma Davis", "Frank Miller", "Grace Lee", "Henry Clark"]

target_name = "Sarah Johnson"

# Search in small list
print("Searching small list...")
found = False
for contact in small_contacts:
    if contact == target_name:
        print(f"Found {target_name}!")
        found = True
        break
if not found:
    print(f"{target_name} not found")

# Search in large list using same approach
print("\nSearching large list...")
found = False
for contact in large_contacts:
    if contact == target_name:
        print(f"Found {target_name}!")
        found = True
        break
if not found:
    print(f"{target_name} not found")

print("\nSame algorithm works for any number of contacts.")
```

## Loop Techniques for Contact Processing

### Two Ways to Loop Through Lists

When processing contact lists, you can choose between two loop approaches depending on what information you need:

#### Direct Iteration: Working with Contact Names

When you only need the contact names themselves, use direct iteration:

```python-execute
print("=== Direct Iteration with Contacts ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]

print("All contacts:")
for contact in contacts:
    print(f"  {contact}")

print("\nThis is the most common approach for simple processing.")
```

#### Index-Based Iteration: When Position Matters

When you need to know positions or work with multiple related lists, use index-based iteration:

```python-execute
print("=== Index-Based Iteration with Contacts ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]

print("Numbered contact list:")
for i in range(len(contacts)):
    contact = contacts[i]
    position = i + 1  # Human-friendly numbering
    print(f"  {position}. {contact}")

print(f"\nProcessed {len(contacts)} contacts with positions.")
```

#### Working with Related Contact Data

Contact systems often have multiple related lists that must be processed together:

```python-execute
print("=== Processing Related Contact Data ===")
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
phone_numbers = ["555-1234", "555-5678", "555-9012", "555-3456"]
has_email = [True, False, True, True]

print("Complete contact directory:")
for i in range(len(contact_names)):
    name = contact_names[i]
    phone = phone_numbers[i]
    email_status = "Yes" if has_email[i] else "No"
    print(f"  {name}: {phone} (Email: {email_status})")

print(f"\nGenerated directory for {len(contact_names)} contacts.")
```

#### Alternative: Using enumerate()

Python provides `enumerate()` as a cleaner way to get both the index and value:

```python-execute
print("=== Using enumerate() for Index and Value ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]

print("Numbered contact list with enumerate():")
for i, contact in enumerate(contacts):
    position = i + 1
    print(f"  {position}. {contact}")

print("\nThis is often cleaner than using range(len(contacts)).")
```

```quiz
id: iteration-choice
question: "You have a list of contact names and a separate list of their phone numbers. You need to print each contact with their phone number. Which iteration method should you use?"
options:
  - id: direct
    text: "Direct iteration (`for contact in contacts`)"
    correct: false
    explanation: "Direct iteration only gives you access to one list at a time. You need positions to match contacts with their phone numbers."
  - id: index-based
    text: "Index-based iteration (`for i in range(len(contacts))`)"
    correct: true
    explanation: "Correct! You need indices to access corresponding elements from both the contact names list and the phone numbers list."
  - id: both
    text: "Use both methods simultaneously"
    correct: false
    explanation: "You can only use one iteration method at a time in a single loop."
  - id: doesnt-matter
    text: "Either method works equally well"
    correct: false
    explanation: "When working with multiple related lists, you need index-based iteration to access corresponding elements."
```

### Contact Processing with Loops

When working with contact lists, you'll frequently need to perform these operations:

#### Counting Contacts

Count how many contacts meet specific criteria:

```python-execute
print("=== Counting Contacts ===")
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown", "Emma Davis"]
has_email = [True, False, True, True, False]

print("Contact list:", contact_names)
print("Goal: Count how many contacts have email addresses")

# Counting pattern
email_count = 0
for i in range(len(contact_names)):
    if has_email[i]:
        email_count = email_count + 1
        print(f"  {contact_names[i]} has email")

print(f"\nTotal contacts with email: {email_count} out of {len(contact_names)}")
```

#### Finding Specific Contacts

Select contacts that meet certain criteria:

```python-execute
print("=== Finding Specific Contacts ===")
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
contact_ages = [25, 30, 28, 22]

print("Goal: Find contacts over 25 years old")

# Selection pattern
contacts_over_25 = []
for i in range(len(contact_names)):
    if contact_ages[i] > 25:
        contacts_over_25.append(contact_names[i])
        print(f"  Found: {contact_names[i]} (age {contact_ages[i]})")

print(f"\nContacts over 25: {contacts_over_25}")
```

#### Building Contact Summaries

Accumulate information about contacts:

```python-execute
print("=== Building Contact Summaries ===")
contact_names = ["Alice", "Bob", "Sarah", "David"]
call_counts = [5, 2, 8, 3]

print("Goal: Calculate total calls across all contacts")

# Accumulation pattern
total_calls = 0
for i in range(len(contact_names)):
    calls = call_counts[i]
    total_calls = total_calls + calls
    print(f"  {contact_names[i]}: {calls} calls")

print(f"\nTotal calls: {total_calls}")
average_calls = total_calls / len(contact_names)
print(f"Average calls per contact: {average_calls:.1f}")
```

## Contact Search Algorithm Implementation

Now let's implement the complete contact search algorithm using the patterns you've learned. This builds directly on the contact search concepts from previous chapters:

### Step-by-Step Contact Search

```python-execute
print("=== Complete Contact Search Algorithm ===")
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown", "Emma Davis"]
target_name = "Sarah Johnson"

print(f"Contact list: {contacts}")
print(f"Searching for: {target_name}")
print()

# Linear search algorithm
found = False
position = -1

for i in range(len(contacts)):
    current_contact = contacts[i]
    print(f"Step {i + 1}: Checking {current_contact}")

    if current_contact == target_name:
        found = True
        position = i
        print(f"  Found match! {target_name} is at position {i + 1}")
        break
    else:
        print(f"  No match, continue searching...")

if found:
    print(f"\nSearch successful: {target_name} found at position {position + 1}")
else:
    print(f"\nSearch unsuccessful: {target_name} not found in contacts")
```

### Finding Multiple Matches

Sometimes you need to find all contacts that match certain criteria:

```python-execute
print("=== Finding Multiple Contacts ===")
contacts = ["Alice Smith", "Bob Smith", "Sarah Johnson", "David Smith", "Emma Davis"]
search_term = "Smith"

print(f"Contact list: {contacts}")
print(f"Searching for contacts containing: '{search_term}'")
print()

# Find all matching contacts
matching_contacts = []
for i in range(len(contacts)):
    contact = contacts[i]
    if search_term in contact:
        matching_contacts.append(contact)
        print(f"Found match: {contact}")

print(f"\nTotal matches found: {len(matching_contacts)}")
print(f"Matching contacts: {matching_contacts}")
```

### Contact Statistics

Combine search with counting and accumulation patterns:

```python-execute
print("=== Contact Database Statistics ===")
contact_names = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
contact_cities = ["New York", "Boston", "New York", "Chicago"]

print("Contact database:")
for i in range(len(contact_names)):
    print(f"  {contact_names[i]} - {contact_cities[i]}")

# Count contacts by city
cities = ["New York", "Boston", "Chicago"]
for city in cities:
    count = 0
    for contact_city in contact_cities:
        if contact_city == city:
            count = count + 1
    print(f"\nContacts in {city}: {count}")
```

## Key Takeaways

You have learned to combine lists with loops to implement complete algorithms for contact management:

#### Essential Skills Developed
- **Contact processing patterns** - counting, finding, and summarizing contact information
- **Algorithm implementation** - step-by-step contact search with detailed tracking
- **Multiple search strategies** - finding single contacts and multiple matches
- **Data coordination** - working with related contact information across multiple lists

#### Loop Mastery for Contact Systems
- **Direct iteration** - when you only need contact names or values
- **Index-based iteration** - when you need positions or multiple related lists
- **Pattern recognition** - identifying which approach fits your contact processing needs

#### Contact Search Algorithm
You implemented a complete linear search algorithm that:
- Searches through any number of contacts
- Tracks progress step-by-step
- Reports success or failure with position information
- Handles both single and multiple search criteria

These patterns form the foundation for any contact management system and scale from small personal contact lists to large business databases.

## Practice and Assessment

Apply your contact processing skills:

```exercise
id: contact-search-practice
title: Contact Search Implementation
description: Practice implementing contact search with step tracking
difficulty: easy
echoInput: false
starterCode: |
  # Implement contact search with detailed tracking
  contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
  target = "Bob Wilson"

  print(f"Searching for: {target}")
  print(f"Contact list: {contacts}")
  print()

  # TODO: Implement search with step-by-step tracking
  # Use a for loop with range(len(contacts))
  # Print each step and check for matches
  # Set found = True and break when found
  found = False

  # Write your search loop here

  if found:
      print("Search successful!")
  else:
      print("Contact not found")

testCases:
  - input: ""
    expectedOutput: |
      Searching for: Bob Wilson
      Contact list: ['Alice Smith', 'Bob Wilson', 'Sarah Johnson', 'David Brown']

      Step 1: Checking Alice Smith
      Step 2: Checking Bob Wilson
      Found match!
      Search successful!
    hidden: false
hints:
  - "Use for i in range(len(contacts)) to get both index and contact"
  - "Print each step: print(f'Step {i+1}: Checking {contacts[i]}')"
  - "Check for match: if contacts[i] == target"
  - "Set found = True and break when match found"
solution: |
  contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown"]
  target = "Bob Wilson"

  print(f"Searching for: {target}")
  print(f"Contact list: {contacts}")
  print()

  found = False

  for i in range(len(contacts)):
      print(f"Step {i+1}: Checking {contacts[i]}")
      if contacts[i] == target:
          print("Found match!")
          found = True
          break

  if found:
      print("Search successful!")
  else:
      print("Contact not found")
```

## Looking Ahead

This section demonstrated how to combine lists with loops to process contact data systematically. You implemented complete search algorithms and learned fundamental patterns for working with collections.

The next section explores dynamic list manipulation - adding, removing, and modifying contacts during program execution to build interactive contact management systems.
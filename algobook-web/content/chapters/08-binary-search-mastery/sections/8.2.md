# Binary Search Variations: Handling Duplicates and Boundaries

Section 8.1 presented binary search for arrays with unique elements. However, real applications frequently involve sorted data with duplicate values, requiring algorithmic modifications to control which occurrence is found and to locate insertion boundaries.

This section examines binary search variations that handle duplicates systematically, establishing the theoretical foundation for boundary detection and range query algorithms.

## Learning Objectives

- Analyze binary search behavior with duplicate elements
- Implement algorithms for finding first and last occurrences
- Develop insertion point and boundary detection techniques
- Apply unified bounds theory to range query problems

## Binary Search with Duplicate Elements

Standard binary search exhibits undefined behavior when multiple copies of the target value exist. While the algorithm correctly locates some occurrence, it provides no guarantee about which specific instance is returned:

```python-execute
def basic_binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Demonstrate unpredictable behavior with duplicates
numbers = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
result = basic_binary_search(numbers, 2)
print(f"Found value 2 at index {result}")  # Could be index 1, 2, 3, or 4
```

```note title="Deterministic but Unpredictable Results"
Standard binary search produces deterministic results—it always returns the same index for identical inputs—but which occurrence it finds among duplicates depends on the algorithm's internal decision path. Applications requiring specific occurrences need specialized algorithms.
```

## First Occurrence Detection

Many applications require finding the leftmost occurrence of a target value among duplicates. This variation modifies the standard algorithm to continue searching in the left subarray even after finding a match:

```python-execute
def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid  # Record position, continue searching left
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Test with duplicate array
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(find_first_occurrence(test_array, 2))  # Returns 1
print(find_first_occurrence(test_array, 5))  # Returns 7
```

The critical modification occurs when `arr[mid] == target`: instead of returning immediately, the algorithm records the current position and continues searching the left subarray for potentially earlier occurrences.

## Last Occurrence Detection

Last occurrence detection applies the symmetric approach, searching the right subarray after finding a match:

```python-execute
def find_last_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid  # Record position, continue searching right
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Demonstrate symmetric behavior
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(find_last_occurrence(test_array, 2))  # Returns 4
print(find_last_occurrence(test_array, 5))  # Returns 9
```

Both variations follow the same pattern: continue searching in the appropriate direction even after finding the target. This establishes the fundamental principle for boundary detection algorithms.

```quiz
id: first-last-occurrence
question: "When finding the LAST occurrence of a target in an array with duplicates, what should you do after finding a match at the middle position?"
options:
  - id: a
    text: "Stop immediately and return the current position"
    correct: false
    explanation: "If you stop immediately, you might miss later occurrences of the same value."
  - id: b
    text: "Continue searching in the right half to see if there's a later occurrence"
    correct: true
    explanation: "Correct! To find the rightmost occurrence, you need to keep searching in the right half even after finding a match, in case there are more copies of the target further right."
  - id: c
    text: "Continue searching in the left half to find earlier occurrences"
    correct: false
    explanation: "Searching left would help find the first occurrence, not the last one."
  - id: d
    text: "Search both halves simultaneously"
    correct: false
    explanation: "Binary search works by eliminating half the search space at each step, not searching both halves."
```

## Insertion Point Detection

Applications requiring sorted order maintenance need algorithms that determine insertion positions for new elements. This variation uses modified boundary conditions to handle positions beyond the array's current bounds:

```python-execute
def find_insertion_point(arr, target):
    left, right = 0, len(arr)  # right = len(arr) to allow end insertion

    while left < right:  # left < right to handle boundary properly
        mid = (left + right) // 2

        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left

# Test insertion points
test_array = [1, 3, 5, 7, 9, 11]
print(find_insertion_point(test_array, 0))   # Returns 0 (beginning)
print(find_insertion_point(test_array, 4))   # Returns 2 (between 3 and 5)
print(find_insertion_point(test_array, 12))  # Returns 6 (end)
```

The key differences from occurrence-finding algorithms are the boundary conditions: `right = len(arr)` enables insertion at the array's end, while `left < right` prevents accessing out-of-bounds indices.

## Lower and Upper Bounds

In many applications, you need to find the range where a value could appear. This involves finding both the lower bound (first possible position) and upper bound (first position after the last occurrence):

```python-execute
def lower_bound(arr, target):
    """Find the first position where target could be inserted (first occurrence or insertion point)"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """Find the first position after target (last occurrence + 1 or insertion point)"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:  # Note: <= instead of <
            left = mid + 1
        else:
            right = mid
    
    return left

# Demonstrate with duplicates
test_array = [1, 2, 2, 2, 4, 4, 4, 4, 6, 8]
print(f"Array: {test_array}")
print(f"Indices: {list(range(len(test_array)))}")
print()

targets = [2, 4, 5, 0, 10]
for target in targets:
    lower = lower_bound(test_array, target)
    upper = upper_bound(test_array, target)
    
    print(f"Target {target}:")
    print(f"  Lower bound (first position): {lower}")
    print(f"  Upper bound (after last): {upper}")
    
    if lower < len(test_array) and test_array[lower] == target:
        print(f"  Range: indices {lower} to {upper-1}")
        print(f"  Count: {upper - lower} occurrences")
    else:
        print(f"  Not found, would insert at index {lower}")
    print()
```

## Practical Application: Range Queries

Let's see how lower and upper bounds work together to solve practical problems:

```python-execute
def lower_bound(arr, target):
    """Find the first position where target could be inserted"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """Find the first position after target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left

def count_in_range(arr, min_val, max_val):
    """Count how many elements are in the range [min_val, max_val]"""
    left_bound = lower_bound(arr, min_val)
    right_bound = upper_bound(arr, max_val)
    return right_bound - left_bound

def find_value_range(arr, target):
    """Find the complete range of indices where target appears"""
    left_bound = lower_bound(arr, target)
    right_bound = upper_bound(arr, target)
    
    if left_bound < len(arr) and arr[left_bound] == target:
        return (left_bound, right_bound - 1)  # Convert to inclusive range
    else:
        return None  # Target not found

# Test with sample data
data = [1, 3, 3, 3, 5, 5, 7, 9, 9, 9, 9, 11, 13]
print(f"Data: {data}")
print()

# Count elements in different ranges
print("Counting elements in ranges:")
ranges = [(3, 7), (5, 9), (1, 5)]
for min_val, max_val in ranges:
    count = count_in_range(data, min_val, max_val)
    print(f"  Range [{min_val}, {max_val}]: {count} elements")

print()

# Find where specific values appear
print("Finding value ranges:")
targets = [3, 9, 6]
for target in targets:
    range_result = find_value_range(data, target)
    if range_result:
        start, end = range_result
        print(f"  Value {target}: indices {start} to {end}")
    else:
        print(f"  Value {target}: not found")
```

```quiz
id: bounds-understanding
question: "What's the difference between `lower_bound` and `upper_bound` for the same target?"
options:
  - id: a
    text: "Lower bound finds the first occurrence, upper bound finds the last occurrence"
    correct: false
    explanation: "Upper bound actually finds the position AFTER the last occurrence, not the last occurrence itself."
  - id: b
    text: "Lower bound finds the first possible position, upper bound finds the first position after the target"
    correct: true
    explanation: "Correct! Upper bound points to where the next larger element would go, which is one position after the last occurrence of the target."
  - id: c
    text: "They're the same when there are no duplicates"
    correct: false
    explanation: "Even without duplicates, upper bound is always one position after lower bound."
  - id: d
    text: "Lower bound uses `<=` comparison, upper bound uses `<` comparison"
    correct: false
    explanation: "It's the opposite: lower bound uses `<`, while upper bound uses `<=` in the comparison logic."
```

## Edge Cases and Boundary Conditions

Mastering binary search variations requires handling edge cases correctly. Let's explore the most common pitfalls:

```danger title="Common Binary Search Pitfalls"
1. **Integer overflow**: `(left + right) // 2` can overflow with very large numbers. Use `left + (right - left) // 2` instead.
2. **Infinite loops**: Wrong boundary conditions can cause infinite loops. Pay attention to when to use `<=` vs `<`.
3. **Off-by-one errors**: Especially common when working with insertion points and ranges.
```

## Practice Exercise: Implement First Occurrence Finder

```exercise
id: first-occurrence-finder
title: Find First Occurrence
description: Implement a function that finds the first occurrence of a target in a sorted array with duplicates. Return -1 if the target is not found.
difficulty: medium
starterCode: |
  def find_first_occurrence(arr, target):
      """
      Find the index of the first occurrence of target in sorted array arr.
      Return -1 if target is not found.
      
      Example:
      arr = [1, 2, 2, 2, 3, 4]
      find_first_occurrence(arr, 2) should return 1
      """
      # Your code here
      pass
postpend: |
  # Test the function
  arr_str = input().strip()
  target = int(input().strip())
  arr = eval(arr_str)
  result = find_first_occurrence(arr, target)
  print(result)
testCases:
  - input: "[1, 2, 2, 2, 3, 4]\n2"
    expectedOutput: "1"
  - input: "[1, 2, 3, 4]\n5"
    expectedOutput: "-1"
  - input: "[1, 3, 5, 7, 9]\n5"
    expectedOutput: "2"
    hidden: true
  - input: "[1, 1, 1, 1]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[]\n1"
    expectedOutput: "-1"
    hidden: true
  - input: "[5]\n5"
    expectedOutput: "0"
    hidden: true
  - input: "[5]\n3"
    expectedOutput: "-1"
    hidden: true
  - input: "[1, 2, 3, 3, 3, 4, 5]\n3"
    expectedOutput: "2"
    hidden: true
  - input: "[10, 20, 20, 30, 30, 30, 40]\n30"
    expectedOutput: "3"
    hidden: true
  - input: "[7, 7, 7, 7, 7]\n7"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10"
    expectedOutput: "9"
    hidden: true
  - input: "[2, 4, 6, 8, 10, 12, 14]\n7"
    expectedOutput: "-1"
    hidden: true
  - input: "[-5, -3, -1, 0, 1, 3, 5]\n-3"
    expectedOutput: "1"
    hidden: true
  - input: "[0, 0, 0, 1, 1, 1, 2, 2, 2]\n0"
    expectedOutput: "0"
    hidden: true
hints:
  - "When you find the target, don't return immediately - keep searching in the left half"
  - "Remember to store the result when you find a match"
  - "Use the pattern: if arr[mid] == target, set result = mid and search left"
solution: |
  def find_first_occurrence(arr, target):
      left, right = 0, len(arr) - 1
      result = -1
      
      while left <= right:
          mid = (left + right) // 2
          
          if arr[mid] == target:
              result = mid
              right = mid - 1  # Continue searching left
          elif arr[mid] < target:
              left = mid + 1
          else:
              right = mid - 1
      
      return result
```

## Key Takeaways

- **Basic binary search** works well for unique elements but is unpredictable with duplicates
- **First occurrence search** requires continuing to search left even after finding the target
- **Last occurrence search** requires continuing to search right even after finding the target
- **Insertion point search** uses slightly different boundary conditions (`right = len(arr)` and `left < right`)
- **Lower and upper bounds** provide powerful range query capabilities
- **Edge cases** require careful attention to boundary conditions and empty arrays

These binary search variations are the building blocks for more advanced algorithms. In the next section, we'll explore how to use binary search on answer spaces rather than just sorted arrays!
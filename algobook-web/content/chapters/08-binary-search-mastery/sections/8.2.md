# Binary Search Variations: Handling Duplicates and Boundaries

Section 8.1 presented binary search for arrays with unique elements. However, real applications frequently involve sorted data with duplicate values, requiring algorithmic modifications to control which occurrence is found and to locate insertion boundaries.

This section examines binary search variations that handle duplicates systematically, establishing the theoretical foundation for boundary detection and range query algorithms.

## Learning Objectives

- Analyze binary search behavior with duplicate elements
- Implement algorithms for finding first and last occurrences
- Develop insertion point and boundary detection techniques
- Apply unified bounds theory to range query problems

## Binary Search with Duplicate Elements

Standard binary search exhibits undefined behavior when multiple copies of the target value exist. While the algorithm correctly locates some occurrence, it provides no guarantee about which specific instance is returned:

```python-execute
def basic_binary_search(arr, target):
    left, right = 0, len(arr) - 1

    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Demonstrate unpredictable behavior with duplicates
numbers = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
result = basic_binary_search(numbers, 2)
print(f"Found value 2 at index {result}")  # Could be index 1, 2, 3, or 4
```

```note title="Deterministic but Unpredictable Results"
Standard binary search produces deterministic results—it always returns the same index for identical inputs—but which occurrence it finds among duplicates depends on the algorithm's internal decision path. Applications requiring specific occurrences need specialized algorithms.
```

## First Occurrence Detection

Many applications require finding the leftmost occurrence of a target value among duplicates. This variation modifies the standard algorithm to continue searching in the left subarray even after finding a match:

```python-execute
def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid  # Record position, continue searching left
            right = mid - 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Test with duplicate array
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(find_first_occurrence(test_array, 2))  # Returns 1
print(find_first_occurrence(test_array, 5))  # Returns 7
```

The critical modification occurs when `arr[mid] == target`: instead of returning immediately, the algorithm records the current position and continues searching the left subarray for potentially earlier occurrences.

## Last Occurrence Detection

Last occurrence detection applies the symmetric approach, searching the right subarray after finding a match:

```python-execute
def find_last_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1

    while left <= right:
        mid = (left + right) // 2

        if arr[mid] == target:
            result = mid  # Record position, continue searching right
            left = mid + 1
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1

    return result

# Demonstrate symmetric behavior
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(find_last_occurrence(test_array, 2))  # Returns 4
print(find_last_occurrence(test_array, 5))  # Returns 9
```

Both variations follow the same pattern: continue searching in the appropriate direction even after finding the target. This establishes the fundamental principle for boundary detection algorithms.

```quiz
id: first-last-occurrence
question: "When finding the LAST occurrence of a target in an array with duplicates, what should you do after finding a match at the middle position?"
options:
  - id: a
    text: "Stop immediately and return the current position"
    correct: false
    explanation: "If you stop immediately, you might miss later occurrences of the same value."
  - id: b
    text: "Continue searching in the right half to see if there's a later occurrence"
    correct: true
    explanation: "Correct! To find the rightmost occurrence, you need to keep searching in the right half even after finding a match, in case there are more copies of the target further right."
  - id: c
    text: "Continue searching in the left half to find earlier occurrences"
    correct: false
    explanation: "Searching left would help find the first occurrence, not the last one."
  - id: d
    text: "Search both halves simultaneously"
    correct: false
    explanation: "Binary search works by eliminating half the search space at each step, not searching both halves."
```

## Insertion Point Detection

Applications requiring sorted order maintenance need algorithms that determine insertion positions for new elements. This variation uses modified boundary conditions to handle positions beyond the array's current bounds:

```python-execute
def find_insertion_point(arr, target):
    left, right = 0, len(arr)  # right = len(arr) to allow end insertion

    while left < right:  # left < right to handle boundary properly
        mid = (left + right) // 2

        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left

# Test insertion points
test_array = [1, 3, 5, 7, 9, 11]
print(find_insertion_point(test_array, 0))   # Returns 0 (beginning)
print(find_insertion_point(test_array, 4))   # Returns 2 (between 3 and 5)
print(find_insertion_point(test_array, 12))  # Returns 6 (end)
```

The key differences from occurrence-finding algorithms are the boundary conditions: `right = len(arr)` enables insertion at the array's end, while `left < right` prevents accessing out-of-bounds indices.

## Unified Bounds Theory

The previous algorithms can be generalized into a unified framework using lower and upper bound functions. These functions provide the theoretical foundation for all boundary detection problems:

```python-execute
def lower_bound(arr, target):
    """Find the first position where target could be inserted"""
    left, right = 0, len(arr)

    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid

    return left

def upper_bound(arr, target):
    """Find the first position after target"""
    left, right = 0, len(arr)

    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:  # Key difference: <= instead of <
            left = mid + 1
        else:
            right = mid

    return left

# Demonstrate unified approach
test_array = [1, 2, 2, 2, 4, 4, 4, 4, 6, 8]
target = 4

lower = lower_bound(test_array, target)
upper = upper_bound(test_array, target)

print(f"Target {target}: bounds [{lower}, {upper})")  # Half-open interval
if lower < len(test_array) and test_array[lower] == target:
    print(f"Range: indices {lower} to {upper-1} (inclusive)")
    print(f"Count: {upper - lower}")
```

These bounds relate to previous algorithms:
- **First occurrence** = `lower_bound(arr, target)` when target exists
- **Last occurrence** = `upper_bound(arr, target) - 1` when target exists
- **Insertion point** = `lower_bound(arr, target)` always

## Range Query Applications

The unified bounds framework enables efficient range operations on sorted data:

```python-execute
def count_in_range(arr, min_val, max_val):
    """Count elements in range [min_val, max_val] using bounds"""
    return upper_bound(arr, max_val) - lower_bound(arr, min_val)

def find_value_range(arr, target):
    """Find complete range where target appears"""
    left_bound = lower_bound(arr, target)
    right_bound = upper_bound(arr, target)

    if left_bound < len(arr) and arr[left_bound] == target:
        return (left_bound, right_bound - 1)  # Inclusive range
    return None

# Application examples
data = [1, 3, 3, 3, 5, 5, 7, 9, 9, 9, 9, 11, 13]

print(count_in_range(data, 3, 7))    # Count elements in [3, 7]: 7
print(find_value_range(data, 9))     # Range for 9: (7, 10)
print(find_value_range(data, 6))     # Range for 6: None
```

Range queries demonstrate the power of bounds-based algorithms: complex operations reduce to simple arithmetic on boundary positions.

```quiz
id: bounds-understanding
question: "What's the difference between `lower_bound` and `upper_bound` for the same target?"
options:
  - id: a
    text: "Lower bound finds the first occurrence, upper bound finds the last occurrence"
    correct: false
    explanation: "Upper bound actually finds the position AFTER the last occurrence, not the last occurrence itself."
  - id: b
    text: "Lower bound finds the first possible position, upper bound finds the first position after the target"
    correct: true
    explanation: "Correct! Upper bound points to where the next larger element would go, which is one position after the last occurrence of the target."
  - id: c
    text: "They're the same when there are no duplicates"
    correct: false
    explanation: "Even without duplicates, upper bound is always one position after lower bound."
  - id: d
    text: "Lower bound uses `<=` comparison, upper bound uses `<` comparison"
    correct: false
    explanation: "It's the opposite: lower bound uses `<`, while upper bound uses `<=` in the comparison logic."
```

## Practice Exercise: Implement First Occurrence Finder

```exercise
id: first-occurrence-finder
title: Find First Occurrence
description: Implement a function that finds the first occurrence of a target in a sorted array with duplicates. Return -1 if the target is not found.
difficulty: medium
starterCode: |
  def find_first_occurrence(arr, target):
      """
      Find the index of the first occurrence of target in sorted array arr.
      Return -1 if target is not found.
      
      Example:
      arr = [1, 2, 2, 2, 3, 4]
      find_first_occurrence(arr, 2) should return 1
      """
      # Your code here
      pass
postpend: |
  # Test the function
  arr_str = input().strip()
  target = int(input().strip())
  arr = eval(arr_str)
  result = find_first_occurrence(arr, target)
  print(result)
testCases:
  - input: "[1, 2, 2, 2, 3, 4]\n2"
    expectedOutput: "1"
  - input: "[1, 2, 3, 4]\n5"
    expectedOutput: "-1"
  - input: "[1, 3, 5, 7, 9]\n5"
    expectedOutput: "2"
    hidden: true
  - input: "[1, 1, 1, 1]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[]\n1"
    expectedOutput: "-1"
    hidden: true
  - input: "[5]\n5"
    expectedOutput: "0"
    hidden: true
  - input: "[5]\n3"
    expectedOutput: "-1"
    hidden: true
  - input: "[1, 2, 3, 3, 3, 4, 5]\n3"
    expectedOutput: "2"
    hidden: true
  - input: "[10, 20, 20, 30, 30, 30, 40]\n30"
    expectedOutput: "3"
    hidden: true
  - input: "[7, 7, 7, 7, 7]\n7"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10"
    expectedOutput: "9"
    hidden: true
  - input: "[2, 4, 6, 8, 10, 12, 14]\n7"
    expectedOutput: "-1"
    hidden: true
  - input: "[-5, -3, -1, 0, 1, 3, 5]\n-3"
    expectedOutput: "1"
    hidden: true
  - input: "[0, 0, 0, 1, 1, 1, 2, 2, 2]\n0"
    expectedOutput: "0"
    hidden: true
hints:
  - "When you find the target, don't return immediately - keep searching in the left half"
  - "Remember to store the result when you find a match"
  - "Use the pattern: if arr[mid] == target, set result = mid and search left"
solution: |
  def find_first_occurrence(arr, target):
      left, right = 0, len(arr) - 1
      result = -1
      
      while left <= right:
          mid = (left + right) // 2
          
          if arr[mid] == target:
              result = mid
              right = mid - 1  # Continue searching left
          elif arr[mid] < target:
              left = mid + 1
          else:
              right = mid - 1
      
      return result
```

This section established the theoretical framework for binary search variations through progressive development from simple occurrence detection to unified bounds theory. The lower and upper bound functions provide the foundation for all boundary detection algorithms, with specific variations emerging as special cases of this general framework.

Section 8.3 extends these principles to optimization problems where binary search operates on answer spaces rather than explicit sorted arrays.
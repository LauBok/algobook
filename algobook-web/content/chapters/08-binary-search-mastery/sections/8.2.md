# Binary Search Variations: Beyond Simple Search

The basic binary search you mastered in the previous section is just the beginning. Real-world problems often require more sophisticated variations that can handle duplicates, find boundaries, and locate insertion points. Today, you'll learn the advanced binary search techniques that separate beginners from experts.

## Learning Objectives

- Master binary search variants for handling duplicates
- Implement boundary-finding algorithms (first/last occurrence)
- Understand insertion point searches and their applications
- Handle edge cases systematically in binary search problems

## The Duplicate Problem

The classic binary search works perfectly when all elements are unique, but what happens when your sorted array contains duplicate values? Let's explore this challenge:

```python-execute
# Array with duplicates - a common real-world scenario
numbers = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(f"Array: {numbers}")
print(f"Indices: {list(range(len(numbers)))}")

# Basic binary search on duplicates
def basic_binary_search(arr, target):
    left, right = 0, len(arr) - 1
    
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1

# Test multiple searches for the same value
target = 2
print(f"\nSearching for {target} multiple times:")
for i in range(5):
    result = basic_binary_search(numbers, target)
    print(f"Search {i+1}: Found at index {result}")
```

```note title="Arbitrary Results with Duplicates"
While basic binary search will consistently return the same index for the same array and target, when there are duplicates, you can't predict WHICH occurrence it will find. It might return index 1, 2, 3, or 4 for the value 2, but it will always return the same one. When you need the first or last occurrence specifically, you need specialized algorithms.
```

```table
title: Binary Search Variations Overview
headers: ["Variation", "Goal", "Key Difference", "When to Use"]
rows:
  - ["Basic Search", "Find any occurrence", "Return immediately when found", "Unique elements only"]
  - ["First Occurrence", "Find leftmost match", "Continue searching left after finding", "Need earliest occurrence"]
  - ["Last Occurrence", "Find rightmost match", "Continue searching right after finding", "Need latest occurrence"]
  - ["Insertion Point", "Find where to insert", "Different boundary conditions", "Maintaining sorted order"]
  - ["Lower Bound", "First possible position", "Find leftmost valid position", "Range queries"]
  - ["Upper Bound", "After last occurrence", "Find first position after target", "Range queries"]
caption: Each variation serves a specific purpose in handling duplicates and boundaries
sortable: false
```

## Finding the First Occurrence

When dealing with duplicates, you often want to find the **first** (leftmost) occurrence of a target value. This is crucial for applications like finding the start of a range or the earliest occurrence of an event.

```python-execute
def find_first_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid  # Record this position, but keep searching left
            right = mid - 1  # Continue searching in the left half
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test with our duplicate array
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(f"Array: {test_array}")

for target in [2, 5, 7]:
    first_pos = find_first_occurrence(test_array, target)
    if first_pos != -1:
        print(f"First occurrence of {target}: index {first_pos}")
    else:
        print(f"{target} not found")
```

```hint title="Key Insight: Keep Searching After Finding"
The crucial difference is that when we find the target, we don't immediately return. Instead, we record the position and continue searching in the left half to see if there's an earlier occurrence.
```

## Finding the Last Occurrence

Similarly, you might want to find the **last** (rightmost) occurrence of a target value:

```python-execute
def find_last_occurrence(arr, target):
    left, right = 0, len(arr) - 1
    result = -1
    
    while left <= right:
        mid = (left + right) // 2
        
        if arr[mid] == target:
            result = mid  # Record this position, but keep searching right
            left = mid + 1  # Continue searching in the right half
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    
    return result

# Test finding last occurrence
test_array = [1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 6]
print(f"Array: {test_array}")

targets = [2, 5, 7]
for target in targets:
    last = find_last_occurrence(test_array, target)
    if last != -1:
        print(f"Last occurrence of {target}: index {last}")
    else:
        print(f"{target} not found")
```

```quiz
id: first-last-occurrence
question: "When finding the LAST occurrence of a target in an array with duplicates, what should you do after finding a match at the middle position?"
options:
  - id: a
    text: "Stop immediately and return the current position"
    correct: false
    explanation: "If you stop immediately, you might miss later occurrences of the same value."
  - id: b
    text: "Continue searching in the right half to see if there's a later occurrence"
    correct: true
    explanation: "Correct! To find the rightmost occurrence, you need to keep searching in the right half even after finding a match, in case there are more copies of the target further right."
  - id: c
    text: "Continue searching in the left half to find earlier occurrences"
    correct: false
    explanation: "Searching left would help find the first occurrence, not the last one."
  - id: d
    text: "Search both halves simultaneously"
    correct: false
    explanation: "Binary search works by eliminating half the search space at each step, not searching both halves."
```

## Finding Insertion Points

Sometimes you don't need to find an exact match - you need to find where a value should be inserted to maintain sorted order. This is the foundation of algorithms like insertion sort and binary insertion.

```python-execute
def find_insertion_point(arr, target):
    """
    Find the index where target should be inserted to maintain sorted order.
    Returns the leftmost position where target could be inserted.
    """
    left, right = 0, len(arr)  # Note: right = len(arr), not len(arr) - 1
    
    while left < right:  # Note: left < right, not left <= right
        mid = (left + right) // 2
        
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid  # Don't exclude mid, as it could be the insertion point
    
    return left

# Demonstrate insertion points
test_array = [1, 3, 5, 7, 9, 11]
print(f"Array: {test_array}")
print(f"Indices: {list(range(len(test_array)))}")
print()

test_values = [0, 2, 4, 6, 8, 10, 12]
for value in test_values:
    insertion_point = find_insertion_point(test_array, value)
    print(f"Insert {value} at index {insertion_point}")
    
    # Show what the array would look like
    new_array = test_array[:insertion_point] + [value] + test_array[insertion_point:]
    print(f"Result: {new_array}")
    print()
```

```warning title="Different Boundary Conditions"
Notice that insertion point search uses slightly different boundary conditions: `right = len(arr)` initially and `left < right` in the loop. This allows us to find positions at the very end of the array.
```

## Lower and Upper Bounds

In many applications, you need to find the range where a value could appear. This involves finding both the lower bound (first possible position) and upper bound (first position after the last occurrence):

```python-execute
def lower_bound(arr, target):
    """Find the first position where target could be inserted (first occurrence or insertion point)"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """Find the first position after target (last occurrence + 1 or insertion point)"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:  # Note: <= instead of <
            left = mid + 1
        else:
            right = mid
    
    return left

# Demonstrate with duplicates
test_array = [1, 2, 2, 2, 4, 4, 4, 4, 6, 8]
print(f"Array: {test_array}")
print(f"Indices: {list(range(len(test_array)))}")
print()

targets = [2, 4, 5, 0, 10]
for target in targets:
    lower = lower_bound(test_array, target)
    upper = upper_bound(test_array, target)
    
    print(f"Target {target}:")
    print(f"  Lower bound (first position): {lower}")
    print(f"  Upper bound (after last): {upper}")
    
    if lower < len(test_array) and test_array[lower] == target:
        print(f"  Range: indices {lower} to {upper-1}")
        print(f"  Count: {upper - lower} occurrences")
    else:
        print(f"  Not found, would insert at index {lower}")
    print()
```

## Practical Application: Range Queries

Let's see how lower and upper bounds work together to solve practical problems:

```python-execute
def lower_bound(arr, target):
    """Find the first position where target could be inserted"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] < target:
            left = mid + 1
        else:
            right = mid
    
    return left

def upper_bound(arr, target):
    """Find the first position after target"""
    left, right = 0, len(arr)
    
    while left < right:
        mid = (left + right) // 2
        if arr[mid] <= target:
            left = mid + 1
        else:
            right = mid
    
    return left

def count_in_range(arr, min_val, max_val):
    """Count how many elements are in the range [min_val, max_val]"""
    left_bound = lower_bound(arr, min_val)
    right_bound = upper_bound(arr, max_val)
    return right_bound - left_bound

def find_value_range(arr, target):
    """Find the complete range of indices where target appears"""
    left_bound = lower_bound(arr, target)
    right_bound = upper_bound(arr, target)
    
    if left_bound < len(arr) and arr[left_bound] == target:
        return (left_bound, right_bound - 1)  # Convert to inclusive range
    else:
        return None  # Target not found

# Test with sample data
data = [1, 3, 3, 3, 5, 5, 7, 9, 9, 9, 9, 11, 13]
print(f"Data: {data}")
print()

# Count elements in different ranges
print("Counting elements in ranges:")
ranges = [(3, 7), (5, 9), (1, 5)]
for min_val, max_val in ranges:
    count = count_in_range(data, min_val, max_val)
    print(f"  Range [{min_val}, {max_val}]: {count} elements")

print()

# Find where specific values appear
print("Finding value ranges:")
targets = [3, 9, 6]
for target in targets:
    range_result = find_value_range(data, target)
    if range_result:
        start, end = range_result
        print(f"  Value {target}: indices {start} to {end}")
    else:
        print(f"  Value {target}: not found")
```

```quiz
id: bounds-understanding
question: "What's the difference between `lower_bound` and `upper_bound` for the same target?"
options:
  - id: a
    text: "Lower bound finds the first occurrence, upper bound finds the last occurrence"
    correct: false
    explanation: "Upper bound actually finds the position AFTER the last occurrence, not the last occurrence itself."
  - id: b
    text: "Lower bound finds the first possible position, upper bound finds the first position after the target"
    correct: true
    explanation: "Correct! Upper bound points to where the next larger element would go, which is one position after the last occurrence of the target."
  - id: c
    text: "They're the same when there are no duplicates"
    correct: false
    explanation: "Even without duplicates, upper bound is always one position after lower bound."
  - id: d
    text: "Lower bound uses `<=` comparison, upper bound uses `<` comparison"
    correct: false
    explanation: "It's the opposite: lower bound uses `<`, while upper bound uses `<=` in the comparison logic."
```

## Edge Cases and Boundary Conditions

Mastering binary search variations requires handling edge cases correctly. Let's explore the most common pitfalls:

```danger title="Common Binary Search Pitfalls"
1. **Integer overflow**: `(left + right) // 2` can overflow with very large numbers. Use `left + (right - left) // 2` instead.
2. **Infinite loops**: Wrong boundary conditions can cause infinite loops. Pay attention to when to use `<=` vs `<`.
3. **Off-by-one errors**: Especially common when working with insertion points and ranges.
```

## Practice Exercise: Implement First Occurrence Finder

```exercise
id: first-occurrence-finder
title: Find First Occurrence
description: Implement a function that finds the first occurrence of a target in a sorted array with duplicates. Return -1 if the target is not found.
difficulty: medium
starterCode: |
  def find_first_occurrence(arr, target):
      """
      Find the index of the first occurrence of target in sorted array arr.
      Return -1 if target is not found.
      
      Example:
      arr = [1, 2, 2, 2, 3, 4]
      find_first_occurrence(arr, 2) should return 1
      """
      # Your code here
      pass
postpend: |
  # Test the function
  arr_str = input().strip()
  target = int(input().strip())
  arr = eval(arr_str)
  result = find_first_occurrence(arr, target)
  print(result)
testCases:
  - input: "[1, 2, 2, 2, 3, 4]\n2"
    expectedOutput: "1"
  - input: "[1, 2, 3, 4]\n5"
    expectedOutput: "-1"
  - input: "[1, 3, 5, 7, 9]\n5"
    expectedOutput: "2"
    hidden: true
  - input: "[1, 1, 1, 1]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[]\n1"
    expectedOutput: "-1"
    hidden: true
  - input: "[5]\n5"
    expectedOutput: "0"
    hidden: true
  - input: "[5]\n3"
    expectedOutput: "-1"
    hidden: true
  - input: "[1, 2, 3, 3, 3, 4, 5]\n3"
    expectedOutput: "2"
    hidden: true
  - input: "[10, 20, 20, 30, 30, 30, 40]\n30"
    expectedOutput: "3"
    hidden: true
  - input: "[7, 7, 7, 7, 7]\n7"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n1"
    expectedOutput: "0"
    hidden: true
  - input: "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n10"
    expectedOutput: "9"
    hidden: true
  - input: "[2, 4, 6, 8, 10, 12, 14]\n7"
    expectedOutput: "-1"
    hidden: true
  - input: "[-5, -3, -1, 0, 1, 3, 5]\n-3"
    expectedOutput: "1"
    hidden: true
  - input: "[0, 0, 0, 1, 1, 1, 2, 2, 2]\n0"
    expectedOutput: "0"
    hidden: true
hints:
  - "When you find the target, don't return immediately - keep searching in the left half"
  - "Remember to store the result when you find a match"
  - "Use the pattern: if arr[mid] == target, set result = mid and search left"
solution: |
  def find_first_occurrence(arr, target):
      left, right = 0, len(arr) - 1
      result = -1
      
      while left <= right:
          mid = (left + right) // 2
          
          if arr[mid] == target:
              result = mid
              right = mid - 1  # Continue searching left
          elif arr[mid] < target:
              left = mid + 1
          else:
              right = mid - 1
      
      return result
```

## Key Takeaways

- **Basic binary search** works well for unique elements but is unpredictable with duplicates
- **First occurrence search** requires continuing to search left even after finding the target
- **Last occurrence search** requires continuing to search right even after finding the target
- **Insertion point search** uses slightly different boundary conditions (`right = len(arr)` and `left < right`)
- **Lower and upper bounds** provide powerful range query capabilities
- **Edge cases** require careful attention to boundary conditions and empty arrays

These binary search variations are the building blocks for more advanced algorithms. In the next section, we'll explore how to use binary search on answer spaces rather than just sorted arrays!
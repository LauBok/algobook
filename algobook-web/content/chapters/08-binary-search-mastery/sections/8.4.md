# Advanced Binary Search: Multidimensional and Modified Spaces

Binary search principles extend beyond simple sorted arrays to multidimensional spaces and data structures with modified monotonic properties. These applications demonstrate the algorithmic flexibility of systematic elimination.

## Learning Objectives

- Apply elimination principles to multidimensional search spaces
- Analyze modified monotonic properties in rotated and peak-finding problems
- Develop systematic approaches for recognizing binary search variants
- Synthesize multiple concepts in complex optimization problems

## Multidimensional Search Spaces

When binary search principles apply to higher-dimensional spaces, the key insight remains systematic elimination. For 2D matrices with monotonic properties, we can eliminate entire rows or columns at each step.

### Staircase Search Algorithm

For matrices sorted both row-wise and column-wise, the **staircase search** provides optimal $O(m + n)$ performance by starting from a corner position where comparisons enable definitive elimination.

```note title="Staircase Search Principle"
Starting from the top-right corner of a row/column sorted matrix:
- If current element > target: eliminate entire column (move left)
- If current element < target: eliminate entire row (move down)
- If current element = target: element found

This guarantees elimination of at least one row or column per comparison.
```

```python-execute
def search_2d_matrix(matrix, target):
    """Search in row-wise and column-wise sorted matrix using staircase approach."""
    if not matrix or not matrix[0]:
        return False

    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1  # Start from top-right corner

    while row < rows and col >= 0:
        current = matrix[row][col]

        if current == target:
            return True
        elif current > target:
            col -= 1  # Eliminate column
        else:
            row += 1  # Eliminate row

    return False

# Test with row/column sorted matrix
matrix = [
    [1,  4,  7,  11, 15],
    [2,  5,  8,  12, 19],
    [3,  6,  9,  16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

print(f"Search for 5: {search_2d_matrix(matrix, 5)}")
print(f"Search for 14: {search_2d_matrix(matrix, 14)}")
print(f"Search for 25: {search_2d_matrix(matrix, 25)}")
```

### Alternative Approaches

For **globally sorted matrices** (where each row's first element > previous row's last element), we can treat the matrix as a flattened 1D array and apply standard binary search with coordinate conversion:

```python
# Convert between 1D and 2D coordinates
# 1D to 2D: row = index // cols, col = index % cols
# 2D to 1D: index = row * cols + col
```

For matrices with **only row-wise sorting**, binary search on each potentially relevant row yields $O(m \log n)$ complexity.

```quiz
id: matrix-approach-selection
question: "For a matrix sorted both row-wise and column-wise (but not globally), why does staircase search from the top-right corner guarantee optimal elimination?"
options:
  - id: a
    text: "Because it checks all elements systematically"
    correct: false
    explanation: "Staircase search doesn't check all elements - it eliminates entire rows or columns based on comparisons."
  - id: b
    text: "Because from top-right, each comparison can eliminate either a full row or full column"
    correct: true
    explanation: "Correct! From the top-right corner, if current > target, eliminate the column (all elements in column are ≥ current). If current < target, eliminate the row (all elements in row are ≤ current)."
  - id: c
    text: "Because it uses binary search on each row"
    correct: false
    explanation: "Staircase search moves through the matrix systematically, not using binary search within rows."
  - id: d
    text: "Because corners always contain extreme values"
    correct: false
    explanation: "The effectiveness comes from the elimination property, not from corner values being extreme."
```

## Modified Monotonic Properties

Binary search adapts to data structures where monotonic properties are modified but systematic elimination remains possible.

### Rotated Sorted Arrays

A rotated sorted array contains two contiguous sorted subarrays. The key insight: at any midpoint, at least one half maintains standard sorted order.

```note title="Rotated Array Strategy"
A rotated sorted array contains two sorted subarrays. At any midpoint:

1. **Identify the normally sorted half**: Compare `nums[left]`, `nums[mid]`, `nums[right]`
   - If `nums[left] ≤ nums[mid]`: left half `[left...mid]` is normally sorted
   - Otherwise: right half `[mid...right]` is normally sorted

2. **Check if target is in the sorted half's range**
   - If yes: search the sorted half
   - If no: search the other half (which contains the rotation point)
```

```python-execute
def search_rotated_array(nums, target):
    """Search in rotated sorted array by identifying sorted half."""
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2

        if nums[mid] == target:
            return mid

        # Determine which half is sorted
        if nums[left] <= nums[mid]:  # Left half is sorted
            if nums[left] <= target < nums[mid]:
                right = mid - 1  # Target in sorted left half
            else:
                left = mid + 1   # Target in right half
        else:  # Right half is sorted
            if nums[mid] < target <= nums[right]:
                left = mid + 1   # Target in sorted right half
            else:
                right = mid - 1  # Target in left half

    return -1

# Test with rotated arrays
rotated = [4, 5, 6, 7, 0, 1, 2]
print(f"Search for 0: {search_rotated_array(rotated, 0)}")
print(f"Search for 3: {search_rotated_array(rotated, 3)}")
print(f"Search for 5: {search_rotated_array(rotated, 5)}")
```

### Peak Finding

Peak finding demonstrates binary search on **local properties** rather than global ordering. A peak element is greater than its neighbors.

```note title="Peak Finding Strategy"
In an array where adjacent elements are never equal:
- If `nums[mid] > nums[mid + 1]`: peak exists in left half (including mid)
- If `nums[mid] < nums[mid + 1]`: peak exists in right half
- Follow ascending slopes to guarantee reaching a peak
```

```python-execute
def find_peak_element(nums):
    """Find any peak element using slope-following binary search."""
    left, right = 0, len(nums) - 1

    while left < right:
        mid = (left + right) // 2

        if nums[mid] > nums[mid + 1]:
            # Descending slope, peak in left half
            right = mid
        else:
            # Ascending slope, peak in right half
            left = mid + 1

    return left

# Test peak finding
test_arrays = [
    [1, 2, 3, 1],
    [1, 2, 1, 3, 5, 6, 4],
    [1, 2, 3, 4, 5]  # Peak at end
]

for arr in test_arrays:
    peak_idx = find_peak_element(arr)
    print(f"Array: {arr}")
    print(f"Peak at index {peak_idx}, value: {arr[peak_idx]}")
    print()
```

### Problem Analysis Framework

When encountering complex binary search problems, systematic analysis identifies the appropriate approach:

```table
title: "Binary Search Variant Recognition"
headers: ["Problem Type", "Key Property", "Elimination Strategy", "Example"]
rows:
  - ["Standard Search", "Global sorted order", "Compare with target", "Find element in sorted array"]
  - ["Boundary Search", "Range identification", "Include boundaries in updates", "First/last occurrence"]
  - ["Answer Space", "Monotonic feasibility", "Validation function", "Minimum ship capacity"]
  - ["2D Matrix", "Row/column ordering", "Eliminate rows/columns", "Staircase search"]
  - ["Rotated Array", "Partial sorted halves", "Identify sorted half", "Search in rotated array"]
  - ["Peak Finding", "Local comparison", "Follow slopes", "Find local maximum"]
caption: Match problem characteristics to appropriate binary search variant
sortable: false
```

```note title="Analysis Questions"
1. **What structure does the data have?** (sorted, partially sorted, monotonic property)
2. **What are we searching for?** (exact element, boundary, optimal value, local property)
3. **How can we eliminate half the space?** (comparison logic, elimination rule)
4. **What are the edge cases?** (empty arrays, single elements, boundary conditions)
```

## Complex Application: Unknown Size Array Search

```exercise
id: search-unknown-size
title: Search in Array of Unknown Size
description: Search for a target in a sorted array where the size is unknown. You have access to a get(index) function that returns the value at index or -1 if out of bounds. This problem combines exponential search with binary search.
difficulty: hard
prepend: |
  # Test array setup - students don't need to see this
  test_arrays = {
      1: [4, 6, 8, 10, 12, 14, 16, 18, 20],
      2: [1, 3, 5, 7, 9],
      3: [2, 4, 6],
      4: [10],
      5: list(range(2, 20002, 2)),
      6: list(range(1, 15001)),
      7: list(range(100, 25001, 5)),
  }

  def create_get_func(arr):
      def get_func(index):
          return arr[index] if 0 <= index < len(arr) else -1
      return get_func
starterCode: |
  def search_unknown_size(get_func, target):
      """
      Two-phase approach:
      1. Exponential search to find bounds
      2. Binary search within bounds

      Key insight: Treat -1 as "larger than any valid element"
      """
      # Phase 1: Find upper bound using exponential search
      # Phase 2: Binary search between bounds
      # Your code here
      pass
postpend: |
  test_case = int(input().strip())
  target = int(input().strip())

  test_array = test_arrays[test_case]
  get_func = create_get_func(test_array)
  result = search_unknown_size(get_func, target)
  print(result)
testCases:
  - input: "1\n8"
    expectedOutput: "2"
  - input: "1\n4"
    expectedOutput: "0"
    hidden: true
  - input: "1\n25"
    expectedOutput: "-1"
    hidden: true
  - input: "2\n7"
    expectedOutput: "3"
    hidden: true
  - input: "3\n6"
    expectedOutput: "2"
    hidden: true
  - input: "4\n10"
    expectedOutput: "0"
    hidden: true
  - input: "5\n10000"
    expectedOutput: "4999"
    hidden: true
  - input: "6\n15000"
    expectedOutput: "14999"
    hidden: true
  - input: "7\n12500"
    expectedOutput: "2480"
    hidden: true
hints:
  - "Use exponential search: double the index until you find a bound"
  - "Then apply binary search between the established bounds"
  - "Treat get_func() returning -1 as 'value too large'"
solution: |
  def search_unknown_size(get_func, target):
      # Phase 1: Exponential search for upper bound
      right = 1
      while get_func(right) != -1 and get_func(right) < target:
          right *= 2

      # Phase 2: Binary search
      left = right // 2
      while left <= right:
          mid = (left + right) // 2
          mid_val = get_func(mid)

          if mid_val == target:
              return mid
          elif mid_val == -1 or mid_val > target:
              right = mid - 1
          else:
              left = mid + 1

      return -1
```

## Synthesis and Mastery

Advanced binary search applications require recognizing how fundamental elimination principles adapt to different data structures and properties:

- **Multidimensional spaces**: Extend elimination to rows/columns in matrices
- **Modified monotonic properties**: Identify which portions maintain ordering (rotated arrays)
- **Local properties**: Apply elimination to slopes rather than global ordering (peak finding)
- **Hybrid approaches**: Combine exponential search with binary search (unknown size arrays)

The unifying principle remains **systematic elimination through comparison-based decisions**, demonstrating the algorithmic power of the binary search approach across diverse problem domains.

## Key Algorithmic Insights

- **Staircase search** achieves optimal $O(m + n)$ complexity for row/column sorted matrices through strategic corner positioning
- **Rotated array analysis** leverages the invariant that at least one half maintains standard sorted order
- **Peak finding** demonstrates elimination based on local slopes rather than global comparisons
- **Complex applications** often require combining multiple binary search concepts and careful edge case analysis

These advanced techniques showcase binary search as a general elimination framework applicable to any problem where systematic comparison enables halving the search space.

Section 8.5 synthesizes all binary search concepts through comprehensive problem-solving applications.
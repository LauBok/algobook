# Advanced Applications: 2D Search and Beyond

You've mastered binary search in 1D arrays and answer spaces. Now it's time to explore the most challenging applications: searching in 2D matrices, rotated arrays, and other complex data structures. These advanced techniques showcase the true versatility of binary search thinking.

## Learning Objectives

- Apply binary search principles to 2D sorted matrices
- Handle search in rotated and shifted arrays
- Recognize advanced binary search patterns
- Solve complex search problems with modified binary search approaches

## Searching in 2D Sorted Matrices

When you have a matrix that's sorted both row-wise and column-wise, you can apply binary search principles in creative ways. The approach you choose depends on the specific sorting properties of your matrix.

```table
title: 2D Matrix Search Approaches Comparison
headers: ["Approach", "Matrix Requirements", "Time Complexity", "Best Use Case"]
rows:
  - ["1D Array Treatment", "Globally sorted (each row > previous row)", "O(log(m×n))", "Fully sorted matrices"]
  - ["Staircase Search", "Row-wise & column-wise sorted only", "O(m + n)", "Partially sorted matrices"]
  - ["Row-wise Binary Search", "Each row individually sorted", "O(m × log n)", "When unsure of global structure"]
  - ["Column Binary Search", "Each column individually sorted", "O(n × log m)", "Column-focused searching"]
caption: Choose the right approach based on your matrix's sorting properties
sortable: false
```

```note title="Matrix Sorting Types"
**Globally Sorted**: Each element is ≤ all elements to its right and below (can treat as 1D array)  
**Row/Column Sorted**: Each row sorted left-to-right, each column sorted top-to-bottom (but not globally)  
**Partially Sorted**: Only some rows or columns are sorted (requires careful approach selection)
```

Let's explore different approaches with an interactive visualization:

```widget
id: matrix-2d-search-visualizer
type: Matrix2DSearchVisualizer
title: Interactive 2D Matrix Search Comparison
description: Compare all three search approaches and see how they work on different matrix types!
```

Now let's examine each approach in detail:

### Approach 1: Treat Matrix as 1D Array

```python-execute
def search_2d_matrix_as_1d(matrix, target):
    """
    Search in a matrix where:
    1. Each row is sorted left to right
    2. First element of each row > last element of previous row
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    left, right = 0, rows * cols - 1
    
    print(f"Matrix:")
    for row in matrix:
        print(f"  {row}")
    print(f"Searching for: {target}")
    print()
    
    while left <= right:
        mid = (left + right) // 2
        
        # Convert 1D index to 2D coordinates
        row = mid // cols
        col = mid % cols
        mid_value = matrix[row][col]
        
        print(f"Step: left={left}, right={right}, mid={mid}")
        print(f"  Position: matrix[{row}][{col}] = {mid_value}")
        
        if mid_value == target:
            print(f"  ✓ Found {target} at position ({row}, {col})")
            return True
        elif mid_value < target:
            left = mid + 1
            print(f"  {mid_value} < {target}, search right")
        else:
            right = mid - 1
            print(f"  {mid_value} > {target}, search left")
        print()
    
    print(f"✗ {target} not found")
    return False

# Test with a fully sorted matrix
matrix1 = [
    [1,  4,  7,  11],
    [2,  5,  8,  12],
    [3,  6,  9,  16]
]

search_2d_matrix_as_1d(matrix1, 5)
print("=" * 50)
search_2d_matrix_as_1d(matrix1, 13)
```

### Approach 2: Staircase Search

For matrices sorted row-wise and column-wise (but not necessarily in the global order), we can use a clever "staircase" approach:

```python-execute
def search_2d_matrix_staircase(matrix, target):
    """
    Search in a matrix where:
    1. Each row is sorted left to right
    2. Each column is sorted top to bottom
    (But not necessarily globally sorted)
    """
    if not matrix or not matrix[0]:
        return False
    
    rows, cols = len(matrix), len(matrix[0])
    row, col = 0, cols - 1  # Start from top-right corner
    
    print(f"Matrix:")
    for i, matrix_row in enumerate(matrix):
        print(f"  {matrix_row}")
    print(f"Searching for: {target}")
    print("Starting from top-right corner")
    print()
    
    step = 1
    while row < rows and col >= 0:
        current = matrix[row][col]
        print(f"Step {step}: position ({row}, {col}) = {current}")
        
        if current == target:
            print(f"  ✓ Found {target} at position ({row}, {col})")
            return True
        elif current > target:
            print(f"  {current} > {target}, move left (eliminate column)")
            col -= 1
        else:
            print(f"  {current} < {target}, move down (eliminate row)")
            row += 1
        
        step += 1
        print()
    
    print(f"✗ {target} not found")
    return False

# Test with row/column sorted matrix
matrix2 = [
    [1,  4,  7,  11, 15],
    [2,  5,  8,  12, 19],
    [3,  6,  9,  16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

search_2d_matrix_staircase(matrix2, 5)
print("=" * 50)
search_2d_matrix_staircase(matrix2, 14)
```

```note title="Why Staircase Search Works"
Starting from the top-right corner, we can eliminate either an entire row or an entire column at each step. This gives us O(m + n) time complexity, which is optimal for this type of matrix.
```

### Approach 3: Binary Search on Each Row

```python-execute
def search_2d_matrix_row_wise(matrix, target):
    """
    Search by applying binary search to each row.
    Good when we're not sure about the matrix structure.
    """
    print(f"Matrix:")
    for i, row in enumerate(matrix):
        print(f"  Row {i}: {row}")
    print(f"Searching for: {target}")
    print()
    
    for i, row in enumerate(matrix):
        # Check if target could be in this row
        if row[0] <= target <= row[-1]:
            print(f"Checking row {i}: {row}")
            
            # Binary search in this row
            left, right = 0, len(row) - 1
            while left <= right:
                mid = (left + right) // 2
                if row[mid] == target:
                    print(f"  ✓ Found {target} at position ({i}, {mid})")
                    return True
                elif row[mid] < target:
                    left = mid + 1
                else:
                    right = mid - 1
            print(f"  Not found in row {i}")
        else:
            print(f"Skipping row {i}: target not in range [{row[0]}, {row[-1]}]")
    
    print(f"✗ {target} not found in any row")
    return False

# Test the row-wise approach  
matrix2 = [
    [1,  4,  7,  11, 15],
    [2,  5,  8,  12, 19],
    [3,  6,  9,  16, 22],
    [10, 13, 14, 17, 24],
    [18, 21, 23, 26, 30]
]

search_2d_matrix_row_wise(matrix2, 16)
```

```quiz
id: 2d-search-approaches
question: "You have a matrix where each row is sorted and each column is sorted, but the last element of a row might be larger than the first element of the next row. Which search approach makes the most sense?"
options:
  - id: a
    text: "Treat the entire matrix as one big sorted array"
    correct: false
    explanation: "This won't work because the matrix isn't globally sorted - you can't predict the ordering between the end of one row and start of the next."
  - id: b
    text: "Start from a corner and eliminate entire rows or columns at each step"
    correct: true
    explanation: "Correct! The staircase approach works perfectly here - from the top-right corner, you can always eliminate either a full row or full column based on comparison with your target."
  - id: c
    text: "Search each row individually using binary search"
    correct: false
    explanation: "While this would work, it's not optimal. The staircase approach can eliminate entire rows/columns faster."
  - id: d
    text: "Use linear search since binary search won't work"
    correct: false
    explanation: "Binary search principles still apply, just in a different way. The staircase approach is essentially a modified binary search."
```

## Search in Rotated Arrays

A classic advanced binary search problem involves searching in sorted arrays that have been rotated. This simulates real-world scenarios like circular buffers or shifted time series data.

### Understanding Rotated Arrays

**What is a rotated array?**
Imagine you have a sorted array `[0, 1, 2, 4, 5, 6, 7]`. A rotated array is created by taking some elements from the front and moving them to the back:
- Original: `[0, 1, 2, 4, 5, 6, 7]`  
- Rotate by 4: `[4, 5, 6, 7, 0, 1, 2]`

**Key Insight #1: Two Sorted Halves**
A rotated sorted array always consists of two sorted subarrays joined together. In `[4, 5, 6, 7, 0, 1, 2]`:
- Left part: `[4, 5, 6, 7]` (sorted)
- Right part: `[0, 1, 2]` (sorted)

**Key Insight #2: At Least One Half is Always Properly Sorted**
When you pick any middle point, at least one half (left or right) will be a normal sorted subarray. This is crucial because:
- We can use normal binary search logic on the sorted half
- We can determine if our target belongs in the sorted half or the "mixed" half

**The Strategy:**
1. Find the middle element
2. Determine which half is properly sorted (compare middle with boundaries)
3. Check if target belongs in the sorted half
4. If yes → update boundaries to search only the sorted half (`right = mid - 1` or `left = mid + 1`)
5. If no → update boundaries to search the other half (`right = mid - 1` or `left = mid + 1`)
6. Continue the same binary search loop with new boundaries

**Important**: This is still the same iterative binary search - we exclude `mid` in boundary updates since we already checked it's not our target. No recursion needed!

```note title="Boundary Update Rules"
- If `nums[mid] == target` → return mid (found it!)
- If searching left half → `right = mid - 1` 
- If searching right half → `left = mid + 1`

We exclude `mid` because we already know `nums[mid] ≠ target`
```

```note title="Visual Example"
Array: `[4, 5, 6, 7, 0, 1, 2]`, searching for target `0`

**Step 1**: Middle element is `7` (index 3)
- Left half: `[4, 5, 6, 7]` - properly sorted ✓
- Right half: `[0, 1, 2]` - also properly sorted ✓

**Step 2**: Is target `0` in the sorted left half `[4, 5, 6, 7]`?
- No, because `0 < 4` (target is outside this range)

**Step 3**: Is target `0` in the sorted right half `[0, 1, 2]`?
- Yes, because `0 <= 0 <= 2` (target is in this range)

**Step 4**: Search the right half `[0, 1, 2]` using normal binary search
```

Let's see this strategy in action with an interactive visualization:

```widget
id: rotated-array-search-visualizer
type: RotatedArraySearchVisualizer
title: Interactive Rotated Array Search
description: Explore how binary search adapts to find elements in rotated sorted arrays. See the rotation process and understand why at least one half is always sorted!
```

Now let's examine the detailed implementation:

```python-execute
def search_rotated_array(nums, target):
    """
    Search in a rotated sorted array.
    Example: [4,5,6,7,0,1,2] is [0,1,2,4,5,6,7] rotated.
    """
    left, right = 0, len(nums) - 1
    
    print(f"Rotated array: {nums}")
    print(f"Searching for: {target}")
    print()
    
    while left <= right:
        mid = (left + right) // 2
        mid_val = nums[mid]
        
        print(f"Step: left={left}({nums[left]}), right={right}({nums[right]}), mid={mid}({mid_val})")
        
        if mid_val == target:
            print(f"  ✓ Found {target} at index {mid}")
            return mid
        
        # Determine which half is properly sorted
        if nums[left] <= mid_val:  # Left half is sorted
            print(f"  Left half [{left}..{mid}] is sorted")
            if nums[left] <= target < mid_val:
                print(f"  Target {target} is in sorted left half")
                right = mid - 1
            else:
                print(f"  Target {target} must be in right half")
                left = mid + 1
        else:  # Right half is sorted
            print(f"  Right half [{mid}..{right}] is sorted")
            if mid_val < target <= nums[right]:
                print(f"  Target {target} is in sorted right half")
                left = mid + 1
            else:
                print(f"  Target {target} must be in left half")
                right = mid - 1
        print()
    
    print(f"✗ {target} not found")
    return -1

# Test with rotated arrays
rotated = [4, 5, 6, 7, 0, 1, 2]
search_rotated_array(rotated, 0)
print("=" * 50)
search_rotated_array(rotated, 3)
```

### Finding the Rotation Point

Sometimes you need to find where the rotation occurred - this is also a binary search problem:

```python-execute
def find_rotation_point(nums):
    """
    Find the index of the minimum element (rotation point) in a rotated sorted array.
    """
    left, right = 0, len(nums) - 1
    
    print(f"Finding rotation point in: {nums}")
    print()
    
    while left < right:
        mid = (left + right) // 2
        
        print(f"Step: left={left}({nums[left]}), right={right}({nums[right]}), mid={mid}({nums[mid]})")
        
        if nums[mid] > nums[right]:
            # Minimum is in the right half
            print(f"  {nums[mid]} > {nums[right]}, minimum in right half")
            left = mid + 1
        else:
            # Minimum is in the left half (including mid)
            print(f"  {nums[mid]} <= {nums[right]}, minimum in left half")
            right = mid
        print()
    
    print(f"Rotation point found at index {left}, value: {nums[left]}")
    return left

# Test rotation point finding
test_arrays = [
    [4, 5, 6, 7, 0, 1, 2],
    [2, 3, 4, 5, 1],
    [1, 2, 3, 4, 5]  # Not rotated
]

for arr in test_arrays:
    find_rotation_point(arr)
    print("=" * 30)
```

## Peak Finding

Another advanced application is finding peaks in arrays - elements that are greater than their neighbors. Let's see how binary search adapts to this optimization problem:

```widget
id: peak-finding-visualizer
type: PeakFindingVisualizer
title: Interactive Peak Finding
description: See how binary search finds peaks by following slopes instead of comparing values. Watch the algorithm follow ascending slopes to guarantee reaching a peak!
```

Now let's examine the detailed implementation:

```python-execute
def find_peak_element(nums):
    """
    Find any peak element in the array.
    A peak is an element greater than its neighbors.
    """
    left, right = 0, len(nums) - 1
    
    print(f"Finding peak in: {nums}")
    print()
    
    while left < right:
        mid = (left + right) // 2
        
        print(f"Step: left={left}, right={right}, mid={mid}")
        print(f"  Comparing nums[{mid}]={nums[mid]} with nums[{mid+1}]={nums[mid+1]}")
        
        if nums[mid] > nums[mid + 1]:
            # Peak is in the left half (including mid)
            print(f"  Descending slope, peak in left half")
            right = mid
        else:
            # Peak is in the right half
            print(f"  Ascending slope, peak in right half")
            left = mid + 1
        print()
    
    print(f"Peak found at index {left}, value: {nums[left]}")
    return left

# Test peak finding
peak_arrays = [
    [1, 2, 3, 1],
    [1, 2, 1, 3, 5, 6, 4],
    [1, 2, 3, 4, 5]  # Peak at end
]

for arr in peak_arrays:
    find_peak_element(arr)
    print("=" * 30)
```

```warning title="Peak Finding Edge Cases"
Peak finding assumes that array boundaries are treated as negative infinity. This ensures that at least one peak always exists, even in monotonic arrays.
```

## Advanced Exercise: Search in Unknown Size Array

```exercise
id: search-unknown-size
title: Search in Array of Unknown Size
description: Search for a target in a sorted array of positive integers where you don't know the size. You have a function `get(index)` that returns the value at index or -1 if index is out of bounds. Return the index if found, -1 if not found.
difficulty: hard
prepend: |
  # Test array setup - students don't need to see this
  test_arrays = {
      1: [4, 6, 8, 10, 12, 14, 16, 18, 20],
      2: [1, 3, 5, 7, 9],
      3: [2, 4, 6],
      4: [10],
      5: list(range(2, 20002, 2)),  # [2, 4, 6, ..., 20000] - 10000 elements
      6: list(range(1, 15001)),      # [1, 2, 3, ..., 15000] - 15000 elements
      7: list(range(100, 25001, 5)), # [100, 105, 110, ..., 25000] - 5000 elements
  }
  
  def create_get_func(arr):
      def get_func(index):
          return arr[index] if 0 <= index < len(arr) else -1
      return get_func
starterCode: |
  def search_unknown_size(get_func, target):
      """
      Search for target in an array of unknown size.
      get_func(i) returns arr[i] if i < len(arr), else -1
      
      Strategy:
      1. First find an upper bound by doubling the search range
      2. Then do binary search between the bounds
      """
      # Your code here
      pass
postpend: |
  # Test the function
  test_case = int(input().strip())
  target = int(input().strip())
  
  test_array = test_arrays[test_case]
  get_func = create_get_func(test_array)
  result = search_unknown_size(get_func, target)
  print(result)
testCases:
  - input: "1\n8"
    expectedOutput: "2"
  - input: "1\n4"
    expectedOutput: "0"
    hidden: true
  - input: "1\n25"
    expectedOutput: "-1"
    hidden: true
  - input: "2\n7"
    expectedOutput: "3"
    hidden: true
  - input: "2\n6"
    expectedOutput: "-1"
    hidden: true
  - input: "3\n2"
    expectedOutput: "0"
    hidden: true
  - input: "3\n6"
    expectedOutput: "2"
    hidden: true
  - input: "4\n10"
    expectedOutput: "0"
    hidden: true
  - input: "4\n5"
    expectedOutput: "-1"
    hidden: true
  - input: "5\n10000"
    expectedOutput: "4999"
    hidden: true
  - input: "5\n20000"
    expectedOutput: "9999"
    hidden: true
  - input: "6\n15000"
    expectedOutput: "14999"
    hidden: true
  - input: "6\n7500"
    expectedOutput: "7499"
    hidden: true
  - input: "7\n12500"
    expectedOutput: "2480"
    hidden: true
  - input: "7\n25000"
    expectedOutput: "4980"
    hidden: true
hints:
  - "First find an upper bound by doubling the search range"
  - "Then do normal binary search between the bounds"
  - "Handle the -1 return value as 'greater than target'"
solution: |
  def search_unknown_size(get_func, target):
      # Find upper bound
      right = 1
      while get_func(right) != -1 and get_func(right) < target:
          right *= 2
      
      # Binary search
      left = right // 2
      while left <= right:
          mid = (left + right) // 2
          mid_val = get_func(mid)
          
          if mid_val == target:
              return mid
          elif mid_val == -1 or mid_val > target:
              right = mid - 1
          else:
              left = mid + 1
      
      return -1
```

## Pattern Recognition for Complex Binary Search

When facing complex binary search problems, learning to recognize these key patterns will help you choose the right approach:

```table
title: Binary Search Pattern Recognition Guide
headers: ["Problem Type", "Key Indicators", "Approach", "Boundary Conditions"]
rows:
  - ["Standard Search", "Find exact element in sorted array", "Classic binary search", "`left <= right`, exclude mid"]
  - ["Boundary Finding", "Find first/last occurrence, insertion point", "Modified binary search", "`left < right`, include mid in updates"]
  - ["Answer Space Search", "Minimize/maximize with constraints", "Binary search on answers", "Custom validation function"]
  - ["Rotated Arrays", "Sorted array with rotation point", "Identify sorted half", "Modified comparison logic"]
  - ["2D Matrices", "Sorted rows/columns", "Choose matrix approach", "Based on sorting properties"]
  - ["Peak Finding", "Local maximum elements", "Follow slopes", "Compare with neighbors"]
caption: Match your problem to the right binary search pattern
sortable: false
```

### Decision Framework

When you encounter a binary search problem, ask yourself:

```note title="Problem Analysis Questions"
1. **What am I searching for?**
   - Exact element → Standard binary search
   - Boundary/range → Boundary finding
   - Optimal value → Answer space search

2. **What's the data structure?**
   - 1D sorted array → Standard or boundary approach
   - Rotated array → Modified comparison logic
   - 2D matrix → Choose matrix strategy

3. **What's the monotonic property?**
   - Traditional: smaller elements left, larger right
   - Answer space: if X works, then X+1/X-1 also works
   - Peak finding: follow ascending slopes

4. **What are the edge cases?**
   - Empty arrays, single elements
   - All same elements, boundary positions
   - Out-of-bounds conditions
```

```note title="Problem-Solving Strategy"
When facing a complex binary search problem:
1. **Identify the search space** - what are you searching through?
2. **Find the monotonic property** - what makes one half "better" than the other?
3. **Design the comparison logic** - how do you decide which half to search?
4. **Handle edge cases** - empty arrays, single elements, boundaries
```

## Key Takeaways

- **2D matrix search** has multiple approaches depending on sorting properties
- **Staircase search** works for row/column sorted matrices in O(m + n) time
- **Rotated array search** requires identifying which half is properly sorted
- **Peak finding** demonstrates binary search on local properties rather than global sorting
- **Complex problems** often combine multiple binary search concepts
- **Pattern recognition** is key to identifying when and how to apply binary search variants

These advanced applications show that binary search is not just about finding elements in arrays - it's a fundamental problem-solving technique for any scenario involving systematic elimination of possibilities. In our final section, we'll put all these concepts together in comprehensive practice problems!
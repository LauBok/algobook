# 3.3 While Loops and Common Patterns

## Learning Objectives
By the end of this section, you will:
- Understand the syntax and use cases for while loops
- Recognize when to use while loops vs for loops
- Master common while loop patterns (counting, accumulation, validation)
- Handle user input validation and menu systems with while loops
- Avoid infinite loops and common while loop pitfalls

## When For Loops Hit Their Limit

For loops work well when the number of repetitions is known. However, real-world programming often involves uncertainty.

```note title="Unknown Iteration Scenarios"
- Password validation until correct input is provided
- Game continuation until the player succeeds
- Command processing until termination command is entered
- Waiting for a condition to become true
```

In these situations, the iteration count is unknown in advance. The start and stop conditions are defined, but the number of repetitions cannot be predetermined.

**While loops** provide the solution for condition-based repetition.

## Your First While Loop: Persistent Input

Consider a scenario that demonstrates while loop capabilities. A program requiring a positive number can continue asking until the user provides valid input:

```python-execute
print("I need a positive number!")

number = float(input("Enter a positive number: "))
while number <= 0:
    print("That's not positive! Try again.")
    number = float(input("Enter a positive number: "))

print(f"Great! {number} is indeed positive.")
```

The program continues asking until it receives valid input. The following breakdown explains while loop syntax:

```note title="While Loop Structure"
```python
while number <= 0:
    # loop body here
```

**Components:**
- `while` - The keyword that starts a while loop
- `number <= 0` - The **condition** (loop continues while this is True)
- `:` - Marks the end of the condition
- **Indented code** - The body that gets repeated
- The loop continues as long as the condition evaluates to True
```

The while loop executes the body repeatedly until the condition becomes False.

```note title="Loop Type Comparison"
- **For loops**: Execute a specific number of times
- **While loops**: Execute until a condition changes

**Examples:**
- For loop: "Print numbers 1 to 10" (exactly 10 times)
- While loop: "Ask for password until correct" (unknown number of times)
```

## While Loop Structure

Every while loop has three essential parts that work together:

```note title="While Loop Components"
### 1. Initialization (before the loop)
```python
# Set up the condition variable
number = float(input("Enter a positive number: "))
```

### 2. Condition (the test)
```python
# The loop continues while this is True
while number <= 0:
```

### 3. Update (inside the loop)
```python
# Change something so the condition can eventually become False
number = float(input("Enter a positive number: "))
```
```

```danger title="Infinite Loop Alert!"
If you forget to update the condition variable inside the loop, it will run forever! Your program will get stuck and never finish. Always make sure something changes inside the loop that can eventually make the condition False.
```

## While Loop vs For Loop: Making the Right Choice

### Use a **for loop** when:
- You know exactly how many repetitions you need
- You're working with sequences (numbers, lists, etc.)
- You're counting or iterating through items

```python-execute
# Perfect for a for loop - we know we want exactly 5 iterations
print("Countdown with for loop:")
for i in range(5, 0, -1):
    print(i)
print("Blast off!")
```

### Use a **while loop** when:
- You don't know how many repetitions you'll need
- You're waiting for a condition to become true/false
- You're validating user input
- You're processing data until you reach the end

```python-execute
# Perfect for a while loop - we don't know how many guesses it will take
import random

secret_number = random.randint(1, 10)
guess = 0

print("I'm thinking of a number between 1 and 10!")

while guess != secret_number:
    guess = int(input("What's your guess? "))
    if guess < secret_number:
        print("Too low!")
    elif guess > secret_number:
        print("Too high!")
    else:
        print(f"Correct! The number was {secret_number}")
        
print("Thanks for playing!")
```

```quiz
id: loop_choice
question: "Which type of loop would be best for calculating the factorial of a number (multiplying all numbers from 1 to n)?"
options:
  - id: a
    text: "For loop, because we know exactly how many numbers to multiply"
    correct: true
    explanation: "Correct! If we want 5!, we know we need to multiply exactly 5 numbers: 1Ã—2Ã—3Ã—4Ã—5."
  - id: b
    text: "While loop, because we don't know how many numbers to multiply"
    correct: false
    explanation: "We do know how many numbers - if calculating 5!, we multiply exactly 5 numbers."
  - id: c
    text: "Either would work equally well"
    correct: false
    explanation: "While both could work, a for loop is more natural when you know the exact count."
  - id: d
    text: "Neither - you can't calculate factorials with loops"
    correct: false
    explanation: "Loops are perfect for factorial calculations!"
```

## Common While Loop Patterns

### Pattern 1: Input Validation

One of the most practical uses of while loops is validating user input:

```python-execute
# Age validation
print("Please enter your age.")
age = input("Age: ")

# Keep asking until we get a valid number
while not age.isdigit() or int(age) < 0 or int(age) > 150:
    print("Please enter a valid age (0-150).")
    age = input("Age: ")

age = int(age)  # Convert to integer once we know it's valid
print(f"Thank you! You are {age} years old.")
```

A more robust validation pattern:

```python-execute
# Grade validation with multiple conditions
print("Let's get your test grade:")
valid_input = False

while not valid_input:
    grade_input = input("Enter your test grade (0-100): ")
    
    # Check if it's a valid number
    if grade_input.replace('.', '', 1).isdigit():
        grade = float(grade_input)
        if 0 <= grade <= 100:
            valid_input = True
            print(f"Thank you! Your grade is {grade}")
        else:
            print("Grade must be between 0 and 100.")
    else:
        print("Please enter a valid number.")
```

### Pattern 2: Menu Systems

While loops are perfect for creating interactive menus:

```python-execute
# Simple calculator menu
print("Welcome to the Simple Calculator!")

while True:
    print("\nOptions:")
    print("1. Add")
    print("2. Subtract") 
    print("3. Multiply")
    print("4. Divide")
    print("5. Quit")
    
    choice = input("\nChoose an option (1-5): ")
    
    if choice == "5":
        print("Goodbye!")
        break  # Exit the loop
    
    if choice in ["1", "2", "3", "4"]:
        # Get first number
        num1_input = input("First number: ")
        if num1_input.replace('.', '', 1).replace('-', '', 1).isdigit():
            num1 = float(num1_input)
            
            # Get second number  
            num2_input = input("Second number: ")
            if num2_input.replace('.', '', 1).replace('-', '', 1).isdigit():
                num2 = float(num2_input)
                
                if choice == "1":
                    result = num1 + num2
                    print(f"{num1} + {num2} = {result}")
                elif choice == "2":
                    result = num1 - num2
                    print(f"{num1} - {num2} = {result}")
                elif choice == "3":
                    result = num1 * num2
                    print(f"{num1} Ã— {num2} = {result}")
                elif choice == "4":
                    if num2 == 0:
                        print("Cannot divide by zero!")
                    else:
                        result = num1 / num2
                        print(f"{num1} Ã· {num2} = {result}")
            else:
                print("Please enter a valid number for the second value.")
        else:
            print("Please enter a valid number for the first value.")
    else:
        print("Invalid choice. Please try again.")
```

### Pattern 3: Processing Until Criteria Met

Some tasks need to repeat until specific criteria are satisfied, but you don't know how many attempts it will take:

```python-execute
# Password strength checker - keep asking until strong password
print("Create a strong password (at least 8 characters with a number):")
strong_password = False

while not strong_password:
    password = input("Enter password: ")
    
    # Check if password meets criteria
    has_number = False
    for char in password:
        if char.isdigit():
            has_number = True
            break
    
    long_enough = len(password) >= 8
    
    if long_enough and has_number:
        strong_password = True
        print("âœ“ Strong password created successfully!")
    else:
        print("Password too weak. Need:")
        if not long_enough:
            print("  - At least 8 characters")
        if not has_number:
            print("  - At least one number")
        print("Try again.")

print("Account setup complete!")
```

```note title="Why While Loop Here? ðŸ¤”"
**Why use while instead of for?** We don't know how many attempts the user will need to create a strong password - could be 1 try or 10 tries! 

**Key insight:** The loop continues until the criteria are met, regardless of how many iterations that takes. ðŸ”„
```

### Pattern 4: Accumulation Until Condition Met

Accumulating values until reaching a goal:

```python-execute
# Save money until you reach a goal
goal = 1000
current_savings = 0
week = 0

print(f"Saving money until you reach ${goal}")

while current_savings < goal:
    week += 1
    weekly_saving = float(input(f"Week {week} - How much can you save? $"))
    current_savings += weekly_saving
    remaining = goal - current_savings
    
    print(f"Total saved: ${current_savings:.2f}")
    
    if remaining > 0:
        print(f"${remaining:.2f} left to reach your goal!")
    else:
        print(f"Congratulations! You've reached your goal in {week} weeks!")
```

### Pattern 5: Guessing Games and Search

Using while loops for interactive problem-solving:

```python-execute
# Number guessing game with attempt counting
import random

secret = random.randint(1, 100)
attempts = 0
max_attempts = 7

print("I'm thinking of a number between 1 and 100!")
print(f"You have {max_attempts} attempts to guess it.")

while attempts < max_attempts:
    guess_input = input(f"\nAttempt {attempts + 1}: What's your guess? ")
    
    # Check if input is a valid number
    if guess_input.isdigit():
        guess = int(guess_input)
        attempts += 1
        
        if guess == secret:
            print(f"Correct! You guessed it in {attempts} attempts!")
            break
        elif guess < secret:
            remaining = max_attempts - attempts
            print(f"Too low! {remaining} attempts remaining.")
        else:
            remaining = max_attempts - attempts
            print(f"Too high! {remaining} attempts remaining.")
    else:
        print("Please enter a valid number!")
        # Don't increment attempts for invalid input

else:
    # This runs if the loop completes without breaking
    print(f"\nGame over! The number was {secret}.")
    print("Better luck next time!")
```

### Advanced While Loop Techniques

### Using break and continue

```python-execute
# Password system with limited attempts
max_attempts = 3
attempts = 0
correct_password = "python123"

while attempts < max_attempts:
    password = input("Enter password: ")
    attempts += 1
    
    if password == correct_password:
        print("Access granted!")
        break  # Exit the loop immediately
    
    remaining = max_attempts - attempts
    if remaining > 0:
        print(f"Wrong password. {remaining} attempts remaining.")
    else:
        print("Access denied. Too many failed attempts.")
```

### The while-else Pattern

Python has a unique feature where you can add an `else` clause to while loops:

```python-execute
# Search for a specific value
numbers = [3, 7, 12, 18, 25, 31]
target = 18
index = 0

print(f"Searching for {target} in the list...")

while index < len(numbers):
    if numbers[index] == target:
        print(f"Found {target} at position {index}!")
        break
    index += 1
else:
    # This runs only if the loop completed without breaking
    print(f"{target} was not found in the list.")
```

### Converting Between For and While Loops

Many problems can be solved with either loop type. Consider the same problem implemented both ways:

**For Loop Implementation:**
```python-execute
total = 0
for number in range(1, 11):
    total += number
print(f"Sum using for loop: {total}")
```

**While Loop Implementation:**
```python-execute
total = 0
number = 1

while number <= 10:
    total += number
    number += 1

print(f"Sum using while loop: {total}")
```

```quiz
id: while_loop_mechanics
question: "What will happen if you forget to update the loop variable inside a while loop?"
options:
  - id: a
    text: "The program will crash with an error"
    correct: false
    explanation: "No error occurs initially - the loop just keeps running forever until you manually stop the program."
  - id: b
    text: "The loop will run exactly once"
    correct: false
    explanation: "The loop will keep running as long as the condition is True."
  - id: c
    text: "The loop will run forever (infinite loop)"
    correct: true
    explanation: "Correct! Without updating the variable, the condition never changes, so the loop never stops."
  - id: d
    text: "Python will automatically update the variable"
    correct: false
    explanation: "Python doesn't automatically update variables - you must do it explicitly."
```

### Debugging While Loops

### Common Mistake 1: Infinite Loops
```python-execute
# WRONG: This would run forever
# counter = 1
# while counter <= 5:
#     print(counter)
#     # Forgot to increment counter!

# CORRECT: Always update the condition variable
counter = 1
while counter <= 5:
    print(counter)
    counter += 1  # Don't forget this!
```

### Common Mistake 2: Off-by-One Errors
```python-execute
# Check your conditions carefully
count = 0

# This prints 0, 1, 2, 3, 4 (5 numbers)
print("Counting to 4:")
while count < 5:
    print(count)
    count += 1

print("\nCounting 1 to 5:")
count = 1
# This prints 1, 2, 3, 4, 5 (5 numbers)
while count <= 5:
    print(count)
    count += 1
```

### Common Mistake 3: Wrong Condition Logic
```python-execute
# Be careful with your condition logic
password = ""

# WRONG: This won't work as expected
# while password == "secret":  # Loop only runs if password is ALREADY correct
#     password = input("Enter password: ")

# CORRECT: Loop continues while password is NOT correct
while password != "secret":
    password = input("Enter password: ")
print("Access granted!")
```

### Real-World Applications

### File Processing Pattern
```python-execute
# Simulating reading lines from a file
lines = ["Line 1", "Line 2", "Line 3", "", "Line 5", ""]  # Empty strings represent blank lines
line_index = 0

print("Processing file lines:")
while line_index < len(lines):
    current_line = lines[line_index]
    if current_line.strip():  # If line is not empty
        print(f"Processing: {current_line}")
    else:
        print("Skipping empty line")
    line_index += 1

print("File processing complete!")
```

### Game Loop Pattern
```python-execute
# Simple coin flip game
import random

player_score = 0
computer_score = 0
rounds_played = 0

print("Welcome to Coin Flip!")
print("Type 'quit' to exit anytime.")

while True:
    user_input = input("\nGuess heads or tails: ").lower()
    
    if user_input == "quit":
        break
    
    if user_input not in ["heads", "tails"]:
        print("Please enter 'heads' or 'tails'")
        continue
    
    # Flip the coin (simple random method)
    coin_result = "heads" if random.randint(1, 2) == 1 else "tails"
    print(f"The coin landed on: {coin_result}")
    
    rounds_played += 1
    
    if user_input == coin_result:
        player_score += 1
        print("You win this round!")
    else:
        computer_score += 1
        print("Computer wins this round!")
    
    print(f"Score - You: {player_score}, Computer: {computer_score}")

if rounds_played > 0:
    print(f"\nFinal Score after {rounds_played} rounds:")
    print(f"You: {player_score}, Computer: {computer_score}")
    if player_score > computer_score:
        print("You won overall!")
    elif computer_score > player_score:
        print("Computer won overall!")
    else:
        print("It's a tie!")

print("Thanks for playing!")
```

### Practice Challenges

### Challenge 1: Digital Root Calculator
```exercise
id: digital-root
title: Calculate Digital Root
description: Calculate the digital root of a number by repeatedly summing its digits until only one digit remains.
difficulty: easy
starterCode: |
  # Calculate the digital root of a number
  # Digital root: Keep adding the digits of a number until you get a single digit.
  # Example: 987 â†’ 9+8+7=24 â†’ 2+4=6, so digital root is 6
  
  number = int(input())
  
  if number == 0:
      print(0)
  else:
      # Your code here - use a while loop!
      # Keep summing digits until you have a single digit
      pass
testCases:
  - input: "987\n"
    expectedOutput: "6"
    description: "987 â†’ 9+8+7=24 â†’ 2+4=6"
  - input: "123\n"
    expectedOutput: "6"
    description: "123 â†’ 1+2+3=6"
    hidden: true
  - input: "999\n"
    expectedOutput: "9"
    description: "999 â†’ 9+9+9=27 â†’ 2+7=9"
    hidden: true
  - input: "0\n"
    expectedOutput: "0"
    description: "Special case: 0 returns 0"
    hidden: true
  - input: "7\n"
    expectedOutput: "7"
    description: "Single digit returns itself"
    hidden: true
  - input: "88\n"
    expectedOutput: "7"
    description: "88 â†’ 8+8=16 â†’ 1+6=7"
    hidden: true
  - input: "456\n"
    expectedOutput: "6"
    description: "456 â†’ 4+5+6=15 â†’ 1+5=6"
    hidden: true
  - input: "99\n"
    expectedOutput: "9"
    description: "99 â†’ 9+9=18 â†’ 1+8=9"
    hidden: true
  - input: "1111\n"
    expectedOutput: "4"
    description: "1111 â†’ 1+1+1+1=4"
    hidden: true
  - input: "9876\n"
    expectedOutput: "3"
    description: "9876 â†’ 9+8+7+6=30 â†’ 3+0=3"
    hidden: true
hints:
  - "Use while number >= 10: to continue until single digit"
  - "Extract digits by using number % 10 for last digit"
  - "Remove last digit with number // 10"
  - "Keep a running sum of digits, then replace number with that sum"
solution: |
  number = int(input())
  
  if number == 0:
      print(0)
  else:
      while number >= 10:
          digit_sum = 0
          temp_number = number
          while temp_number > 0:
              digit_sum += temp_number % 10
              temp_number //= 10
          number = digit_sum
      
      print(number)
```

### Challenge 2: Doubling Number Game
```exercise
id: doubling-game
title: Keep Doubling Until Limit
description: Start with a number and keep doubling it until it exceeds a given limit, counting how many doublings were needed.
difficulty: medium
starterCode: |
  # Keep doubling a number until it exceeds the limit
  # Count how many times we doubled the number
  
  start_number = int(input())
  limit = int(input())
  
  current_number = start_number
  doublings = 0
  
  # Your code here - use a while loop!
  # Keep doubling until current_number exceeds limit
  pass
testCases:
  - input: "3\n50\n"
    expectedOutput: "5"
    description: "Double 3 until it exceeds 50 (takes 5 doublings)"
  - input: "1\n10\n"
    expectedOutput: "4"
    description: "Double 1 until it exceeds 10 (takes 4 doublings)"
    hidden: true
  - input: "5\n5\n"
    expectedOutput: "1"
    description: "Start at limit boundary (takes 1 doubling)"
    hidden: true
  - input: "2\n20\n"
    expectedOutput: "4"
    description: "Double 2 until it exceeds 20 (takes 4 doublings)"
    hidden: true
  - input: "10\n10\n"
    expectedOutput: "1"
    description: "Start at exact limit (takes 1 doubling)"
    hidden: true
  - input: "4\n100\n"
    expectedOutput: "5"
    description: "Double 4 until it exceeds 100 (takes 5 doublings)"
    hidden: true
  - input: "7\n30\n"
    expectedOutput: "3"
    description: "Double 7 until it exceeds 30 (takes 3 doublings)"
    hidden: true
  - input: "15\n15\n"
    expectedOutput: "1"
    description: "Start at exact limit with 15 (takes 1 doubling)"
    hidden: true
  - input: "1\n1\n"
    expectedOutput: "1"
    description: "Small numbers: 1 exceeds 1 (takes 1 doubling)"
    hidden: true
  - input: "6\n25\n"
    expectedOutput: "3"
    description: "Double 6 until it exceeds 25 (takes 3 doublings)"
    hidden: true
hints:
  - "Use while current_number <= limit: to continue doubling"
  - "Inside the loop: double the current_number and increment doublings counter"
  - "Print progress after each doubling"
  - "Return the doublings counter when done"
solution: |
  start_number = int(input())
  limit = int(input())
  
  current_number = start_number
  doublings = 0
  
  while current_number <= limit:
      current_number *= 2
      doublings += 1
  
  print(doublings)
```

## Key Takeaways: While Loop Mastery

This section has covered the second major loop type. While loop capabilities include:

- **While loops handle uncertain iteration counts** - use them when the number of iterations is unknown
- **Condition-based repetition** - the loop continues as long as your condition is True
- **Always update the condition variable** inside the loop - this prevents infinite loops
- **Master the common patterns**: input validation (keep asking until valid), menu systems (continue until quit), and accumulation until a goal is reached
- **Break and continue** provide control over loop termination and iteration skipping
- **The while-else pattern** is a Python special feature that runs code only if the loop completes normally
- **Debugging tip**: if your loop runs forever, check that something inside the loop changes the condition variable

```note title="Loop Selection Criteria"
**For known iteration counts:** Use a for loop
**For condition-based termination:** Use a while loop
```

The following section covers combining for loops and while loops to solve comprehensive problems that demonstrate practical loop applications.
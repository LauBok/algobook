I# 3.3 While Loops and Common Patterns

## Learning Objectives
By the end of this section, you will:
- üéØ Understand the syntax and use cases for while loops
- ü§î Recognize when to use while loops vs for loops
- üõ†Ô∏è Master common while loop patterns (counting, accumulation, validation)
- ‚úÖ Handle user input validation and menu systems with while loops
- ‚ö†Ô∏è Avoid infinite loops and common while loop pitfalls

## When For Loops Hit Their Limit

For loops are amazing when you know exactly how many repetitions you need. But here's the thing: real-world programming is full of uncertainty.

```hint title="ü§∑‚Äç‚ôÄÔ∏è What if you need to..."
- üîê Keep asking the user for their password until they get it right? (You don't know if it'll take 1 try or 10 tries)
- üé≤ Continue a guessing game until the player finds the right number? (Could be 3 guesses or 20 guesses)  
- üí¨ Process user commands until they type "quit"? (No idea how many commands they'll enter)
- ‚è≥ Wait for a condition to become true? (Might happen immediately or never)
```

In these situations, you don't know the count ahead of time. You know when to *start* repeating, and you know when to *stop*, but you have no clue how many times you'll need to repeat. üîÑ

This is where **while loops** become your best friend!

## Your First While Loop: Persistent Input

Let's start with a scenario that perfectly shows the power of while loops. Imagine you're writing a program that needs a positive number, and you want to keep asking until the user provides one. Here's how to do it:

```python-execute
print("I need a positive number!")

number = float(input("Enter a positive number: "))
while number <= 0:
    print("That's not positive! Try again.")
    number = float(input("Enter a positive number: "))

print(f"Great! {number} is indeed positive.")
```

Beautiful! The program keeps asking until it gets what it wants. ‚ú® Now let's break down the while loop syntax:

```note title="Anatomy of a While Loop üî¨"
```python
while number <= 0:
    # loop body here
```

**Breaking it down:**
- `while` üé¨ - The magic keyword that starts a while loop
- `number <= 0` üßÆ - The **condition** (loop continues while this is True)
- `:` ‚è±Ô∏è - Marks the end of the condition (just like with for loops and if statements)  
- **Indented code** üìù - The body that gets repeated
- The loop continues **as long as** the condition is True ‚úÖ
```

Think of it as: "While this condition is true, keep doing this stuff." üîÑ

```note title="The Key Difference üÜö"
- üî¢ **For loops**: "Do this a specific number of times"
- üîÑ **While loops**: "Keep doing this until something changes"

**For example:**
- For loop: "Print numbers 1 to 10" (exactly 10 times)
- While loop: "Ask for password until correct" (unknown number of times)
```

## The Anatomy of a While Loop üèóÔ∏è

Every while loop has three essential parts that work together:

```hint title="The While Loop Trinity üî∫"
### 1. üèÅ Initialization (before the loop)
```python
# Set up the condition variable
number = float(input("Enter a positive number: "))
```

### 2. üßÆ Condition (the test)  
```python
# The loop continues while this is True
while number <= 0:
```

### 3. üîÑ Update (inside the loop)
```python
# Change something so the condition can eventually become False  
number = float(input("Enter a positive number: "))
```
```

```danger title="Infinite Loop Alert!"
If you forget to update the condition variable inside the loop, it will run forever! Your program will get stuck and never finish. Always make sure something changes inside the loop that can eventually make the condition False.
```

## While Loop vs For Loop: Making the Right Choice

### Use a **for loop** when:
- You know exactly how many repetitions you need
- You're working with sequences (numbers, lists, etc.)
- You're counting or iterating through items

```python-execute
# Perfect for a for loop - we know we want exactly 5 iterations
print("Countdown with for loop:")
for i in range(5, 0, -1):
    print(i)
print("Blast off!")
```

### Use a **while loop** when:
- You don't know how many repetitions you'll need
- You're waiting for a condition to become true/false
- You're validating user input
- You're processing data until you reach the end

```python-execute
# Perfect for a while loop - we don't know how many guesses it will take
import random

secret_number = random.randint(1, 10)
guess = 0

print("I'm thinking of a number between 1 and 10!")

while guess != secret_number:
    guess = int(input("What's your guess? "))
    if guess < secret_number:
        print("Too low!")
    elif guess > secret_number:
        print("Too high!")
    else:
        print(f"Correct! The number was {secret_number}")
        
print("Thanks for playing!")
```

```quiz
id: loop_choice
question: "Which type of loop would be best for calculating the factorial of a number (multiplying all numbers from 1 to n)?"
options:
  - id: a
    text: "For loop, because we know exactly how many numbers to multiply"
    correct: true
    explanation: "Correct! If we want 5!, we know we need to multiply exactly 5 numbers: 1√ó2√ó3√ó4√ó5."
  - id: b
    text: "While loop, because we don't know how many numbers to multiply"
    correct: false
    explanation: "We do know how many numbers - if calculating 5!, we multiply exactly 5 numbers."
  - id: c
    text: "Either would work equally well"
    correct: false
    explanation: "While both could work, a for loop is more natural when you know the exact count."
  - id: d
    text: "Neither - you can't calculate factorials with loops"
    correct: false
    explanation: "Loops are perfect for factorial calculations!"
```

## Common While Loop Patterns üé®

### Pattern 1: Input Validation ‚úÖ

One of the most practical uses of while loops is validating user input:

```python-execute
# Age validation
print("Please enter your age.")
age = input("Age: ")

# Keep asking until we get a valid number
while not age.isdigit() or int(age) < 0 or int(age) > 150:
    print("Please enter a valid age (0-150).")
    age = input("Age: ")

age = int(age)  # Convert to integer once we know it's valid
print(f"Thank you! You are {age} years old.")
```

Here's a more robust validation pattern:

```python-execute
# Grade validation with multiple conditions
print("Let's get your test grade:")
valid_input = False

while not valid_input:
    grade_input = input("Enter your test grade (0-100): ")
    
    # Check if it's a valid number
    if grade_input.replace('.', '', 1).isdigit():
        grade = float(grade_input)
        if 0 <= grade <= 100:
            valid_input = True
            print(f"Thank you! Your grade is {grade}")
        else:
            print("Grade must be between 0 and 100.")
    else:
        print("Please enter a valid number.")
```

### Pattern 2: Menu Systems üçΩÔ∏è

While loops are perfect for creating interactive menus:

```python-execute
# Simple calculator menu
print("Welcome to the Simple Calculator!")

while True:
    print("\nOptions:")
    print("1. Add")
    print("2. Subtract") 
    print("3. Multiply")
    print("4. Divide")
    print("5. Quit")
    
    choice = input("\nChoose an option (1-5): ")
    
    if choice == "5":
        print("Goodbye!")
        break  # Exit the loop
    
    if choice in ["1", "2", "3", "4"]:
        # Get first number
        num1_input = input("First number: ")
        if num1_input.replace('.', '', 1).replace('-', '', 1).isdigit():
            num1 = float(num1_input)
            
            # Get second number  
            num2_input = input("Second number: ")
            if num2_input.replace('.', '', 1).replace('-', '', 1).isdigit():
                num2 = float(num2_input)
                
                if choice == "1":
                    result = num1 + num2
                    print(f"{num1} + {num2} = {result}")
                elif choice == "2":
                    result = num1 - num2
                    print(f"{num1} - {num2} = {result}")
                elif choice == "3":
                    result = num1 * num2
                    print(f"{num1} √ó {num2} = {result}")
                elif choice == "4":
                    if num2 == 0:
                        print("Cannot divide by zero!")
                    else:
                        result = num1 / num2
                        print(f"{num1} √∑ {num2} = {result}")
            else:
                print("Please enter a valid number for the second value.")
        else:
            print("Please enter a valid number for the first value.")
    else:
        print("Invalid choice. Please try again.")
```

### Pattern 3: Processing Until Criteria Met üéØ

Some tasks need to repeat until specific criteria are satisfied, but you don't know how many attempts it will take:

```python-execute
# Password strength checker - keep asking until strong password
print("Create a strong password (at least 8 characters with a number):")
strong_password = False

while not strong_password:
    password = input("Enter password: ")
    
    # Check if password meets criteria
    has_number = False
    for char in password:
        if char.isdigit():
            has_number = True
            break
    
    long_enough = len(password) >= 8
    
    if long_enough and has_number:
        strong_password = True
        print("‚úì Strong password created successfully!")
    else:
        print("Password too weak. Need:")
        if not long_enough:
            print("  - At least 8 characters")
        if not has_number:
            print("  - At least one number")
        print("Try again.")

print("Account setup complete!")
```

```note title="Why While Loop Here? ü§î"
**Why use while instead of for?** We don't know how many attempts the user will need to create a strong password - could be 1 try or 10 tries! 

**Key insight:** The loop continues until the criteria are met, regardless of how many iterations that takes. üîÑ
```

### Pattern 4: Accumulation Until Condition Met

Accumulating values until reaching a goal:

```python-execute
# Save money until you reach a goal
goal = 1000
current_savings = 0
week = 0

print(f"Saving money until you reach ${goal}")

while current_savings < goal:
    week += 1
    weekly_saving = float(input(f"Week {week} - How much can you save? $"))
    current_savings += weekly_saving
    remaining = goal - current_savings
    
    print(f"Total saved: ${current_savings:.2f}")
    
    if remaining > 0:
        print(f"${remaining:.2f} left to reach your goal!")
    else:
        print(f"Congratulations! You've reached your goal in {week} weeks!")
```

### Pattern 5: Guessing Games and Search

Using while loops for interactive problem-solving:

```python-execute
# Number guessing game with attempt counting
import random

secret = random.randint(1, 100)
attempts = 0
max_attempts = 7

print("I'm thinking of a number between 1 and 100!")
print(f"You have {max_attempts} attempts to guess it.")

while attempts < max_attempts:
    guess_input = input(f"\nAttempt {attempts + 1}: What's your guess? ")
    
    # Check if input is a valid number
    if guess_input.isdigit():
        guess = int(guess_input)
        attempts += 1
        
        if guess == secret:
            print(f"Amazing! You guessed it in {attempts} attempts!")
            break
        elif guess < secret:
            remaining = max_attempts - attempts
            print(f"Too low! {remaining} attempts remaining.")
        else:
            remaining = max_attempts - attempts
            print(f"Too high! {remaining} attempts remaining.")
    else:
        print("Please enter a valid number!")
        # Don't increment attempts for invalid input

else:
    # This runs if the loop completes without breaking
    print(f"\nGame over! The number was {secret}.")
    print("Better luck next time!")
```

## Advanced While Loop Techniques

### Using break and continue

```python-execute
# Password system with limited attempts
max_attempts = 3
attempts = 0
correct_password = "python123"

while attempts < max_attempts:
    password = input("Enter password: ")
    attempts += 1
    
    if password == correct_password:
        print("Access granted!")
        break  # Exit the loop immediately
    
    remaining = max_attempts - attempts
    if remaining > 0:
        print(f"Wrong password. {remaining} attempts remaining.")
    else:
        print("Access denied. Too many failed attempts.")
```

### The while-else Pattern

Python has a unique feature where you can add an `else` clause to while loops:

```python-execute
# Search for a specific value
numbers = [3, 7, 12, 18, 25, 31]
target = 18
index = 0

print(f"Searching for {target} in the list...")

while index < len(numbers):
    if numbers[index] == target:
        print(f"Found {target} at position {index}!")
        break
    index += 1
else:
    # This runs only if the loop completed without breaking
    print(f"{target} was not found in the list.")
```

## Converting Between For and While Loops

Many problems can be solved with either type of loop. Here's the same problem solved both ways:

### Sum of numbers 1 to 10 (For Loop)
```python-execute
total = 0
for number in range(1, 11):
    total += number
print(f"Sum using for loop: {total}")
```

### Sum of numbers 1 to 10 (While Loop)
```python-execute
total = 0
number = 1

while number <= 10:
    total += number
    number += 1

print(f"Sum using while loop: {total}")
```

```quiz
id: while_loop_mechanics
question: "What will happen if you forget to update the loop variable inside a while loop?"
options:
  - id: a
    text: "The program will crash with an error"
    correct: false
    explanation: "No error occurs initially - the loop just keeps running forever until you manually stop the program."
  - id: b
    text: "The loop will run exactly once"
    correct: false
    explanation: "The loop will keep running as long as the condition is True."
  - id: c
    text: "The loop will run forever (infinite loop)"
    correct: true
    explanation: "Correct! Without updating the variable, the condition never changes, so the loop never stops."
  - id: d
    text: "Python will automatically update the variable"
    correct: false
    explanation: "Python doesn't automatically update variables - you must do it explicitly."
```

## Debugging While Loops

### Common Mistake 1: Infinite Loops
```python-execute
# WRONG: This would run forever
# counter = 1
# while counter <= 5:
#     print(counter)
#     # Forgot to increment counter!

# CORRECT: Always update the condition variable
counter = 1
while counter <= 5:
    print(counter)
    counter += 1  # Don't forget this!
```

### Common Mistake 2: Off-by-One Errors
```python-execute
# Check your conditions carefully
count = 0

# This prints 0, 1, 2, 3, 4 (5 numbers)
print("Counting to 4:")
while count < 5:
    print(count)
    count += 1

print("\nCounting 1 to 5:")
count = 1
# This prints 1, 2, 3, 4, 5 (5 numbers)
while count <= 5:
    print(count)
    count += 1
```

### Common Mistake 3: Wrong Condition Logic
```python-execute
# Be careful with your condition logic
password = ""

# WRONG: This won't work as expected
# while password == "secret":  # Loop only runs if password is ALREADY correct
#     password = input("Enter password: ")

# CORRECT: Loop continues while password is NOT correct
while password != "secret":
    password = input("Enter password: ")
print("Access granted!")
```

## Real-World Applications

### File Processing Pattern
```python-execute
# Simulating reading lines from a file
lines = ["Line 1", "Line 2", "Line 3", "", "Line 5", ""]  # Empty strings represent blank lines
line_index = 0

print("Processing file lines:")
while line_index < len(lines):
    current_line = lines[line_index]
    if current_line.strip():  # If line is not empty
        print(f"Processing: {current_line}")
    else:
        print("Skipping empty line")
    line_index += 1

print("File processing complete!")
```

### Game Loop Pattern
```python-execute
# Simple coin flip game
import random

player_score = 0
computer_score = 0
rounds_played = 0

print("Welcome to Coin Flip!")
print("Type 'quit' to exit anytime.")

while True:
    user_input = input("\nGuess heads or tails: ").lower()
    
    if user_input == "quit":
        break
    
    if user_input not in ["heads", "tails"]:
        print("Please enter 'heads' or 'tails'")
        continue
    
    # Flip the coin (simple random method)
    coin_result = "heads" if random.randint(1, 2) == 1 else "tails"
    print(f"The coin landed on: {coin_result}")
    
    rounds_played += 1
    
    if user_input == coin_result:
        player_score += 1
        print("You win this round!")
    else:
        computer_score += 1
        print("Computer wins this round!")
    
    print(f"Score - You: {player_score}, Computer: {computer_score}")

if rounds_played > 0:
    print(f"\nFinal Score after {rounds_played} rounds:")
    print(f"You: {player_score}, Computer: {computer_score}")
    if player_score > computer_score:
        print("You won overall! üéâ")
    elif computer_score > player_score:
        print("Computer won overall! ü§ñ")
    else:
        print("It's a tie! ü§ù")

print("Thanks for playing!")
```

## Practice Challenges: Time to Apply Your While Loop Skills

### Challenge 1: Digital Root Calculator
```exercise
id: digital-root
title: Calculate Digital Root
description: Calculate the digital root of a number by repeatedly summing its digits until only one digit remains.
difficulty: easy
starterCode: |
  # Calculate the digital root of a number
  # Digital root: Keep adding the digits of a number until you get a single digit.
  # Example: 987 ‚Üí 9+8+7=24 ‚Üí 2+4=6, so digital root is 6
  
  number = int(input())
  
  if number == 0:
      print(0)
  else:
      # Your code here - use a while loop!
      # Keep summing digits until you have a single digit
      pass
testCases:
  - input: "987\n"
    expectedOutput: "6"
    description: "987 ‚Üí 9+8+7=24 ‚Üí 2+4=6"
  - input: "123\n"
    expectedOutput: "6"
    description: "123 ‚Üí 1+2+3=6"
    hidden: true
  - input: "999\n"
    expectedOutput: "9"
    description: "999 ‚Üí 9+9+9=27 ‚Üí 2+7=9"
    hidden: true
  - input: "0\n"
    expectedOutput: "0"
    description: "Special case: 0 returns 0"
    hidden: true
  - input: "7\n"
    expectedOutput: "7"
    description: "Single digit returns itself"
    hidden: true
  - input: "88\n"
    expectedOutput: "7"
    description: "88 ‚Üí 8+8=16 ‚Üí 1+6=7"
    hidden: true
  - input: "456\n"
    expectedOutput: "6"
    description: "456 ‚Üí 4+5+6=15 ‚Üí 1+5=6"
    hidden: true
  - input: "99\n"
    expectedOutput: "9"
    description: "99 ‚Üí 9+9=18 ‚Üí 1+8=9"
    hidden: true
  - input: "1111\n"
    expectedOutput: "4"
    description: "1111 ‚Üí 1+1+1+1=4"
    hidden: true
  - input: "9876\n"
    expectedOutput: "3"
    description: "9876 ‚Üí 9+8+7+6=30 ‚Üí 3+0=3"
    hidden: true
hints:
  - "Use while number >= 10: to continue until single digit"
  - "Extract digits by using number % 10 for last digit"
  - "Remove last digit with number // 10"
  - "Keep a running sum of digits, then replace number with that sum"
solution: |
  number = int(input())
  
  if number == 0:
      print(0)
  else:
      while number >= 10:
          digit_sum = 0
          temp_number = number
          while temp_number > 0:
              digit_sum += temp_number % 10
              temp_number //= 10
          number = digit_sum
      
      print(number)
```

### Challenge 2: Doubling Number Game
```exercise
id: doubling-game
title: Keep Doubling Until Limit
description: Start with a number and keep doubling it until it exceeds a given limit, counting how many doublings were needed.
difficulty: medium
starterCode: |
  # Keep doubling a number until it exceeds the limit
  # Count how many times we doubled the number
  
  start_number = int(input())
  limit = int(input())
  
  current_number = start_number
  doublings = 0
  
  # Your code here - use a while loop!
  # Keep doubling until current_number exceeds limit
  pass
testCases:
  - input: "3\n50\n"
    expectedOutput: "5"
    description: "Double 3 until it exceeds 50 (takes 5 doublings)"
  - input: "1\n10\n"
    expectedOutput: "4"
    description: "Double 1 until it exceeds 10 (takes 4 doublings)"
    hidden: true
  - input: "5\n5\n"
    expectedOutput: "1"
    description: "Start at limit boundary (takes 1 doubling)"
    hidden: true
  - input: "2\n20\n"
    expectedOutput: "4"
    description: "Double 2 until it exceeds 20 (takes 4 doublings)"
    hidden: true
  - input: "10\n10\n"
    expectedOutput: "1"
    description: "Start at exact limit (takes 1 doubling)"
    hidden: true
  - input: "4\n100\n"
    expectedOutput: "5"
    description: "Double 4 until it exceeds 100 (takes 5 doublings)"
    hidden: true
  - input: "7\n30\n"
    expectedOutput: "3"
    description: "Double 7 until it exceeds 30 (takes 3 doublings)"
    hidden: true
  - input: "15\n15\n"
    expectedOutput: "1"
    description: "Start at exact limit with 15 (takes 1 doubling)"
    hidden: true
  - input: "1\n1\n"
    expectedOutput: "1"
    description: "Small numbers: 1 exceeds 1 (takes 1 doubling)"
    hidden: true
  - input: "6\n25\n"
    expectedOutput: "3"
    description: "Double 6 until it exceeds 25 (takes 3 doublings)"
    hidden: true
hints:
  - "Use while current_number <= limit: to continue doubling"
  - "Inside the loop: double the current_number and increment doublings counter"
  - "Print progress after each doubling"
  - "Return the doublings counter when done"
solution: |
  start_number = int(input())
  limit = int(input())
  
  current_number = start_number
  doublings = 0
  
  while current_number <= limit:
      current_number *= 2
      doublings += 1
  
  print(doublings)
```

## Key Takeaways: While Loop Mastery

You've now mastered the second major type of loop! Here's what you can do with while loops:

- **While loops excel at uncertainty** - use them when you don't know how many iterations you need
- **Condition-based repetition** - the loop continues as long as your condition is True
- **Always update the condition variable** inside the loop - this is crucial to avoid infinite loops!
- **Master the common patterns**: input validation (keep asking until valid), menu systems (continue until quit), and accumulation until a goal is reached
- **Break and continue** give you precise control over when to exit or skip iterations
- **The while-else pattern** is a Python special feature that runs code only if the loop completes normally
- **Debugging tip**: if your loop runs forever, check that something inside the loop changes the condition variable

```hint title="When to Choose While vs For"
Ask yourself: "Do I know how many times I need to repeat this?" 
- **Yes** ‚Üí Use a for loop 
- **No, but I know when to stop** ‚Üí Use a while loop
```

You now have both types of loops in your toolkit. But the real power comes from combining them and understanding when to use each one. That's what we'll practice next!

Next up: **Practice and Review: Building with Loops**, where we'll combine for loops and while loops to solve comprehensive, real-world problems!
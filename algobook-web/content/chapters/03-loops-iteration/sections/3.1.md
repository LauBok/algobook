# Introduction to Loops and Repetition

Recall the contact search algorithm from section 1.1:

> **ALGORITHM: Sequential Contact Search**
> 1. Start at the first contact in the list
> 2. Compare current contact with target name
> 3. If match found, return contact information
> 4. If no match, move to next contact
> 5. **Repeat until target found or list exhausted**

You've learned to implement the decision-making in step 3 using if statements from Chapter 2. This section introduces loops that enable step 5: repeating operations multiple times. Loops transform the contact search from checking a single contact to efficiently searching through hundreds or thousands of contacts.

## The Problem with Manual Repetition

### Contact Search Without Loops

Imagine implementing the contact search algorithm manually by checking each contact individually. For a small contact list with 5 people, you might write:

```python-execute
# Manual contact search - checking 5 contacts individually
target_name = "Sarah Johnson"

# Check contact 1
contact1 = "Alice Smith"
if contact1 == target_name:
    print(f"Found {target_name}!")
    print("Phone: (555) 123-4567")
else:
    print(f"{contact1} is not the target")

# Check contact 2
contact2 = "Bob Wilson"
if contact2 == target_name:
    print(f"Found {target_name}!")
    print("Phone: (555) 234-5678")
else:
    print(f"{contact2} is not the target")

# Check contact 3
contact3 = "Sarah Johnson"
if contact3 == target_name:
    print(f"Found {target_name}!")
    print("Phone: (555) 345-6789")
else:
    print(f"{contact3} is not the target")

# Check contact 4
contact4 = "David Brown"
if contact4 == target_name:
    print(f"Found {target_name}!")
    print("Phone: (555) 456-7890")
else:
    print(f"{contact4} is not the target")

# Check contact 5
contact5 = "Emma Davis"
if contact5 == target_name:
    print(f"Found {target_name}!")
    print("Phone: (555) 567-8901")
else:
    print(f"{contact5} is not the target")
```

This manual approach works for 5 contacts but becomes impractical for a real contact list with hundreds or thousands of entries. Each contact requires nearly identical code with only the name and phone number changing.

```note title="Code Duplication Indicators"
Repetitive code patterns suggest the need for loops. Key indicators include:

- Multiple lines with nearly identical structure
- Only small values changing (variable names or numbers)
- Manual repetition of the same operation
```

## Recognizing Repetitive Patterns

The contact search examples reveal a common repetitive pattern:

**Contact search pattern:**
1. Get a contact name
2. Compare with target name
3. Print result (found or not found)
4. Repeat for the next contact

Both examples follow the same basic structure: perform an operation, then repeat with slightly different data. The specific contact changes, but the comparison and output pattern remains identical.

```note title="Why Manual Repetition Fails"
**The scaling problem:** As the number of items grows, manual repetition becomes:
- 5 repetitions: Manageable but inefficient
- 20 repetitions: Error-prone and time-consuming
- 100+ repetitions: Completely impractical

**The maintenance problem:** Changing logic requires updating every copy, making the code error-prone and difficult to maintain.
```

### Pattern Recognition Example

The following code demonstrates the same repetitive pattern in contact input collection:

```python-execute
# Collecting contact information from user
print("Enter contact information:")

contact1 = input("Contact 1 name: ")
print(f"Added: {contact1}")

contact2 = input("Contact 2 name: ")
print(f"Added: {contact2}")

contact3 = input("Contact 3 name: ")
print(f"Added: {contact3}")

contact4 = input("Contact 4 name: ")
print(f"Added: {contact4}")

print("Contact collection complete!")
```

Each block follows the same pattern:
1. Ask for contact name (`input()`)
2. Display confirmation (`print()`)
3. Repeat for the next contact

The only variable is the contact number.

```quiz
id: pattern_recognition
question: "What makes the contact search example repetitive?"
options:
  - id: a
    text: "We use different variable names"
    correct: false
    explanation: "Variable names don't make code repetitive - it's the repeated operations that matter."
  - id: b
    text: "We perform the same comparison (check if names match) multiple times"
    correct: true
    explanation: "Exactly! The same comparison operation is repeated for each contact."
  - id: c
    text: "We print the results"
    correct: false
    explanation: "Printing isn't what makes it repetitive - it's doing the same comparison over and over."
  - id: d
    text: "We use string data"
    correct: false
    explanation: "The data type doesn't cause repetition - it's the repeated process."
```

## How Loops Solve the Problem

Loops provide an efficient solution to repetitive tasks. Here's a preview of how a loop can handle the contact search:

```python-execute
# Contact search with a loop (preview - syntax explained in next section)
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown", "Emma Davis"]
target_name = "Sarah Johnson"

for contact in contacts:
    if contact == target_name:
        print(f"Found {target_name}!")
        print("Phone: (555) 345-6789")
    else:
        print(f"{contact} is not the target")
```

This loop accomplishes the same result as the manual approach using only 7 lines of code compared to 40+ lines previously. To search through 100 contacts instead of 5 requires no additional code - just more names in the contact list.

### Benefits of Loops

Loops provide significant advantages over manual repetition:

- **Efficiency**: Write once, execute many times
- **Flexibility**: Easily modify to handle more or fewer items
- **Maintainability**: Update logic in one place instead of many
- **Scalability**: Same code works for 5 contacts or 500 contacts

### Two Types of Loops

The next sections introduce two fundamental loop types:

- **For loops**: Used when you want to process each item in a collection (e.g., check every contact in a list)
- **While loops**: Used when you repeat until a condition is met (e.g., keep searching until target found)

Both types enable the "repeat until" step from the contact search algorithm.

```quiz
id: loop_benefits
question: "What's the biggest advantage of using loops instead of copy-pasting code?"
options:
  - id: a
    text: "Loops run faster"
    correct: false
    explanation: "While loops can be efficient, the main benefit is not speed but maintainability and flexibility."
  - id: b
    text: "Loops allow easy modification of repetition count"
    correct: true
    explanation: "Correct! Loops enable repetition of operations 5 times or 500 times by changing a single parameter."
  - id: c
    text: "Loops use less memory"
    correct: false
    explanation: "Memory usage isn't the primary advantage - it's the ability to avoid repetitive code."
  - id: d
    text: "Loops are required by Python"
    correct: false
    explanation: "Python doesn't require loops, but they make repetitive tasks much easier to manage."
```

## Summary

Loops solve the repetition problem in algorithms like contact search:

- Manual repetition becomes impractical for large datasets
- Loops automate repetitive tasks efficiently
- The same loop code works for 5 contacts or 500 contacts
- Pattern recognition helps identify when loops are needed

**What's Next:** The next section introduces for loops, which enable implementing the "repeat until target found" step from the contact search algorithm.
# 3.2 For Loops: Controlled Repetition

## Learning Objectives
By the end of this section, you will:
- Understand the syntax and structure of for loops
- Use the `range()` function to control loop iterations
- Work with loop variables to track progress
- Solve repetitive problems efficiently with for loops

## For Loop Implementation

The countdown problem from Section 3.1 required 10 separate print statements. A for loop provides an efficient alternative:

```python-execute
print("Countdown starting...")
for number in range(10, 0, -1):
    print(number)
print("Blast off!")
```

This implementation uses 4 lines instead of 12. The following breakdown explains each component of the for loop:

```note title="For Loop Structure"
**Basic syntax:**
```python
for number in range(10, 0, -1):
    print(number)
```

**Components:**
- `for` - Keyword that initiates a for loop
- `number` - The loop variable (user-defined name)
- `in` - Connects the loop variable to the sequence
- `range(10, 0, -1)` - Generates numbers from 10 down to 1
- `:` - Marks the end of the loop header
- **Indented code** - The loop body executed for each iteration
```

The loop executes the indented code block for each value in the specified sequence.

```note
**Indentation is crucial.** All code that should be repeated must be indented consistently (4 spaces is the Python standard).
```

## Understanding range(): Number Sequence Generation

The `range()` function provides sequence generation for loops. It produces integers in a specified order based on given parameters.

The `range()` function generates integers within specified bounds, following this critical rule:

```warning title="Important: Stop Value Exclusion"
The `range()` function stops before the stop value. To generate numbers 1, 2, 3, 4, 5, use `range(1, 6)` because 6 is excluded.

**Key principle:**
- The stop value acts as an exclusive upper bound
- The sequence approaches but never includes the stop value
- To generate numbers 1-5, specify `range(1, 6)`
```

The `range()` function has three forms with different parameter combinations:

### 1. range(stop) - Count from 0
Creates numbers starting from 0, stopping before the stop value.

```python-execute
# range(5) creates: 0, 1, 2, 3, 4 (5 excluded)
print("range(5) produces:")
for i in range(5):
    print(f"Number: {i}")
print("Notice: 5 is not included")
```

### 2. range(start, stop) - Custom starting point
Creates numbers from start up to (but not including) stop.

```python-execute
# range(3, 8) creates: 3, 4, 5, 6, 7 (8 excluded)
print("range(3, 8) produces:")
for i in range(3, 8):
    print(f"Number: {i}")
print("Notice: 8 is not included")
```

### 3. range(start, stop, step) - Custom increment
Creates numbers from start, incrementing by step, stopping before stop.

```python-execute
# range(0, 11, 2) creates: 0, 2, 4, 6, 8, 10 (11 excluded)
print("Even numbers - range(0, 11, 2):")
for i in range(0, 11, 2):
    print(f"Number: {i}")
print("Notice: 11 is not included")

# range(5, 0, -1) creates: 5, 4, 3, 2, 1 (0 excluded)
print("\nCountdown - range(5, 0, -1):")
for i in range(5, 0, -1):
    print(f"Number: {i}")
print("Notice: 0 is not included")
```

The following table summarizes common `range()` patterns:

```table
title: Common range() Examples
headers: ["Code", "What it creates", "Key point"]
rows:
  - ["`range(5)`", "0, 1, 2, 3, 4", "**5 is excluded**"]
  - ["`range(1, 6)`", "1, 2, 3, 4, 5", "**6 is excluded**"]
  - ["`range(2, 10, 3)`", "2, 5, 8", "**10 is excluded**"]
  - ["`range(10, 0, -2)`", "10, 8, 6, 4, 2", "**0 is excluded**"]
sortable: false
searchable: false
```

```note title="Memory Aid"
**"Stop means stop before"**
- The stop value serves as an exclusive upper bound
- The sequence approaches but never includes this value
- To generate 1-5, use `range(1, 6)` which stops before 6
```

```quiz
id: range_understanding
question: "What will `range(2, 10, 3)` produce?"
options:
  - id: a
    text: "2, 5, 8"
    correct: true
    explanation: "Correct! Start at 2, go up by 3 each time, stop before 10: 2, 5, 8."
  - id: b
    text: "2, 5, 8, 11"
    correct: false
    explanation: "Close, but 11 exceeds the stop value of 10, so it's not included."
  - id: c
    text: "2, 3, 4, 5, 6, 7, 8, 9"
    correct: false
    explanation: "This would be range(2, 10, 1). The step is 3, not 1."
  - id: d
    text: "2, 10, 3"
    correct: false
    explanation: "Range generates a sequence based on start, stop, step - not the literal values."
```

### Working with Loop Variables

The loop variable (like `i` or `number` in our examples) is automatically updated each iteration:

```python-execute
print("Loop variable in action:")
for counter in range(1, 6):
    print(f"This is iteration number {counter}")
    print(f"  Double of {counter} is {counter * 2}")
    print(f"  Square of {counter} is {counter ** 2}")
    print("---")
```

```note title="Variable Naming Best Practices"
Use descriptive variable names to improve code readability. Choose names that clearly indicate the loop variable's purpose.

**Clear examples:**
- `for student in range(class_size):`
- `for day in range(1, 8):`
- `for temperature in range(0, 101, 10):`

**Less descriptive:**
- `for i in range(30):` (unclear what i represents)
```

## Practical For Loop Applications

For loops provide efficient solutions to the repetitive problems demonstrated in Section 3.1. The following examples illustrate practical implementations:

### Problem 1: Compound Interest Calculator
```python-execute
# Calculate compound interest over multiple years
principal = 1000
rate = 0.05  # 5% annual interest
years = 5

print(f"Starting amount: ${principal:.2f}")
print(f"Interest rate: {rate*100}% per year")
print(f"Calculating growth over {years} years:\n")

for year in range(1, years + 1):
    principal = principal * (1 + rate)
    print(f"Year {year}: ${principal:.2f}")

print(f"\nFinal amount after {years} years: ${principal:.2f}")
```

This loop-based approach eliminates the manual repetition required in Section 3.1. To calculate for 30 years instead of 5, only one parameter needs modification: `years = 30`. This contrasts with writing 30 separate calculations manually.

### Problem 2: Grade Average Calculator
```python-execute
# Calculate average of test scores
num_tests = 4
total_score = 0

print(f"Enter {num_tests} test scores:")

for test_num in range(1, num_tests + 1):
    score = float(input(f"Test {test_num}: "))
    total_score += score

average = total_score / num_tests
print(f"\nYour average score: {average:.2f}")

# Determine letter grade
if average >= 90:
    letter_grade = "A"
elif average >= 80:
    letter_grade = "B"
elif average >= 70:
    letter_grade = "C"
elif average >= 60:
    letter_grade = "D"
else:
    letter_grade = "F"

print(f"Letter grade: {letter_grade}")
```

This implementation demonstrates the pattern clearly. Instead of writing separate input statements for Test 1, Test 2, Test 3, and Test 4, the loop handles all repetition. The loop variable `test_num` automatically changes from 1 to 2 to 3 to 4, generating different prompts each time.

## Common For Loop Patterns: Building Your Toolkit

This section examines the most common for loop patterns. These patterns form a programming toolkit that enables solving various problems once recognized.

### Pattern 1: Accumulation (Building Up a Total)
```python-execute
# Sum of numbers from 1 to 10
total = 0
for number in range(1, 11):
    total += number  # Add each number to the total

print(f"Sum of numbers 1 to 10: {total}")
```

```note title="The Accumulation Pattern"
This represents the most common pattern in loop programming. **The strategy:**

1. **Initialize**: Begin with a neutral value (usually 0 for sums)
2. **Iterate**: Process each item in sequence
3. **Accumulate**: Add/combine each new value with the running total
4. **Complete**: The accumulated value contains the final result

**Common uses:** Calculating sums, averages, running totals, building strings
```

### Pattern 2: Counting/Tracking (Keeping Score)
```python-execute
# Count how many numbers from 1 to 20 are divisible by 3
count = 0
for number in range(1, 21):
    if number % 3 == 0:
        print(f"{number} is divisible by 3")
        count += 1

print(f"\nTotal numbers divisible by 3: {count}")
```

```note title="The Counting Pattern"
**The strategy:**
1. **Initialize**: Begin with count = 0
2. **Iterate**: Check each item in sequence
3. **Test**: Determine if this item meets the criteria
4. **Count**: If criteria met, increment the counter
5. **Report**: Display the final count

**Typical applications:** Counting occurrences, finding items that match conditions, statistical analysis
```

### Pattern 3: Generating Output (Creating Something Each Time)
```python-execute
# Create a multiplication table
number = 7
print(f"Multiplication table for {number}:")

for i in range(1, 11):
    result = number * i
    print(f"{number} √ó {i} = {result}")
```

```note title="The Generation Pattern"
**The strategy:**
1. **Setup**: Prepare required values and parameters
2. **Iterate**: Process each item in the sequence
3. **Calculate**: Apply operations using the loop variable
4. **Output**: Display or store the computed result
5. **Continue**: Repeat for each subsequent value

**Applications:** Multiplication tables, formatted reports, sequential calculations
```

### Interactive Example: Temperature Conversion

The following example demonstrates temperature conversion:

```python-execute
# Temperature converter: Celsius to Fahrenheit
print("Temperature Conversion (Celsius to Fahrenheit)")
print("=" * 40)

for celsius in range(0, 101, 10):  # 0 to 100, every 10 degrees
    fahrenheit = (celsius * 9/5) + 32
    print(f"{celsius}¬∞C = {fahrenheit}¬∞F")
```

```quiz
id: for_loop_syntax
question: "In the code `for day in range(1, 8):`, how many times will the loop run?"
options:
  - id: a
    text: "8 times"
    correct: false
    explanation: "Remember, range(1, 8) stops before 8, so it includes 1, 2, 3, 4, 5, 6, 7."
  - id: b
    text: "7 times"
    correct: true
    explanation: "Correct! range(1, 8) produces 1, 2, 3, 4, 5, 6, 7 - seven numbers total."
  - id: c
    text: "6 times"
    correct: false
    explanation: "That would be range(1, 7). The range goes from start to stop-1."
  - id: d
    text: "1 time"
    correct: false
    explanation: "The loop runs once for each number in the range sequence."
```

```hint title="Experiment Challenge üß™"
**Try this challenge**: Change the range from 0 to 101 to be -20 to 41 (that's -4¬∞F to 105¬∞F). Or change the step from 10 to 5 for more precise readings. 

**The power of loops:** One small change affects the entire output! This is why loops are so much better than copy-paste. üí™
```

### Nested Loops: Loops Inside Loops

Nested loops place one loop inside another loop, creating useful patterns for certain applications. The following example demonstrates this concept:

```python-execute
# Create a simple pattern
rows = 4

for row in range(1, rows + 1):
    print(f"Row {row}: ", end="")
    for star in range(row):
        print("*", end="")
    print()  # New line after each row
```

```note title="Nested Loop Walkthrough üë£"
The execution proceeds as follows:
- **Row 1**: The inner loop runs 1 time ‚Üí prints 1 star ‚≠ê
- **Row 2**: The inner loop runs 2 times ‚Üí prints 2 stars ‚≠ê‚≠ê  
- **Row 3**: The inner loop runs 3 times ‚Üí prints 3 stars ‚≠ê‚≠ê‚≠ê
- **Row 4**: The inner loop runs 4 times ‚Üí prints 4 stars ‚≠ê‚≠ê‚≠ê‚≠ê

**The key insight:** 
- üåê **Outer loop** controls which row we're on
- üîÑ **Inner loop** controls how many stars to print for that row
```

```warning title="Nested Loop Caution ‚ö†Ô∏è"
Nested loops can become complex quickly. Begin with simple single loops before progressing to nested structures, as they often present challenges for beginners.

**Pro tip:** Always trace through nested loops step by step when learning. üîç
```

### Common For Loop Mistakes

Even experienced programmers make these mistakes. The following sections identify and explain how to fix the most common ones:

### Mistake 1: Off-by-One Errors
```python-execute
# WRONG: Trying to print numbers 1 to 5
print("This prints 0 to 4:")
for i in range(5):
    print(i)

print("\nThis prints 1 to 5:")
for i in range(1, 6):  # Remember: stop is NOT included
    print(i)
```

```danger title="Off-by-One Error Alert üö®"
**Remember:** If you want numbers 1 to 5, you need `range(1, 6)` because the stop value (6) is not included!

**Common mistakes:**
- ‚ùå `range(5)` for numbers 1-5 (gives 0-4)
- ‚ùå `range(1, 5)` for numbers 1-5 (gives 1-4)  
- ‚úÖ `range(1, 6)` for numbers 1-5 (gives 1-5)
```

### Mistake 2: Indentation Errors
```python-execute
# WRONG: Not all code is indented
for i in range(3):
    print(f"Inside loop: {i}")
print("This runs after each iteration")  # Should be indented if part of loop

print("\n" + "="*30)

# CORRECT: Proper indentation
for i in range(3):
    print(f"Inside loop: {i}")
    print("This also runs for each iteration")
print("This runs once, after the loop completes")
```

```warning title="Indentation Matters! üìè"
Python uses indentation to determine what's inside your loop. 

**The rule:**
- üîÑ **Inside the loop**: Must be indented (4 spaces)
- üö™ **After the loop**: Back to the original indentation level

**If you want something to happen every time through the loop, it must be indented at the same level as the rest of the loop body.**
```

### Mistake 3: Changing Loop Variable
```python-execute
# AVOID: Modifying the loop variable (confusing)
print("Don't do this:")
for i in range(5):
    print(f"i is {i}")
    i = 100  # This doesn't actually affect the next iteration!
```

```note title="Let the Loop Drive üöó"
**The for loop manages the loop variable for you.** Trying to change it manually just leads to confusion.

**Why this doesn't work:**
- The for loop controls the variable automatically
- Your changes get overwritten on the next iteration  
- It makes your code confusing to read

**Bottom line:** Let the loop do its job! ü§ñ
```

### Practice Challenges

The following challenges combine the patterns covered in this section:

### Challenge 1: Fibonacci-ish Sequence
The following example creates a Fibonacci-like sequence where each number is the sum of the two preceding ones, starting with 1, 1:

```python-execute
# Fibonacci-like sequence: 1, 1, 2, 3, 5, 8, 13...
a, b = 1, 1
print(f"{a}, {b}", end="")  # end="" prevents automatic newline

for i in range(8):  # Generate 8 more numbers
    next_num = a + b
    print(f", {next_num}", end="")
    a, b = b, next_num
print()  # New line at the end
```

This uses some advanced techniques (like `a, b = b, next_num` which assigns multiple variables simultaneously), but the core is still a simple for loop!

### Challenge 2: Prime Number Detective
The following example checks if numbers from 2 to 20 are prime (divisible only by 1 and themselves):

```python-execute
print("Prime numbers from 2 to 20:")

for num in range(2, 21):
    is_prime = True
    
    # Check if num is divisible by any number from 2 to num-1
    for divisor in range(2, num):
        if num % divisor == 0:
            is_prime = False
            break  # No need to check further
    
    if is_prime:
        print(f"{num} is prime")
```

This example uses nested loops (a loop inside a loop) to check every possible divisor. Notice how we combine the counting pattern (tracking `is_prime`) with the generation pattern (checking each number).

## Key Takeaways: Your For Loop Mastery

This section has covered one of the fundamental tools in programming. Key concepts include:

- **For loops** are optimal when the number of repetitions is known
- **`range()` function** generates sequences - the stop value is excluded
- **Loop variables** automatically update each iteration
- **Indentation** determines which code belongs to the loop body
- **Common patterns** include accumulation, counting, and output generation
- Begin with simple loops before progressing to nested structures

```note title="Practice Strategy"
**Effective for loop implementation**: Identify repetitive elements and variable components. The changing element typically becomes the loop variable, while the repetitive logic forms the loop body.
```

For loops enable automation when the iteration count is predetermined. While loops, covered in the next section, handle scenarios with unknown iteration counts.

The next section covers while loops, which continue until a specified condition is met.
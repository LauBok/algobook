# For Loops: Controlled Repetition

Recall the contact search algorithm and the manual repetition problem from Section 3.1. You saw how manually checking each contact required nearly identical code repeated for every contact. For loops provide the solution to this repetition problem by automating the "repeat for next contact" step.

## For Loop Basics

Here's how a for loop solves the contact search repetition:

```python-execute
# Contact search using a for loop
# This is a list - a container that holds multiple items (details in Chapter 4)
contacts = ["Alice Smith", "Bob Wilson", "Sarah Johnson", "David Brown", "Emma Davis"]
target_name = "Sarah Johnson"

for contact in contacts:
    if contact == target_name:
        print(f"Found {target_name}!")
        print("Phone: (555) 345-6789")
    else:
        print(f"{contact} is not the target")
```

This implementation uses 8 lines instead of 40+ lines from the manual approach. The following breakdown explains each component of the for loop:

```note title="For Loop Structure"
**Basic syntax:**
```python
for contact in contacts:
    print(contact)
```

**Components:**
- `for` - Keyword that initiates a for loop
- `contact` - The loop variable (user-defined name)
- `in` - Connects the loop variable to the sequence
- `contacts` - The list of items to process
- `:` - Marks the end of the loop header
- **Indented code** - The loop body executed for each iteration
```

The loop executes the indented code block for each value in the specified sequence. All code that should be repeated must be indented consistently (4 spaces is the Python standard).

## Using range() for Number Sequences

The `range()` function generates sequences of numbers for use in loops. This is useful when you need to repeat something a specific number of times or work with numbered items. The critical rule to remember: **the stop value is excluded**.

```warning title="Important: Stop Value Exclusion"
The `range()` function stops before the stop value. To generate numbers 1, 2, 3, 4, 5, use `range(1, 6)` because 6 is excluded.
```

The `range()` function has three forms with different parameter combinations:

### 1. range(stop) - Count from 0
Creates numbers starting from 0, stopping before the stop value.

```python-execute
# Process 5 contacts using position numbers
print("Processing contacts by number:")
for i in range(5):
    print(f"Processing contact {i}")
print("Notice: range(5) gave us 0, 1, 2, 3, 4")
```

### 2. range(start, stop) - Custom starting point
Creates numbers from start up to (but not including) stop.

```python-execute
# Process contacts 2 through 4
print("Processing contacts 2-4:")
for i in range(2, 5):
    print(f"Processing contact {i}")
print("Notice: range(2, 5) gave us 2, 3, 4")
```

### 3. range(start, stop, step) - Custom increment
Creates numbers from start, incrementing by step, stopping before stop.

```python-execute
# Process every other contact number
print("Processing every other contact:")
for i in range(0, 11, 2):
    print(f"Processing contact {i}")
print("Notice: range(0, 11, 2) gave us 0, 2, 4, 6, 8, 10")
```

The following table summarizes common `range()` patterns:

```table
title: Common range() Examples
headers: ["Code", "What it creates", "Key point"]
rows:
  - ["`range(5)`", "0, 1, 2, 3, 4", "**5 is excluded**"]
  - ["`range(1, 6)`", "1, 2, 3, 4, 5", "**6 is excluded**"]
  - ["`range(2, 10, 3)`", "2, 5, 8", "**10 is excluded**"]
  - ["`range(10, 0, -2)`", "10, 8, 6, 4, 2", "**0 is excluded**"]
sortable: false
searchable: false
```

```note title="Memory Aid"
**"Stop means stop before"**
- The stop value serves as an exclusive upper bound
- The sequence approaches but never includes this value
- To generate 1-5, use `range(1, 6)` which stops before 6
```

```quiz
id: range_understanding
question: "What will `range(2, 10, 3)` produce?"
options:
  - id: a
    text: "2, 5, 8"
    correct: true
    explanation: "Correct! Start at 2, go up by 3 each time, stop before 10: 2, 5, 8."
  - id: b
    text: "2, 5, 8, 11"
    correct: false
    explanation: "Close, but 11 exceeds the stop value of 10, so it's not included."
  - id: c
    text: "2, 3, 4, 5, 6, 7, 8, 9"
    correct: false
    explanation: "This would be range(2, 10, 1). The step is 3, not 1."
  - id: d
    text: "2, 10, 3"
    correct: false
    explanation: "Range generates a sequence based on start, stop, step - not the literal values."
```

### Working with Loop Variables

The loop variable (like `i` or `number` in our examples) is automatically updated each iteration:

```python-execute
print("Loop variable in action:")
for counter in range(1, 6):
    print(f"This is iteration number {counter}")
    print(f"  Double of {counter} is {counter * 2}")
    print(f"  Square of {counter} is {counter ** 2}")
    print("---")
```

```note title="Variable Naming Best Practices"
Use descriptive variable names to improve code readability. Choose names that clearly indicate the loop variable's purpose.

**Clear examples:**
- `for student in range(class_size):`
- `for day in range(1, 8):`
- `for temperature in range(0, 101, 10):`

**Less descriptive:**
- `for i in range(30):` (unclear what i represents)
```

## Practical For Loop Applications

For loops provide efficient solutions to the repetitive problems demonstrated in Section 3.1. The following examples show practical contact processing applications:

### Contact Directory Display
```python-execute
# Display numbered contact directory using range
print("=== Contact Directory ===")
for contact_num in range(1, 6):
    print(f"{contact_num}. Contact {contact_num} Name")
    print(f"   Phone: (555) {contact_num}23-456{contact_num}")
    print()
```

This loop-based approach eliminates the manual repetition required in Section 3.1. To display 100 contacts instead of 5, only the range needs to change - the loop code remains unchanged.

### Contact Collection System
```python-execute
# Collect multiple contacts from user
num_contacts = 4

print(f"Enter {num_contacts} contact names:")

for contact_num in range(1, num_contacts + 1):
    name = input(f"Contact {contact_num}: ")
    print(f"Added: {name}")

print("Contact collection complete!")
```

This implementation demonstrates the pattern clearly. Instead of writing separate input statements for Contact 1, Contact 2, Contact 3, and Contact 4, the loop handles all repetition. The loop variable `contact_num` automatically changes from 1 to 2 to 3 to 4, generating different prompts each time.



```quiz
id: for_loop_syntax
question: "In the code `for day in range(1, 8):`, how many times will the loop run?"
options:
  - id: a
    text: "8 times"
    correct: false
    explanation: "Remember, range(1, 8) stops before 8, so it includes 1, 2, 3, 4, 5, 6, 7."
  - id: b
    text: "7 times"
    correct: true
    explanation: "Correct! range(1, 8) produces 1, 2, 3, 4, 5, 6, 7 - seven numbers total."
  - id: c
    text: "6 times"
    correct: false
    explanation: "That would be range(1, 7). The range goes from start to stop-1."
  - id: d
    text: "1 time"
    correct: false
    explanation: "The loop runs once for each number in the range sequence."
```

## Common For Loop Mistakes

Understanding common mistakes helps you write correct for loops from the start:

### Off-by-One Errors
```python-execute
# WRONG: Trying to print numbers 1 to 5
print("This prints 0 to 4:")
for i in range(5):
    print(i)

print("\nThis prints 1 to 5:")
for i in range(1, 6):  # Remember: stop value is excluded
    print(i)
```

Remember: if you want numbers 1 to 5, you need `range(1, 6)` because the stop value (6) is not included.

### Indentation Errors
```python-execute
# WRONG: Inconsistent indentation
for i in range(3):
    print(f"Inside loop: {i}")
print("This runs after the entire loop")  # Not indented = outside loop

print("\n" + "="*30)

# CORRECT: Proper indentation
for i in range(3):
    print(f"Inside loop: {i}")
    print("This also runs for each iteration")  # Indented = inside loop
print("This runs once, after the loop completes")
```

Python uses indentation to determine what code belongs inside the loop. All code that should repeat must be indented consistently.

## Summary

For loops provide the solution to repetitive tasks in programming:

- **For loops** process each item in a sequence automatically
- **`range()` function** generates number sequences - the stop value is excluded
- **Loop variables** update automatically with each iteration
- **Indentation** determines which code belongs inside the loop
- **Common patterns** include processing items, counting matches, and building results

You can now implement the "repeat for each contact" step from the contact search algorithm using for loops.

**What's Next:** The next section covers while loops, which repeat until a condition is met rather than for a predetermined number of times.
# Practice and Review: Building with Loops

```note title="Loop Integration"
This section combines loop types to solve complex problems and demonstrates appropriate loop selection for different scenarios.
```

## Learning Objectives

By the end of this section, you will be able to:

- Combine different loop types to tackle complex, multi-step problems
- Choose the appropriate loop type for each situation
- Apply loop patterns to solve practical, real-world challenges
- Demonstrate mastery through hands-on coding exercises

## Loop Review

Two fundamental loop types have been introduced, each with distinct strengths. This section demonstrates how to combine them to solve real-world programming problems.

```note title="Loop Selection Principle"
Effective loop usage requires understanding when to apply each type based on problem characteristics and iteration requirements.
```

A review of the two fundamental loop types:

### For Loops: Precision Tool

**Perfect when:** You know exactly how many times to repeat

```python-execute
# Use for loops when you know exactly how many times to repeat
print("Countdown from 5:")
for i in range(5, 0, -1):
    print(f"{i}...")
print("Blast off!")
```

### While Loops: Flexible Tool

**Perfect when:** You repeat until a condition is met (unknown number of iterations)

```python-execute
# Use while loops when you repeat until a condition is met
print("Keep guessing until you get 7:")
import random
secret = 7
guess = 0

while guess != secret:
    guess = int(input("Your guess: "))
    if guess != secret:
        print("Try again!")
    else:
        print("Correct!")
```

```note title="Loop Type Specialization"
Each loop type has optimal use cases: for loops excel with known quantities, while loops handle uncertainty effectively. Combining them in the same program provides comprehensive solutions.
```

## Practice Challenges: Real-World Problem Solving

The following challenges demonstrate how loops solve practical programming problems:

### Challenge 1: Grade Calculator with Validation

```note title="Challenge Focus"
**Practice objective:** Combining loop types strategically
**Application:** Input validation and data processing
**Key concept:** Selecting appropriate loop types for specific tasks
```

This challenge demonstrates effective loop type combination:
- **For loop:** Known number of students
- **While loop:** Unknown number of validation attempts

```python-execute
# Grade Calculator - Practice combining loops
print("=== Class Grade Calculator ===")

# First, ask how many students (for loop will use this)
num_students = int(input("How many students? "))

total_points = 0
student_count = 0

# Use for loop since we know exact number of students
for student_num in range(1, num_students + 1):
    print(f"\nStudent {student_num}:")
    
    # Use while loop to keep asking until valid grade
    valid_grade = False
    while not valid_grade:
        grade = float(input("Enter grade (0-100): "))
        if 0 <= grade <= 100:
            valid_grade = True
            total_points += grade
            student_count += 1
        else:
            print("Grade must be between 0 and 100!")

# Calculate and display results
average = total_points / student_count
print(f"\nClass Results:")
print(f"Total students: {student_count}")
print(f"Class average: {average:.1f}")

if average >= 90:
    print("Excellent class performance!")
elif average >= 80:
    print("Good class performance!")
elif average >= 70:
    print("Acceptable class performance.")
else:
    print("Class needs improvement.")
```

```note title="Loop Combination Strategy"
**Implementation approach:**

**Outer for loop:** Handles known quantity (number of students)
**Inner while loop:** Handles unknown quantity (validation attempts)

**Benefits:**
- Each loop performs its optimal function
- Clear separation of concerns
- Robust code structure

This pattern is common in professional programming applications.
```

### Challenge 2: Pattern Maker with Nested Loops

Nested loops (loops inside loops) are perfect for creating patterns. The outer loop typically controls rows, and the inner loop controls what appears in each row:

```python-execute
# Number Pattern Maker - Practice nested loops
print("=== Number Pattern Maker ===")

rows = int(input("How many rows for the pattern? "))

# Pattern 1: Number triangle
print("\nPattern 1 - Number Triangle:")
for row in range(1, rows + 1):
    for num in range(1, row + 1):
        print(num, end=" ")
    print()  # New line after each row

# Pattern 2: Star rectangle  
print(f"\nPattern 2 - Star Rectangle ({rows} x {rows}):")
for row in range(rows):
    for col in range(rows):
        print("*", end=" ")
    print()  # New line after each row
```

```note title="Pattern Building Logic üìê"
**Observe the pattern:**

‚û°Ô∏è Row 1 has **1 number**  
‚û°Ô∏è Row 2 has **2 numbers**  
‚û°Ô∏è Row 3 has **3 numbers**  

**The key insight:** The outer loop (row number) determines how many times the inner loop (numbers) should run!

üéØ **This pattern is everywhere:** tables, grids, game boards, pixel art!
```

### Challenge 3: Interactive Calculator Menu

```note title="üéØ Challenge Focus"
**What you'll practice:** While loops for user-driven programs  
**Real-world application:** Menu systems, interactive applications, user interfaces  
**Key insight:** How to keep programs running until the user decides to quit
```

This example showcases while loops perfectly! We don't know how many calculations the user wants to do, but we keep the program running until they choose to quit:

```python-execute
# Simple Calculator Menu - Practice while loops and decision making
print("=== Simple Calculator ===")

running = True
while running:
    print("\nOptions:")
    print("1. Add two numbers")
    print("2. Subtract two numbers") 
    print("3. Multiply two numbers")
    print("4. Quit")
    
    choice = input("Choose option (1-4): ")
    
    if choice == "1":
        num1 = float(input("First number: "))
        num2 = float(input("Second number: "))
        result = num1 + num2
        print(f"Result: {num1} + {num2} = {result}")
        
    elif choice == "2":
        num1 = float(input("First number: "))
        num2 = float(input("Second number: "))
        result = num1 - num2
        print(f"Result: {num1} - {num2} = {result}")
        
    elif choice == "3":
        num1 = float(input("First number: "))
        num2 = float(input("Second number: "))
        result = num1 * num2
        print(f"Result: {num1} √ó {num2} = {result}")
        
    elif choice == "4":
        print("Thanks for using the calculator!")
        running = False
        
    else:
        print("Invalid choice. Please try again.")
```

```note title="üçΩÔ∏è Menu-Driven Programs"
This represents a classic **menu-driven program structure**‚Äîthis pattern appears frequently in professional software!

**Why this works so well:**

‚úÖ **User controls the flow** ‚Üí program runs until they choose to quit  
üîÑ **Always responsive** ‚Üí handles user input gracefully  
üìù **Clean structure** ‚Üí easy to read and maintain  
üîß **Easily extensible** ‚Üí simple to add new menu options  

**Real-world examples:** ATM machines, restaurant ordering systems, game menus, admin dashboards
```

### Independent Practice

```note title="üí™ Time to Level Up!"
These exercises provide opportunities to implement loops independently. Each exercise builds loop intuition and problem-solving confidence through hands-on practice.
```

Working through problems independently builds programming skills more effectively than immediately viewing solutions. Analyzing logic, making mistakes, and learning from them develops stronger problem-solving abilities.

### Skill-Building Challenges

#### Exercise 1: The $3x+1$ Problem (Collatz Conjecture)

**Skills practiced:** While loops, conditionals, mathematical problem-solving  
**Difficulty:** Medium
```exercise
id: collatz-conjecture
title: Count Steps to Reach 1 in $3x+1$ Sequence
description: Implement the famous $3x+1$ problem and count how many steps it takes to reach 1.
difficulty: medium
starterCode: |
  # Count how many steps it takes to reach 1 using the 3x+1 rule:
  # - If n is even: divide by 2  
  # - If n is odd: multiply by 3 and add 1
  # - Continue until n becomes 1
  
  n = int(input())
  steps = 0
  
  # Your code here - use a while loop!
  # Keep going until n becomes 1
  pass
testCases:
  - input: "3\n"
    expectedOutput: "7"
    description: "3‚Üí10‚Üí5‚Üí16‚Üí8‚Üí4‚Üí2‚Üí1 (7 steps)"
  - input: "1\n"
    expectedOutput: "0"
    description: "Already at 1, so 0 steps needed"
  - input: "2\n"
    expectedOutput: "1"
    description: "2‚Üí1 (1 step)"
    hidden: true
  - input: "4\n"
    expectedOutput: "2"
    description: "4‚Üí2‚Üí1 (2 steps)"
    hidden: true
  - input: "5\n"
    expectedOutput: "5"
    description: "5‚Üí16‚Üí8‚Üí4‚Üí2‚Üí1 (5 steps)"
    hidden: true
  - input: "6\n"
    expectedOutput: "8"
    description: "6‚Üí3‚Üí10‚Üí5‚Üí16‚Üí8‚Üí4‚Üí2‚Üí1 (8 steps)"
    hidden: true
  - input: "7\n"
    expectedOutput: "16"
    description: "7 takes 16 steps to reach 1"
    hidden: true
  - input: "8\n"
    expectedOutput: "3"
    description: "8‚Üí4‚Üí2‚Üí1 (3 steps)"
    hidden: true
  - input: "9\n"
    expectedOutput: "19"
    description: "9 takes 19 steps to reach 1"
    hidden: true
  - input: "10\n"
    expectedOutput: "6"
    description: "10‚Üí5‚Üí16‚Üí8‚Üí4‚Üí2‚Üí1 (6 steps)"
    hidden: true
hints:
  - "Use a while loop that continues as long as n is not equal to 1"
  - "Inside the loop, check if n is even (n % 2 == 0) or odd"
  - "If even: n = n // 2, if odd: n = n * 3 + 1"
  - "Count each step and return the total when n reaches 1"
solution: |
  n = int(input())
  steps = 0
  
  while n != 1:
      if n % 2 == 0:
          n = n // 2
      else:
          n = n * 3 + 1
      steps += 1
  
  print(steps)
```

#### Exercise 2: Sum of Powers Calculator

**Skills practiced:** For loops, mathematical operations, accumulator pattern
**Difficulty:** Easy

```exercise
id: sum-of-powers
title: Calculate Sum of Consecutive Powers
description: Calculate the sum of consecutive integers each raised to a specified power.
difficulty: easy
starterCode: |
  # Calculate the sum of consecutive integers raised to a power
  # For example: start=2, count=3, power=2 means 2¬≤ + 3¬≤ + 4¬≤ = 4 + 9 + 16 = 29
  
  start = int(input())
  count = int(input())
  power = int(input())
  
  total = 0
  
  # Your code here - use a for loop!
  # Add each number raised to the power to the total
  pass
testCases:
  - input: "2\n3\n2\n"
    expectedOutput: "29"
    description: "$2^2 + 3^2 + 4^2 = 4 + 9 + 16 = 29$"
  - input: "1\n4\n1\n"
    expectedOutput: "10"
    description: "$1^1 + 2^1 + 3^1 + 4^1 = 1 + 2 + 3 + 4 = 10$"
  - input: "3\n2\n3\n"
    expectedOutput: "91"
    description: "$3^3 + 4^3 = 27 + 64 = 91$"
    hidden: true
  - input: "1\n5\n2\n"
    expectedOutput: "55"
    description: "$1^2 + 2^2 + 3^2 + 4^2 + 5^2 = 1 + 4 + 9 + 16 + 25 = 55$"
    hidden: true
  - input: "5\n1\n4\n"
    expectedOutput: "625"
    description: "$5^4 = 625$"
    hidden: true
  - input: "2\n4\n1\n"
    expectedOutput: "14"
    description: "$2^1 + 3^1 + 4^1 + 5^1 = 2 + 3 + 4 + 5 = 14$"
    hidden: true
  - input: "1\n3\n3\n"
    expectedOutput: "36"
    description: "$1^3 + 2^3 + 3^3 = 1 + 8 + 27 = 36$"
    hidden: true
  - input: "0\n3\n2\n"
    expectedOutput: "5"
    description: "$0^2 + 1^2 + 2^2 = 0 + 1 + 4 = 5$"
    hidden: true
  - input: "4\n3\n0\n"
    expectedOutput: "3"
    description: "$4^0 + 5^0 + 6^0 = 1 + 1 + 1 = 3$ (any number to power 0 is 1)"
    hidden: true
  - input: "10\n2\n1\n"
    expectedOutput: "21"
    description: "$10^1 + 11^1 = 10 + 11 = 21$"
    hidden: true
hints:
  - "Use a for loop to process 'count' consecutive numbers starting from 'start'"
  - "Use ** operator to calculate powers (e.g., 3**2 = 9)"
  - "Add each powered result to a running total"
  - "range(start, start + count) gives you the consecutive numbers you need"
solution: |
  start = int(input())
  count = int(input())
  power = int(input())
  
  total = 0
  
  for number in range(start, start + count):
      total += number ** power
  
  print(total)
```

### Check Your Understanding

```hint title="üéØ Quick Knowledge Check"
These questions assess loop intuition and strategic thinking behind choosing appropriate loop types.
```

```quiz
id: comprehensive_loops
question: "You need to process user input until they enter 'quit', but you don't know how many inputs there will be. Which loop type is most appropriate?"
options:
  - id: a
    text: "For loop with range(1000) to handle many inputs"
    correct: false
    explanation: "This is inefficient and arbitrary. What if they want to enter 1001 items?"
  - id: b
    text: "While loop that continues until input equals 'quit'"
    correct: true
    explanation: "Perfect! While loops are ideal when you don't know how many iterations you need."
  - id: c
    text: "Nested for loops"
    correct: false
    explanation: "Nested loops are for when you need loops within loops, not for unknown iteration counts."
  - id: d
    text: "No loop needed - use if/else statements"
    correct: false
    explanation: "If/else statements don't repeat - you'd need a loop for multiple inputs."
```

```quiz
id: loop_integration
question: "You're building a grade calculator that needs to process an unknown number of students, and for each student you need to collect exactly 4 test scores. What's the best approach?"
options:
  - id: a
    text: "Use only for loops for everything"
    correct: false
    explanation: "For loops work for the 4 test scores, but not for the unknown number of students."
  - id: b
    text: "Use only while loops for everything"
    correct: false
    explanation: "While loops work for the unknown students, but for loops are better when you know you need exactly 4 scores."
  - id: c
    text: "Use a while loop for students, and a for loop for the 4 test scores per student"
    correct: true
    explanation: "Perfect! This combines both loop types strategically - while for unknown quantities, for for known quantities."
  - id: d
    text: "Use nested for loops"
    correct: false
    explanation: "For loops require knowing the count ahead of time, but we don't know how many students there will be."
```

## Loop Mastery Complete

```note title="üéâ Congratulations, Loop Master!"
Loops represent a fundamental concept in programming and computational thinking. This foundation enables solving complex problems with efficient code.

**This is a major milestone in your programming journey!** üöÄ
```

Summary of loop capabilities:

### For Loops - Precision Instrument

- Master `range()` with start, stop, and step values
- Create patterns and calculate totals efficiently
- Handle nested loops for 2D patterns and complex processing
- Use when you know the iteration count

### While Loops - Flexible Powerhouse

- Handle uncertainty with grace and control
- Perfect for validation and interactive programs
- Build interactive systems and user-driven programs
- Combine with flags for precise flow control
- Use when repeating until a condition is met

### Strategic Loop Thinking - Decision Framework

- Known count? ‚Üí For loop
- Unknown count but clear condition? ‚Üí While loop
- Need 2D patterns or grids? ‚Üí Nested loops

### Programming Patterns Toolkit

- **Accumulation** ‚Üí Building up totals or collections
- **Counting** ‚Üí Tracking quantities that meet criteria
- **Validation** ‚Üí Ensuring user input is correct
- **Menu Systems** ‚Üí Creating interactive, user-controlled programs

```hint title="üîç The Secret to Loop Mastery"
**You've unlocked the most important skill:** recognizing repetitive patterns! 

Now when you see repetitive tasks, your brain automatically thinks: *"This is a job for a loop!"* üí°

**This pattern-recognition mindset** will serve you throughout your entire programming career. You're now thinking like a real programmer!
```

## Programming Journey Continues

```note title="üèÜ The Foundation is Complete!"
You've now mastered the **three fundamental building blocks** of programming:

1Ô∏è‚É£ **Variables** ‚Üí storing and managing data  
2Ô∏è‚É£ **Conditionals** ‚Üí making intelligent decisions  
3Ô∏è‚É£ **Loops** ‚Üí automating repetitive tasks  

These three concepts provide the foundation for solving a wide variety of programming problems.
```

### Chapter 4 Preview

Chapter 4 introduces lists, which enable efficient storage and processing of data collections.

Imagine combining everything you know:
- üîÑ **Loops** that process lists of data
- üß† **Conditionals** that make decisions about each item  
- üìä **Variables** that store your results

**You'll be able to:**

‚ú® Process thousands of data points in seconds  
‚ú® Build sophisticated applications with complex logic  
‚ú® Implement classic algorithms used throughout computer science  
‚ú® Create programs that solve real-world problems  

```hint title="üéÜ You're No Longer a Beginner!"
The foundation established here will support future learning. These skills provide the basis for advanced programming concepts.
```